<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta name="google-site-verification" content="4xeRrGz75ndIdizFDms5sFLsaZXJ4UfzKvxLBsSZKS8"><meta name="robots" content="index, follow"><title>标签: iOS面试题 - 人间正道</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="人间正道是沧桑"><meta name="msapplication-TileImage" content="images/faviconNew.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="人间正道是沧桑"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:type" content="blog"><meta property="og:title" content="人间正道"><meta property="og:url" content="https://despacito2.github.io/"><meta property="og:site_name" content="人间正道"><meta property="og:description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://despacito2.github.io/img/og_image.png"><meta property="article:author" content="人间正道"><meta property="article:tag" content="编程"><meta property="article:tag" content="技术博客"><meta property="article:tag" content="工具推荐"><meta property="article:tag" content="人间正道"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://despacito2.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://despacito2.github.io/"},"headline":"人间正道","image":["https://despacito2.github.io/img/og_image.png"],"author":{"@type":"Person","name":"人间正道"},"publisher":{"@type":"Organization","name":"人间正道","logo":{"@type":"ImageObject","url":"https://despacito2.github.io/images/logo.png"}},"description":"一个记录编程笔记、技术工具和个人成长思考的博客。"}</script><link rel="icon" href="/images/faviconNew.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-4191566366727150" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/page">好文收录</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">iOS面试题</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:55:35.000Z" title="2024/3/2 22:55:35">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">14 分钟读完 (大约2073个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A7%86%E5%9B%BE%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%AF%87/">大厂常问iOS面试题--视图和图形篇</a></p><div class="content"><p>本篇我们来讲一下 【iOS面试题的视图&amp;图形】相关的问题.</p>
<h2 id="视图-图像相关"><a href="#视图-图像相关" class="headerlink" title="视图&amp;图像相关"></a>视图&amp;图像相关</h2><p>主要问题列表如下:</p>
<ol>
<li>AutoLayout的原理，性能如何</li>
<li>UIView &amp; CALayer的区别</li>
<li>事件响应链</li>
<li>drawrect &amp; layoutsubviews调用时机</li>
<li>UI的刷新原理</li>
<li>隐式动画 &amp; 显示动画区别</li>
<li>什么是离屏渲染</li>
<li>imageName&amp;imageWithContentsOfFile区别</li>
<li>多个相同的图片，会重复加载吗</li>
<li>图片是什么时候解码的，如何优化</li>
<li>图片渲染怎么优化</li>
<li>如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</li>
</ol>
<h3 id="1-AutoLayout的原理，性能如何"><a href="#1-AutoLayout的原理，性能如何" class="headerlink" title="1.AutoLayout的原理，性能如何?"></a>1.AutoLayout的原理，性能如何?</h3><h4 id="AutoLayout的原理"><a href="#AutoLayout的原理" class="headerlink" title="AutoLayout的原理"></a>AutoLayout的原理</h4><blockquote>
<p>来历 一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（<a target="_blank" rel="noopener" href="http://constraints.cs.washington.edu/solvers/uist97.html">论文地址:http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的<a target="_blank" rel="noopener" href="http://constraints.cs.washington.edu/cassowary/">Cassowary网站上http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的<a target="_blank" rel="noopener" href="https://github.com/pybee/cassowary%E3%80%82%E8%87%AA%E4%BB%8E%E5%AE%83%E5%8F%91%E5%B8%83%E4%BB%A5%E6%9D%A5JavaScript%EF%BC%8C.NET%EF%BC%8CJAVA%EF%BC%8CSmalltall%E5%92%8CC++%E9%83%BD%E6%9C%89%E7%9B%B8%E5%BA%94%E7%9A%84%E5%BA%93%E3%80%822011%E5%B9%B4%E8%8B%B9%E6%9E%9C%E5%B0%86%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E8%BF%90%E7%94%A8%E5%88%B0%E4%BA%86%E8%87%AA%E5%AE%B6%E7%9A%84%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E%E4%B8%AD%EF%BC%8C%E7%BE%8E%E5%85%B6%E5%90%8D%E6%9B%B0Auto">https://github.com/pybee/cassowary。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto</a> Layout。</p>
</blockquote>
<p>论文下载链接比较慢,我下载了一份<a target="_blank" rel="noopener" href="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/Cassowary.pdf">Cassowary原文放到了我的博客 大家可以自由下载</a>.</p>
<p><strong>AutoLayout的原理就是用Cassowary算法来将布局问题抽象成线性不等式，并分解成多个位置间的约束</strong> 因为多了计算视图大小frame的过程,所以性能肯定没有指定Frame坐标要快.</p>
<p>详细的原理以及高阶原理请参考戴铭老师的文章 <a target="_blank" rel="noopener" href="http://www.starming.com/2015/11/03/deeply-analyse-autolayout/">戴铭老师写的 深入剖析Auto Layout，分析iOS各版本新增特性</a></p>
<h4 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何?"></a>性能如何?</h4><p>下面是<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/220/">WWDC2018 High Performance Auto Layout</a>中对比的iOS12和iOS11下分别使用自动布局的性能对比现场.</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/HighPerformanceAutoLayoutiOS11iOS12Compare.gif"><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A21.gif"></a></p>
<p>经过实验得出如下图标结论:</p>
<p><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A22.jpg"></p>
<p>iOS12之前，视图嵌套的数量对性能的影响是呈指数级增长的，而iOS12优化之后对性能的影响是线性增长，对性能消耗不大。</p>
<p>无论如何优化也肯定不如CGRectFrame那样的设置更加直接,性能更好.</p>
<h3 id="2-UIView-CALayer的区别"><a href="#2-UIView-CALayer的区别" class="headerlink" title="2.UIView &amp; CALayer的区别"></a>2.UIView &amp; CALayer的区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>UIView</th>
<th>CALayer</th>
</tr>
</thead>
<tbody><tr>
<td>继承父类</td>
<td>UIView:UIResponder:NSObject</td>
<td>CALayer:NSObject</td>
</tr>
<tr>
<td>用途</td>
<td>可以处理触摸事件</td>
<td>不处理用户的交互,不参与响应事件传递</td>
</tr>
<tr>
<td>两者关系</td>
<td>有一个CALayer成员变量 eg: view.layer</td>
<td>是UIView的成员变量</td>
</tr>
<tr>
<td>分工</td>
<td>处理交互层事件并包装各种图形的简单设置</td>
<td>底层渲染图形,支持动画</td>
</tr>
</tbody></table>
<h3 id="3-事件响应链"><a href="#3-事件响应链" class="headerlink" title="3.事件响应链"></a>3.事件响应链</h3><p>下面这篇文章我已经在前几篇将runloop的时候提了不止一次,前列建议阅读,快手的同事大部分都以这个理解为标准</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a></p>
<h3 id="4-drawrect-layoutsubviews调用时机"><a href="#4-drawrect-layoutsubviews调用时机" class="headerlink" title="4. drawrect &amp; layoutsubviews调用时机"></a>4. drawrect &amp; layoutsubviews调用时机</h3><p><code>layoutSubviews:</code>(相当于layoutSubviews()函数)在以下情况下会被调用：</p>
<ol>
<li>init初始化不会触发layoutSubviews。</li>
<li>addSubview会触发layoutSubviews。</li>
<li>设置view的Frame会触发layoutSubviews (frame发生变化触发)。</li>
<li>滚动一个UIScrollView会触发layoutSubviews。</li>
<li>旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>直接调用setLayoutSubviews。</li>
</ol>
<p><code>drawrect:</code>(drawrect()函数)在以下情况下会被调用：</p>
<ol>
<li><code>drawrect:</code>是在UIViewController的<code>loadView:</code>和<code>ViewDidLoad:</code>方法之后调用.</li>
<li>当我们调用<code>[UIFont的 sizeToFit]</code>后,会触发系统自动调用<code>drawRect:</code></li>
<li>当设置UIView的contentMode或者Frame后会立即触发触发系统调用<code>drawRect:</code></li>
<li>直接调用<code>setNeedsDisplay</code>设置标记 或<code>setNeedsDisplayInRect:</code>的时候会触发<code>drawRect:</code></li>
</ol>
<blockquote>
<p>知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a120d6c64d88">UIView的渲染过程</a>.</p>
</blockquote>
<h3 id="5-UI的刷新原理"><a href="#5-UI的刷新原理" class="headerlink" title="5.UI的刷新原理"></a>5.UI的刷新原理</h3><p>这个问题我不知道问的是不是iOS离屏渲染过程,我来简单的回到一下这个吧</p>
<p>iOS 的<code>MainRunloop</code> 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕在这过程中要完成以下的工作:</p>
<ul>
<li>view的缓冲区创建</li>
<li>view内容的绘制(如果重写了 drawRect)</li>
<li>接收和处理系统的触摸事件</li>
</ul>
<p>我们看到的UI图形实际上是CPU和GPU不断配合工作的结果.经过<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a120d6c64d88">UIView的渲染过程</a> 后我们的UI会不间断的接收系统图给我们的事件.</p>
<p>由于主线程的runloop 一直在回调,我们的UI就得到了刷新的窗口,是渲染还是处理事件都是因为runloop不断工作的结果.前几篇我们学过 main线程的runloop默认是启动的.因为我们响应交互.</p>
<p>不知道我这样回答是否满足这个问题的答案.如果回答的不对烦请下方评论区留言 告知我将持续改进.</p>
<h3 id="6-隐式动画-显示动画区别"><a href="#6-隐式动画-显示动画区别" class="headerlink" title="6.隐式动画 &amp; 显示动画区别"></a>6.隐式动画 &amp; 显示动画区别</h3><p>隐式动画一直存在 如需关闭需设置 显式动画是不存在，如需显式 要开启</p>
<p>只需要观察动画执行完成的结果 比如: 一个简单UIView的frame移动 如果从A点移动到B点 移动完成 回到原始位置就是隐式动画</p>
<p>Core Animation 是显式动画.因为它既可以直接对其layer属性做动画，也可以覆盖默认的图层行为.</p>
<h3 id="7-imageName-imageWithContentsOfFile区别"><a href="#7-imageName-imageWithContentsOfFile区别" class="headerlink" title="7.imageName&amp;imageWithContentsOfFile区别"></a>7.imageName&amp;imageWithContentsOfFile区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>UIView</th>
<th>imageWithContentsOfFile</th>
</tr>
</thead>
<tbody><tr>
<td>不同点</td>
<td>会图片缓存到内存中</td>
<td>无缓存</td>
</tr>
</tbody></table>
<h3 id="8-什么是离屏渲染"><a href="#8-什么是离屏渲染" class="headerlink" title="8.什么是离屏渲染"></a>8.什么是离屏渲染</h3><p><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A23.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72653360">iOS离屏渲染的深入研究</a></p>
<h3 id="9-多个相同的图片，会重复加载吗"><a href="#9-多个相同的图片，会重复加载吗" class="headerlink" title="9.多个相同的图片，会重复加载吗"></a>9.多个相同的图片，会重复加载吗</h3><p>不会,GPU有 像素点缓存的mask.</p>
<h3 id="10-图片是什么时候解码的，如何优化"><a href="#10-图片是什么时候解码的，如何优化" class="headerlink" title="10.图片是什么时候解码的，如何优化"></a>10.图片是什么时候解码的，如何优化</h3><p>是加载到内存中,从UIImge-&gt;CGImage-&gt;CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码.</p>
<h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>自己手动操作图片的编码API</p>
<p>CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库.</p>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/pinterest/PINRemoteImage">PINRemoteImage</a>或者<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage">YYWebImage</a>开源</p>
<h3 id="11-图片渲染怎么优化"><a href="#11-图片渲染怎么优化" class="headerlink" title="11.图片渲染怎么优化"></a>11.图片渲染怎么优化</h3><p>可以从阴影,圆角入手.帧率,电量,图片的锯齿等等.</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/748f9abafff8">iOS开发-视图渲染与性能优化</a></p>
<h3 id="12-如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决"><a href="#12-如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决" class="headerlink" title="12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决"></a>12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</h3><p>现象是 图形清晰,场景逼真,但是一般arm芯片的GPU 刷新超过60Hz一定会超级费电,手机发热导致降频.FPS降低,因为低能耗电量不足,无法支持GPU高刷新率</p>
<p>解决办法只能用xcode自带工具检测,看渲染过程哪里可以优化.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单回答了一些图形相关的问题,大部分都是iOS离屏渲染,这个地方大家要认真学习.很多资料看起来比较耗时.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:38:52.000Z" title="2024/3/2 22:38:52">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">28 分钟读完 (大约4194个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E7%AF%87/">大厂常问iOS面试题--通知机制解析篇</a></p><div class="content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是针对<code>iOS通知机制</code>的全面解析，从接口到原理面面俱到。同时也解决了<code>阿里、字节：一套高效的iOS面试题</code>中关于通知的问题，相信看完此文再也不怕面试官问我任何通知相关问题了</p>
<p>由于苹果没有对相关源码开放，所以以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计</p>
<h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>先把之前的问题列出来，详细读完本文之后，你会找到答案</p>
<ol>
<li>实现原理（结构设计、通知如何存储的、<code>name&amp;observer&amp;SEL</code>之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li><code>NSNotificationCenter</code>接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li><code>NSNotificationQueue</code>是异步还是同步发送？在哪个线程响应</li>
<li><code>NSNotificationQueue</code>和<code>runloop</code>的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="关键类结构"><a href="#关键类结构" class="headerlink" title="关键类结构"></a>关键类结构</h1><h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><p>用于描述通知的类，一个<code>NSNotification</code>对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line">...</span><br><span class="line">/* Querying a Notification Object */</span><br><span class="line"></span><br><span class="line">- (NSString*) name; // 通知的name</span><br><span class="line">- (id) object; // 携带的对象</span><br><span class="line">- (NSDictionary*) userInfo; // 配置信息</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般用于发送通知时使用，常用api如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而<code>NSNotificationCenter</code>类主要负责三件事</p>
<ol>
<li>添加通知</li>
<li>发送通知</li>
<li>移除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加通知</span><br><span class="line">- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">// 发送通知</span><br><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">// 删除通知</span><br><span class="line">- (void)removeObserver:(id)observer;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用<code>NSNotificationCenter</code>的发送接口进行发送通知，这么看<code>NSNotificationQueue</code>最终还是调用<code>NSNotificationCenter</code>进行消息的分发</p>
<p>另外<code>NSNotificationQueue</code>是依赖<code>runloop</code>的，所以如果线程的<code>runloop</code>未开启则无效，至于为什么依赖<code>runloop</code>下面会解释</p>
<p><code>NSNotificationQueue</code>主要做了两件事：</p>
<ol>
<li>添加通知到队列</li>
<li>删除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍</span><br><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</span><br><span class="line">// 删除通知，把满足合并条件的通知从队列中删除</span><br><span class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="队列的合并策略和发送时机"><a href="#队列的合并策略和发送时机" class="headerlink" title="队列的合并策略和发送时机"></a>队列的合并策略和发送时机</h3><p>把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br><span class="line">// 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</span><br><span class="line">    NSNotificationNoCoalescing = 0, // 默认不合并</span><br><span class="line">    NSNotificationCoalescingOnName = 1, // 只要name相同，就认为是相同通知</span><br><span class="line">    NSNotificationCoalescingOnSender = 2  // object相同</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="GSNotificationObserver"><a href="#GSNotificationObserver" class="headerlink" title="GSNotificationObserver"></a>GSNotificationObserver</h2><p>这个类是<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码中定义的，它的作用是代理观察者，主要用来实现接口：<code>addObserverForName：object: queue: usingBlock:</code>时用到，即要实现在指定队列回调block，那么<code>GSNotificationObserver</code>对象保存了<code>queue</code>和<code>block</code>信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把<code>block</code>抛到指定<code>queue</code>中执行，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@implementation GSNotificationObserver</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *_queue; // 保存传入的队列</span><br><span class="line">    GSNotificationBlock _block; // 保存传入的block</span><br><span class="line">&#125;</span><br><span class="line">- (id) initWithQueue: (NSOperationQueue *)queue </span><br><span class="line">               block: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">......初始化操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) dealloc</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">// 响应接收通知的方法，并在指定队列中执行block</span><br><span class="line">- (void) didReceiveNotification: (NSNotification *)notif</span><br><span class="line">&#123;</span><br><span class="line">    if (_queue != nil)</span><br><span class="line">    &#123;</span><br><span class="line">        GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] </span><br><span class="line">            initWithNotification: notif block: _block];</span><br><span class="line"></span><br><span class="line">        [_queue addOperation: op];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        CALL_BLOCK(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="存储容器"><a href="#存储容器" class="headerlink" title="存储容器"></a>存储容器</h2><p>上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation        *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable        nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable        named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct    Obs &#123;</span><br><span class="line">  id        observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL        selector;    /* 响应方法        */</span><br><span class="line">  struct Obs    *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h1><p>正式开始“注册通知”的深入研究，注册通知有几个常用方法，但只需要研究典型的一两个就够了，原理都是一样的</p>
<p>目前只介绍<code>NSNotificationCenter</code>的注册流程，<code>NSNotificationQueue</code>的方式在下面章节单独拎出来解释</p>
<h2 id="接口1"><a href="#接口1" class="headerlink" title="接口1"></a>接口1</h2><h3 id="直接看源码（精简版便于理解）"><a href="#直接看源码（精简版便于理解）" class="headerlink" title="直接看源码（精简版便于理解）"></a>直接看源码（精简版便于理解）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer：观察者，即通知的接收者</span><br><span class="line">selector：接收到通知时的响应方法</span><br><span class="line">name: 通知name</span><br><span class="line">object：携带对象</span><br><span class="line">*/</span><br><span class="line">- (void) addObserver: (id)observer</span><br><span class="line">            selector: (SEL)selector</span><br><span class="line">                name: (NSString*)name </span><br><span class="line">                object: (id)object &#123;</span><br><span class="line">  // 前置条件判断</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它</span><br><span class="line">  o = obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">/*======= case1： 如果name存在 =======*/</span><br><span class="line">  if (name) &#123;</span><br><span class="line">     //-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable</span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</span><br><span class="line">      if (n == 0) &#123; // 不存在，则创建 </span><br><span class="line">          m = mapNew(TABLE); // 先取缓存，如果缓存没有则新建一个map</span><br><span class="line">          GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在则把值取出来 赋值给m</span><br><span class="line">          m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">      &#125;</span><br><span class="line">     //-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节</span><br><span class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      if (n == 0) &#123;// 不存在，则创建 </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next = list-&gt;next;</span><br><span class="line">          list-&gt;next = o;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case2：如果name为空，但object不为空 =======*/</span><br><span class="line">  else if (object) &#123;</span><br><span class="line">      // 以object为key，从nameless字典中取出对应的value，value是个链表结构</span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      // 不存在则新建链表，并存到map中</span><br><span class="line">      if (n == 0) &#123; </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在 则把值接到链表的节点上</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case3：name 和 object 都为空 则存储到wildcard链表中 =======*/</span><br><span class="line">  else &#123;</span><br><span class="line">      o-&gt;next = WILDCARD;</span><br><span class="line">      WILDCARD = o;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>从上面介绍的<code>存储容器</code>中我们了解到<code>NCTable</code>结构体中核心的三个变量以及功能：<code>wildcard</code>、<code>named</code>、<code>nameless</code>，在源码中直接用宏定义表示了：<code>WILDCARD</code>、<code>NAMELESS</code>、<code>NAMED</code>，下面逻辑会用到</p>
<p>建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图</p>
<h4 id="case1-存在name（无论object是否存在）"><a href="#case1-存在name（无论object是否存在）" class="headerlink" title="case1: 存在name（无论object是否存在）"></a>case1: 存在<code>name</code>（无论object是否存在）</h4><ol>
<li>注册通知，如果通知的<code>name</code>存在，则以<code>name</code>为key从<code>named</code>字典中取出值<code>n</code>(这个<code>n</code>其实被<code>MapNode</code>包装了一层，便于理解这里直接认为没有包装)，这个<code>n</code>还是个字典，各种判空新建逻辑不讨论</li>
<li>然后以<code>object</code>为key，从字典<code>n</code>中取出对应的值，这个值就是<code>Observation</code>类型(后面简称<code>obs</code>)的链表，然后把刚开始创建的<code>obs</code>对象<code>o</code>存储进去</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p>这里就回答了上述<code>问题列表</code>的问题1的一部分，现在梳理下存储关系</p>
<p><img src="/images/NSNotification1.jpg"></p>
<p>如果注册通知时传入<code>name</code>，那么会是一个双层的存储结构</p>
<ol>
<li>找到<code>NCTable</code>中的<code>named</code>表，这个表存储了还有<code>name</code>的通知</li>
<li>以<code>name</code>作为key，找到<code>value</code>，这个<code>value</code>依然是一个<code>map</code></li>
<li><code>map</code>的结构是以<code>object</code>作为key，<code>obs</code>对象为value，这个<code>obs</code>对象的结构上面已经解释，主要存储了<code>observer &amp; SEL</code></li>
</ol>
<h4 id="case2-只存在object"><a href="#case2-只存在object" class="headerlink" title="case2: 只存在object"></a>case2: 只存在object</h4><ol>
<li>以<code>object</code>为key，从<code>nameless</code>字典中取出value，此value是个<code>obs</code>类型的链表</li>
<li>把创建的<code>obs</code>类型的对象<code>o</code>存储到链表中</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>只存在<code>object</code>时存储只有一层，那就是<code>object</code>和<code>obs</code>对象之间的映射</p>
<h4 id="case3-没有name和object"><a href="#case3-没有name和object" class="headerlink" title="case3: 没有name和object"></a>case3: 没有name和object</h4><p>这种情况直接把<code>obs</code>对象存放在了<code>Observation  *wildcard</code>  链表结构中</p>
<h2 id="接口2"><a href="#接口2" class="headerlink" title="接口2"></a>接口2</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>接口功能：</strong> 此接口实现的功能是在接收到通知时，在指定队列<code>queue</code>执行<code>block</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 这个api使用频率较低，怎么实现在指定队列回调block的，值得研究</span><br><span class="line">- (id) addObserverForName: (NSString *)name </span><br><span class="line">                   object: (id)object </span><br><span class="line">                    queue: (NSOperationQueue *)queue </span><br><span class="line">               usingBlock: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个临时观察者</span><br><span class="line">    GSNotificationObserver *observer = </span><br><span class="line">        [[GSNotificationObserver alloc] initWithQueue: queue block: block];</span><br><span class="line">    // 调用了接口1的注册方法</span><br><span class="line">    [self addObserver: observer </span><br><span class="line">             selector: @selector(didReceiveNotification:) </span><br><span class="line">                 name: name </span><br><span class="line">               object: object];</span><br><span class="line"></span><br><span class="line">    return observer;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明-1"><a href="#逻辑说明-1" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>这个接口依赖于<code>接口1</code>，只是多了一层代理观察者<code>GSNotificationObserver</code>，在<code>关键类结构</code>中已经介绍了它，设计思路值得学习</p>
<ol>
<li>创建一个<code>GSNotificationObserver</code>类型的对象<code>observer</code>，并把<code>queue</code>和<code>block</code>保存下来</li>
<li>调用接口1进行通知的注册</li>
<li>接收到通知时会响应<code>observer</code>的<code>didReceiveNotification:</code>方法，然后在<code>didReceiveNotification:</code>中把<code>block</code>抛给指定的<code>queue</code>去执行</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>从上述介绍可以总结，存储是以<code>name</code>和<code>object</code>为维度的，即判定是不是同一个通知要从<code>name</code>和<code>object</code>区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的，<code>问题列表</code>中的第九题也迎刃而解了</li>
<li>理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑</li>
<li>存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次</li>
</ol>
<h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>发送通知的核心逻辑比较简单，基本上就是查找和调用响应方法，核心函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">- (void) postNotificationName: (NSString*)name</span><br><span class="line">               object: (id)object</span><br><span class="line">             userInfo: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line">// 构造一个GSNotification对象， GSNotification继承了NSNotification</span><br><span class="line">  GSNotification    *notification;</span><br><span class="line">  notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone());</span><br><span class="line">  notification-&gt;_name = [name copyWithZone: [self zone]];</span><br><span class="line">  notification-&gt;_object = [object retain];</span><br><span class="line">  notification-&gt;_info = [info retain];</span><br><span class="line"></span><br><span class="line">  // 进行发送操作</span><br><span class="line">  [self _postAndRelease: notification];</span><br><span class="line">&#125;</span><br><span class="line">//发送通知的核心函数，主要做了三件事：查找通知、发送、释放资源</span><br><span class="line">- (void) _postAndRelease: (NSNotification*)notification &#123;</span><br><span class="line">    //step1: 从named、nameless、wildcard表中查找对应的通知</span><br><span class="line">    ...</span><br><span class="line">    //step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的</span><br><span class="line">       [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                    withObject: notification];</span><br><span class="line">    //step3: 释放资源</span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="逻辑说明-2"><a href="#逻辑说明-2" class="headerlink" title="逻辑说明"></a>逻辑说明</h2><p>其实上述代码注释说的很清晰了，主要做了三件事</p>
<ol>
<li>通过<code>name &amp; object</code> 查找到所有的<code>obs</code>对象(保存了<code>observer</code>和<code>sel</code>)，放到数组中</li>
<li>通过<code>performSelector：</code>逐一调用<code>sel</code>，这是个同步操作</li>
<li>释放<code>notification</code>对象</li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>从源码逻辑可以看出发送过程的概述：从三个存储容器中：<code>named</code>、<code>nameless</code>、<code>wildcard</code>去查找对应的<code>obs</code>对象，然后通过<code>performSelector：</code>逐一调用响应方法，这就完成了发送流程</p>
<p><strong>核心点：</strong></p>
<ol>
<li>同步发送</li>
<li>遍历所有列表，即注册多次通知就会响应多次</li>
</ol>
<h1 id="删除通知"><a href="#删除通知" class="headerlink" title="删除通知"></a>删除通知</h1><p>这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">源码</a>看下吧 <strong>要注意的点：</strong></p>
<ol>
<li>查找时仍然以<code>name</code>和<code>object</code>为维度的，再加上<code>observer</code>做区分</li>
<li>因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 删除已经注册的通知</span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">           name: (NSString*)name</span><br><span class="line">                 object: (id)object &#123;</span><br><span class="line">  if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil)</span><br><span class="line">      return;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">&#123;</span><br><span class="line">  if (observer == nil)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  [self removeObserver: observer name: nil object: nil];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h1><p>上面介绍的<code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了<code>runloop</code>的时机来触发的</p>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>下面为精简版的源码，看源码的注释，基本上能明白大致逻辑</p>
<ol>
<li>根据<code>coalesceMask</code>参数判断是否合并通知</li>
<li>接着根据<code>postingStyle</code>参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：<code>_asapQueue</code>、<code>_idleQueue</code></li>
</ol>
<p>核心点：</p>
<ol>
<li>队列是双向链表实现</li>
<li>当postingStyle值是立即发送时，调用的是<code>NSNotificationCenter</code>进行发送的，所以<code>NSNotificationQueue</code>还是依赖<code>NSNotificationCenter</code>进行发送</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 把要发送的通知添加到队列，等待发送</span><br><span class="line">* NSPostingStyle 和 coalesceMask在上面的类结构中有介绍</span><br><span class="line">* modes这个就和runloop有关了，指的是runloop的mode</span><br><span class="line">*/ </span><br><span class="line">- (void) enqueueNotification: (NSNotification*)notification</span><br><span class="line">        postingStyle: (NSPostingStyle)postingStyle</span><br><span class="line">        coalesceMask: (NSUInteger)coalesceMask</span><br><span class="line">            forModes: (NSArray*)modes</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">  // 判断是否需要合并通知</span><br><span class="line">  if (coalesceMask != NSNotificationNoCoalescing) &#123;</span><br><span class="line">      [self dequeueNotificationsMatching: notification</span><br><span class="line">                coalesceMask: coalesceMask];</span><br><span class="line">  &#125;</span><br><span class="line">  switch (postingStyle) &#123;</span><br><span class="line">      case NSPostNow: &#123;</span><br><span class="line">          ...</span><br><span class="line">          // 如果是立马发送，则调用NSNotificationCenter进行发送</span><br><span class="line">         [_center postNotification: notification];</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      case NSPostASAP:</span><br><span class="line">          // 添加到_asapQueue队列，等待发送</span><br><span class="line">        add_to_queue(_asapQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case NSPostWhenIdle:</span><br><span class="line">        // 添加到_idleQueue队列，等待发送</span><br><span class="line">        add_to_queue(_idleQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="发送通知-1"><a href="#发送通知-1" class="headerlink" title="发送通知"></a>发送通知</h2><p>这里截取了发送通知的核心代码，这个发送通知逻辑如下：</p>
<ol>
<li><code>runloop</code>触发某个时机，调用<code>GSPrivateNotifyASAP()</code>和<code>GSPrivateNotifyIdle()</code>方法，这两个方法最终都调用了<code>notify()</code>方法</li>
<li><code>notify()</code>所做的事情就是调用<code>NSNotificationCenter</code>的<code>postNotification:</code>进行发送通知</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void notify(NSNotificationCenter *center, </span><br><span class="line">                   NSNotificationQueueList *list,</span><br><span class="line">                   NSString *mode, NSZone *zone)</span><br><span class="line">&#123;</span><br><span class="line">     ......</span><br><span class="line">    // 循环遍历发送通知</span><br><span class="line">    for (pos = 0; pos &lt; len; pos++)</span><br><span class="line">    &#123;</span><br><span class="line">      NSNotification    *n = (NSNotification*)ptr[pos];</span><br><span class="line"></span><br><span class="line">      [center postNotification: n];</span><br><span class="line">      RELEASE(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br><span class="line">// 发送_asapQueue中的通知</span><br><span class="line">void GSPrivateNotifyASAP(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_asapQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line">// 发送_idleQueue中的通知</span><br><span class="line">void GSPrivateNotifyIdle(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_idleQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>对于<code>NSNotificationQueue</code>总结如下</p>
<ol>
<li>依赖<code>runloop</code>，所以如果在其他子线程使用<code>NSNotificationQueue</code>，需要开启runloop</li>
<li>最终还是通过<code>NSNotificationCenter</code>进行发送通知，所以这个角度讲它还是同步的</li>
<li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li>
</ol>
<h1 id="主线程响应通知"><a href="#主线程响应通知" class="headerlink" title="主线程响应通知"></a>主线程响应通知</h1><p>异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？</p>
<p>其实也是比较常见的问题了，基本上解决方式如下几种：</p>
<ol>
<li>使用<code>addObserverForName: object: queue: usingBlock</code>方法注册通知，指定在<code>mainqueue</code>上响应<code>block</code></li>
<li>在主线程注册一个<code>machPort</code>，它是用来做线程通信的，当在异步线程收到通知，然后给<code>machPort</code>发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文写的内容比较多，以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，全面阐述了通知的存储、发送、异步发送等原理，对研究学习有很大帮助</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:26:19.000Z" title="2024/3/2 22:26:19">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">12 分钟读完 (大约1866个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Runloop%E5%92%8CKVO%E7%AF%87/">大厂常问iOS面试题--Runloop&amp;KVO篇</a></p><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天这一篇我们来讲一下 Runloop和KVO</p>
<p>本章的主要回答的问题如下:</p>
<h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><ul>
<li>app如何接收到触摸事件的</li>
<li>为什么只有主线程的runloop是开启的</li>
<li>为什么只在主线程刷新UI</li>
<li>PerformSelector和runloop的关系</li>
<li>如何使线程保活</li>
</ul>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><ul>
<li>实现原理</li>
<li>如何手动关闭kvo</li>
<li>通过KVC修改属性会触发KVO么</li>
<li>哪些情况下使用kvo会崩溃，怎么防护崩溃</li>
<li>kvo的优缺点</li>
</ul>
<h2 id="Runloop-1"><a href="#Runloop-1" class="headerlink" title="Runloop"></a>Runloop</h2><p>作为一个合格的iOS开发者必须对runloop有一个更深入的了解,下面我们来回答一下 相关问题</p>
<h3 id="1-app如何接收到触摸事件的"><a href="#1-app如何接收到触摸事件的" class="headerlink" title="1.app如何接收到触摸事件的"></a>1.app如何接收到触摸事件的</h3><p>回答这个问题前请认真阅读一下 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a></p>
<p><img src="/images/Runloop&KVO.jpg"></p>
<p>通过上图可以看出整个流程就是 我们app启动默认会通过machPort监听端口的方式 来接受IOHIDEvent 来接收和处理触摸事件.</p>
<h3 id="2-为什么只有主线程的runloop是开启的"><a href="#2-为什么只有主线程的runloop是开启的" class="headerlink" title="2.为什么只有主线程的runloop是开启的"></a>2.为什么只有主线程的runloop是开启的</h3><p>mian()函数中调用UIApplicationMain，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行并接收事件，所以在主线程中开启一个runloop，让主线程常驻.</p>
<h3 id="3-为什么只在主线程刷新UI"><a href="#3-为什么只在主线程刷新UI" class="headerlink" title="3.为什么只在主线程刷新UI"></a>3.为什么只在主线程刷新UI</h3><p>我们所有用到的UI都是来自于UIKit这个基础库.因为objc不是一门线程安全的语言所以存在多线程读写不同步的问题,如果使用加锁的方式操作系统开销很大,会耗费大量的系统资源(内存、时间片轮转、cpu处理速度…)，加上上面讲到的系统事件的接收处理都在主线程,如果UI异步线程的话 还会存在 同步处理事件的问题,所以多点触摸手势等一些事件要保持和UI在同一个线程相对是最优解.</p>
<p>另一方面是 屏幕的渲染是 60帧(60Hz&#x2F;秒), 也就是1秒钟回调60次的频率,(iPad Pro 是120Hz&#x2F;秒),我们的runloop 理想状态下也会按照时钟周期 回调60次(iPad Pro 120次), 这么高频率的调用是为了 屏幕图像显示能够垂直同步 不卡顿.在异步线程的话是很难保证这个处理过程的同步更新. 即便能保证的话 相对主线程而言 系统资源开销 线程调度等等将会占据大部分资源和在同一个线程只专门干一件事有点得不偿失.</p>
<h3 id="4-PerformSelector和runloop的关系"><a href="#4-PerformSelector和runloop的关系" class="headerlink" title="4.PerformSelector和runloop的关系"></a>4.PerformSelector和runloop的关系</h3><p>当调用NSObect的 performSelector:相关的时候,内部会创建一个timer定时器添加到当前线程的runloop中,如果当前线程没有启动runloop,则该方法不会被调用.</p>
<p>开发中遇到最多的问题就是这个performSelector: 导致对象的延迟释放,这里开发过程中注意一下,可以用单次的NSTimer替代.</p>
<p>详细可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903781755256840">Runloop与performSelector</a></p>
<h3 id="5-如何使线程保活？"><a href="#5-如何使线程保活？" class="headerlink" title="5.如何使线程保活？"></a>5.如何使线程保活？</h3><p>想要线程保活的话就开启该线程的runloop即可,注意:在NSThread执行的方法中添加while(true){}，这样是模拟runloop的运行原理，结合GCD的信号量，在{}代码块中处理任务.</p>
<p>但是注意 开启runloop的方法要正确</p>
<p>如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//测试开启线程</span><br><span class="line">- (void)memoryTest &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">        [thread start];</span><br><span class="line">        [self performSelector:@selector(stopThread) onThread:thread withObject:nil waitUntilDone:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//线程停止</span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSThread *thread = [NSThread currentThread];</span><br><span class="line">    [thread cancel];</span><br><span class="line">&#125;</span><br><span class="line">//运行线程的runloop 注意 意添加的那个空port,否则会出现内存泄露</span><br><span class="line">- (void)run &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        if (!self.emptyPort) &#123;</span><br><span class="line">            self.emptyPort = [NSMachPort port];</span><br><span class="line">        &#125;</span><br><span class="line">        [runLoop addPort:self.emptyPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下列代码用于模拟线程内部做的一些耗时任务</span><br><span class="line">- (void)printSomething &#123;</span><br><span class="line">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    [self performSelector:@selector(printSomething) withObject:nil afterDelay:1];</span><br><span class="line">&#125;</span><br><span class="line">//模拟手动点击按钮 让 runloop停掉</span><br><span class="line">- (void)stopButtonDidClicked:(id)sender &#123;</span><br><span class="line">    [self performSelector:@selector(stopRunloop) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopRunloop &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请参考:<a target="_blank" rel="noopener" href="https://allluckly.cn/%E6%8A%95%E7%A8%BF/tuogao55">iOS开发深入研究Runloop与线程保活</a></p>
<h2 id="KVO-1"><a href="#KVO-1" class="headerlink" title="KVO"></a>KVO</h2><p>在开发过程中我们经常使用KVO,下面解答一下KVO相关的问题.</p>
<h3 id="KVO的实现原理"><a href="#KVO的实现原理" class="headerlink" title="KVO的实现原理"></a>KVO的实现原理</h3><p>通过<code>runtime</code>派生子类的方式 复写相关需要KVO监听的属性,在该属性setter之前和之后调用NSObject的监听方法,这样KVO就实现了属性变换前后的回调.</p>
<p>KVO派生的子类具体格式应该是:<code>NSKVONotifying_+类名</code>的类 eg: NSKVONotifying_Person</p>
<p>下面示例代码为Person类的name添加KVO的模拟实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    _NSSetObjectValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetObjectValueAndNotify &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [super setName:name];</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">    [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了如何动态创建类呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//动态创建XXCustomClass</span><br><span class="line">Class customClass = objc_allocateClassPair([NSObject class], &quot;XXCustomClass&quot;, 0);</span><br><span class="line">// 添加实例变量</span><br><span class="line">class_addIvar(customClass, &quot;age&quot;, sizeof(int), 0, &quot;i&quot;);</span><br><span class="line">// 动态添加方法</span><br><span class="line">class_addMethod(customClass, @selector(hahahha), (IMP)hahahha, &quot;V@:&quot;);</span><br><span class="line"></span><br><span class="line">//需要实现的方法</span><br><span class="line">void hahahha(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;hahahha====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hahahha&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最后注册到运行时环境</span><br><span class="line">objc_registerClassPair(customClass);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">V@:表示方法的参数和返回值</a></p>
</blockquote>
<p>具体原理以及自定义实现KVO可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1136759">KVO详解及底层实现</a></p>
<h3 id="如何手动关闭KVO"><a href="#如何手动关闭KVO" class="headerlink" title="如何手动关闭KVO?"></a>如何手动关闭KVO?</h3><p>被观察的对象复写如下方法 返回<code>NO</code>即可关闭KVO</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关闭后还想触发 KVO的话 修改需要手动调用在变量setter的前后 主动调用 <code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
<h3 id="通过KVC修改属性会触发KVO么"><a href="#通过KVC修改属性会触发KVO么" class="headerlink" title="通过KVC修改属性会触发KVO么?"></a>通过KVC修改属性会触发KVO么?</h3><p>会的</p>
<h3 id="哪些情况下使用kvo会崩溃，怎么防护崩溃？"><a href="#哪些情况下使用kvo会崩溃，怎么防护崩溃？" class="headerlink" title="哪些情况下使用kvo会崩溃，怎么防护崩溃？"></a>哪些情况下使用kvo会崩溃，怎么防护崩溃？</h3><p>使用不当 会crash,比如:</p>
<ul>
<li>添加和移出不是成对出现且存在多线程添加KVO的情况,经常遇到的crash是移出 - 内存dealloc的时候 或者对象销毁前没有正确移出Observer</li>
</ul>
<p>如何防护？</p>
<p>1.注意移出对象 匹配 2.内存野指针问题,一定要在对象销毁前移出观察者 3.可以使用第三方库BlockKit添加KVO,blockkit内部会自动移除Observer避免crash.</p>
<h3 id="KVO的优缺点"><a href="#KVO的优缺点" class="headerlink" title="KVO的优缺点"></a>KVO的优缺点</h3><p>优点:</p>
<ul>
<li>方便两个对象间同步状态(keypath)更加方便,一般都是在A类要观察B类的属性的变化.</li>
<li>非侵入式的得到某内部对象的状态改变并作出响应.(就是在不改变原来对象类的代码情况下即可做出对该对象的状态变化进行监听)</li>
<li>可以嵌入更改前后的两个时机的状态. - 可以通过Keypaths对嵌套对象的监听.</li>
</ul>
<p>缺点:</p>
<ul>
<li>需要手动移除观察者,不移除容易造成crash.</li>
<li>注册和移出成对匹配出现.</li>
<li>keypath参数的类型String, 如果对象的成员变量被重构而变化字符串不会被编译器识别而报错.</li>
<li>实现观察的方式是复写NSObjec的相关KVO的方法,应该更加面向protocol的方式会更好.</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇我们讲了 runloop和KVO相关的内容,这里面最负责的当属runloop如何处理触摸手势事件.建议认真研读相关链接文章.这样才有一个对runloop更深刻的理解。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:08:39.000Z" title="2024/3/2 22:08:39">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">11 分钟读完 (大约1667个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-NSNotification%E7%AF%87/">大厂常问iOS面试题--NSNotification篇</a></p><div class="content"><h3 id="主要内容包含如下"><a href="#主要内容包含如下" class="headerlink" title="主要内容包含如下:"></a>主要内容包含如下:</h3><ul>
<li>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li>NSNotificationQueue是异步还是同步发送？在哪个线程响应</li>
<li>NSNotificationQueue和runloop的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>在解释这些内容之前 强烈建议认真研读一下这篇 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5952c0a3fc62">一文全解iOS通知机制(经典收藏)</a>文章 了解一下大概 所有的问题就迎刃而解了.</p>
<h2 id="实现原理（结构设计、通知如何存储的、name-observer-SEL之间的关系等"><a href="#实现原理（结构设计、通知如何存储的、name-observer-SEL之间的关系等" class="headerlink" title="实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等"></a>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等</h2><p>首先通知中心结构大概分为如下几个类</p>
<ul>
<li><code>NSNotification</code> 通知的模型 name、object、userinfo.</li>
<li><code>NSNotificationCenter</code>通知中心 负责发送<code>NSNotification</code></li>
<li><code>NSNotificationQueue</code>通知队列 负责在某些时机触发 调用<code>NSNotificationCenter</code>通知中心 <code>post</code>通知</li>
</ul>
<p>通知是结构体通过双向链表进行数据存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation        *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable        nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable        named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct    Obs &#123;</span><br><span class="line">  id        observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL        selector;    /* 响应方法        */</span><br><span class="line">  struct Obs    *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>

<p>主要是以<code>key</code> <code>value</code>的形式存储,这里需要重点强调一下 通知以 <code>name</code>和<code>object</code>两个纬度来存储相关通知内容,也就是我们添加通知的时候传入的两个不同的方法. </p>
<p><img src="/images/NSNotification1.jpg"></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>简单理解<code>name</code>&amp;<code>observer</code>&amp;<code>SEL</code>之间的关系就是<code>name</code>作为<code>key</code>, <code>observer</code>作为观察者对象,当合适时机触发就会调用<code>observer</code>的<code>SEL</code>.这基本很简单,如果觉得我说的不准确可以看下文章开头的文章.</p>
<h2 id="通知的发送时同步的，还是异步的"><a href="#通知的发送时同步的，还是异步的" class="headerlink" title="通知的发送时同步的，还是异步的"></a>通知的发送时同步的，还是异步的</h2><p>同步发送.因为要调用消息转发.所谓异步，指的是<strong>非实时发送</strong>而是<strong>在合适的时机发送</strong>，并没有开启异步线程.</p>
<h2 id="NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息"><a href="#NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息" class="headerlink" title="NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息"></a>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2><p>是的, 异步线程发送通知则响应函数也是在异步线程.</p>
<p>异步发送通知可以开启异步线程发送即可.</p>
<h2 id="NSNotificationQueue是异步还是同步发送？在哪个线程响应"><a href="#NSNotificationQueue是异步还是同步发送？在哪个线程响应" class="headerlink" title="NSNotificationQueue是异步还是同步发送？在哪个线程响应"></a>NSNotificationQueue是异步还是同步发送？在哪个线程响应</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>NSPostWhenIdle</th>
<th>NSPostASAP</th>
<th>NSPostNow</th>
</tr>
</thead>
<tbody><tr>
<td>NSPostingStyle</td>
<td>异步发送</td>
<td>异步发送</td>
<td>同步发送</td>
</tr>
</tbody></table>
<p><code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为<strong>延时发送</strong>，它是利用了<code>runloop</code>的时机来触发的.</p>
<p>异步线程发送通知则响应函数也是在异步线程,主线程发送则在主线程.</p>
<h2 id="NSNotificationQueue和runloop的关系"><a href="#NSNotificationQueue和runloop的关系" class="headerlink" title="NSNotificationQueue和runloop的关系"></a>NSNotificationQueue和runloop的关系</h2><p><code>NSNotificationQueue</code>依赖<code>runloop</code>. 因为通知队列要在runloop回调的某个时机调用通知中心发送通知.从下面的枚举值就能看出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="如何保证通知接收的线程在主线程"><a href="#如何保证通知接收的线程在主线程" class="headerlink" title="如何保证通知接收的线程在主线程"></a>如何保证通知接收的线程在主线程</h2><p>如果想在主线程响应异步通知的话可以用如下两种方式</p>
<p>1.系统接受通知的API指定队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block</span><br></pre></td></tr></table></figure>

<p>2.<code>NSMachPort</code>的方式 通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可</p>
<h2 id="页面销毁时不移除通知会崩溃吗"><a href="#页面销毁时不移除通知会崩溃吗" class="headerlink" title="页面销毁时不移除通知会崩溃吗?"></a>页面销毁时不移除通知会崩溃吗?</h2><p>iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针.</p>
<p>iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。</p>
<h2 id="多次添加同一个通知会是什么结果？多次移除通知呢"><a href="#多次添加同一个通知会是什么结果？多次移除通知呢" class="headerlink" title="多次添加同一个通知会是什么结果？多次移除通知呢"></a>多次添加同一个通知会是什么结果？多次移除通知呢</h2><p>多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。</p>
<h2 id="下面的方式能接收到通知吗？为什么"><a href="#下面的方式能接收到通知吗？为什么" class="headerlink" title="下面的方式能接收到通知吗？为什么"></a>下面的方式能接收到通知吗？为什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>不能</p>
<p>首先我们看下通知中心存储通知观察者的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation  *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct Obs &#123;</span><br><span class="line">  id observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL selector;    /* 响应方法        */</span><br><span class="line">  struct Obs *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>

<p><code>nameless</code>与<code>named</code>的具体数据结构如下: </p>
<p><img src="/images/NSNotification1.jpg"></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>当添加通知监听的时候，我们传入了<code>name</code>和<code>object</code>，所以，观察者的存储链表是这样的：</p>
<p><code>named</code>表：<code>key(name)</code> : <code>value</code>-&gt;<code>key(object)</code> : <code>value(Observation)</code></p>
<p>因此在发送通知的时候，如果只传入<code>name</code>而并没有传入<code>object</code>，是找不到<code>Observation</code>的，也就不能执行观察者回调.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天又重新认识了iOS中的通知中心,希望大家经常温故而知新.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T09:49:15.000Z" title="2024/3/1 17:49:15">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">20 分钟读完 (大约3050个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Block%E7%AF%87/">大厂常问iOS面试题--Block篇</a></p><div class="content"><h3 id="这一篇我们来研究一下objc的block并回答一下面试中的下列问题"><a href="#这一篇我们来研究一下objc的block并回答一下面试中的下列问题" class="headerlink" title="这一篇我们来研究一下objc的block并回答一下面试中的下列问题:"></a>这一篇我们来研究一下objc的block并回答一下面试中的下列问题:</h3><ul>
<li>1.block的内部实现，结构体是什么样的</li>
<li>2.block是类吗，有哪些类型</li>
<li>3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获</li>
<li>4.block在修改NSMutableArray，需不需要添加<code>__block</code></li>
<li>5.怎么进行内存管理的</li>
<li>6.block可以用strong修饰吗</li>
<li>7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰</li>
<li>8.<code>block</code>发生<code>copy</code>时机</li>
<li>9.<code>Block</code>访问对象类型的<code>auto</code>变量时，在<code>ARC</code>和<code>MRC</code>下有什么区别</li>
</ul>
<p>在回答所有问题之前我们需要了解一些block背景相关的知识. 如下:</p>
<ul>
<li>如何查看Block的内部实现,也就是说转换成背后真正的c&#x2F;c++代码的block是什么样的？以及转换格式或者原理等. -关于变量的作用域</li>
</ul>
<h4 id="Objective-C-转-C-的方法"><a href="#Objective-C-转-C-的方法" class="headerlink" title="Objective-C 转 C++的方法"></a>Objective-C 转 C++的方法</h4><p>下面我写了个示例<code>TestClass.m</code>类其中block代码如下</p>
<p>OC代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface TestClass ()</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestClass</span><br><span class="line">- (void)testMethods &#123;</span><br><span class="line">    void (^blockA)(int a) = ^(int a) &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    if (blockA) &#123;</span><br><span class="line">        blockA(1990);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>经过上述转换操作我们在TestClass.cpp中最下面发现如下代码</p>
<p>C++代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// @interface TestClass ()</span><br><span class="line">/* @end */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation TestClass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestClass__testMethods_block_desc_0* Desc;</span><br><span class="line">  __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_ee18d3_mi_0,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; 0, sizeof(struct __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) &#123;</span><br><span class="line">    void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    if (blockA) &#123;</span><br><span class="line">        ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码生成是通过如下操作:</p>
<p>打开终端，cd到TestClass.m所在文件夹,使用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc TestClass.m</span><br></pre></td></tr></table></figure>

<p>就会在当前文件夹内自动生成对应的TestClass.cpp文件</p>
<blockquote>
<p>注意: 如果提示clang没有的话 需要安装, 输入如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install clang-format</span><br><span class="line">或者</span><br><span class="line">brew link clang-forma</span><br><span class="line">然后输入 下面命令测试是否好使</span><br><span class="line">clang-format --help</span><br></pre></td></tr></table></figure>

<p>通过上述代码我们发现Block的其实是一个结构体类型</p>
<p>底层实现 会根据 <code>__</code><strong>类名</strong><code>__</code><strong>方法名</strong><code>_</code>block<code>_</code>impl<code>_</code><strong>下标</strong> (0代表这个方法或者这个类中第0个block 下面如果还有将会 第1个block 第2个…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct __类名__方法名_block_impl_下标</span><br></pre></td></tr></table></figure>

<h4 id="关于变量的作用域"><a href="#关于变量的作用域" class="headerlink" title="关于变量的作用域"></a>关于变量的作用域</h4><p>c语言的函数中可能使用的参数变量种类</p>
<ul>
<li>参数类型</li>
<li>自动变量(局部变量)</li>
<li>静态变量(静态局部变量)</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>由于存储区域特殊,这其中有三种变量是可以在任何时候以任何状态调用的.</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而其他两种,则是有各自相应的作用域,超过作用域后,会被销毁.</p>
<hr>
<h3 id="1-block的内部实现，结构体是什么样的"><a href="#1-block的内部实现，结构体是什么样的" class="headerlink" title="1.block的内部实现，结构体是什么样的"></a>1.block的内部实现，结构体是什么样的</h3><p>看了上面的背景知识我们来回到一下这个问题</p>
<p>block的内部实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl; //成员变量</span><br><span class="line">  struct __TestClass__testMethods_block_desc_0* Desc; //desc 结构体声明</span><br><span class="line">  // 构造函数</span><br><span class="line">  // fp 函数指针</span><br><span class="line">  // desc 静态全局变量初始化的 __main_block_desc_ 结构体实例指针</span><br><span class="line">  // flags block 的负载信息(引用计数和类型信息),按位存储.</span><br><span class="line">  __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将来被调用的block内部的代码：block值被转换为C的函数代码</span><br><span class="line">//这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己(相当于C++里的this，</span><br><span class="line">OC里的self)</span><br><span class="line">//__cself 是指向__TestClass__testMethods_block_impl_0结构体实现的指针</span><br><span class="line">//Block结构体就是__TestClass__testMethods_block_impl_0结构体.Block的值就是通过__TestClass__testMethods_block_impl_0构造出来的</span><br><span class="line">static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_9f58f7_mi_0,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; 0, sizeof(struct __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) &#123;</span><br><span class="line">    void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    if (blockA) &#123;</span><br><span class="line">        ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出来<code>__TestClass__testMethods_block_impl_0</code>有3个部分组成</p>
<ul>
<li>impl 函数指针指向<code>__TestClass__testMethods_block_impl_0</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;  //今后版本升级所需的区域</span><br><span class="line">  void *FuncPtr; //函数指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Desc 指向<code>__TestClass__testMethods_block_impl_0</code>的Desc指针,用于描述当前这个block的附加信息的，包括结构体的大小等等信息.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved; //今后升级版本所需区域</span><br><span class="line">  size_t Block_size; //block的大小</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; 0, sizeof(struct __TestClass__testMethods_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__TestClass__testMethods_block_impl_0()</code>构造函数,也就是该block的具体实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">   impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">   impl.Flags = flags;</span><br><span class="line">   impl.FuncPtr = fp;</span><br><span class="line">   Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此结构体中</p>
<ul>
<li>isa指针保持这所属类的结构体的实例的指针.</li>
<li><code>struct __TestClass__testMethods_block_impl_0</code>相当于Objective-C类对象的结构体</li>
<li><code>_NSConcreteStackBlock</code>相当于Block的结构体实例,也就是说<strong>block其实就是Objective-C对于闭包的对象实现</strong></li>
</ul>
<p>讲到这里block的内部实现你看懂了吗?结构体是什么样的你记住了吗? 其实看着繁琐 细心观察代码会发现还是比较简单的.</p>
<h3 id="2-block是类吗，有哪些类型"><a href="#2-block是类吗，有哪些类型" class="headerlink" title="2.block是类吗，有哪些类型?"></a>2.block是类吗，有哪些类型?</h3><p>block也算是个类,因为它有isa指针,block.isa的类型包括</p>
<ul>
<li>_NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域(.data)中</li>
<li>_NSConcreteStackBlock栈上(前面讲的都是栈上的 block)</li>
<li>_NSConcreteMallocBlock 堆上</li>
</ul>
<blockquote>
<p>这个isa可以按位运算</p>
</blockquote>
<h3 id="3-一个int变量被-block-修饰与否的区别？block的变量截获"><a href="#3-一个int变量被-block-修饰与否的区别？block的变量截获" class="headerlink" title="3.一个int变量被 __block 修饰与否的区别？block的变量截获"></a>3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获</h3><h4 id="被-block-修饰与否的区别"><a href="#被-block-修饰与否的区别" class="headerlink" title="被__block 修饰与否的区别"></a>被<code>__block</code> 修饰与否的区别</h4><p>用一段示例代码来解答这个问题吧:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line"></span><br><span class="line">PrintTwoIntBlock block = ^()&#123;</span><br><span class="line">    a -= 10;</span><br><span class="line">    printf(&quot;%d, %d\n&quot;,a,b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();//0 20</span><br><span class="line"></span><br><span class="line">a += 20;</span><br><span class="line">b += 30;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d, %d\n&quot;,a,b);//20 50</span><br><span class="line"></span><br><span class="line">block();/10 20</span><br></pre></td></tr></table></figure>

<p>通过<code>__block</code>修饰<code>int</code> <code>a</code>,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用.</p>
<p><code>int</code> <code>b</code>没有被<code>__block</code>修饰,block内部对<code>b</code>是值copy.所以在block内部修改<code>b</code>不影响外部b的变化.</p>
<h4 id="block的变量截获"><a href="#block的变量截获" class="headerlink" title="block的变量截获"></a>block的变量截获</h4><p>通过如下代码我们来观察要一下变量的捕获</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    id array = [NSMutableArray new];</span><br><span class="line">    blk = [^(id object)&#123;</span><br><span class="line">        [array addObject:object];</span><br><span class="line">        NSLog(@&quot;array count = %ld&quot;,[array count]);</span><br><span class="line">    &#125; copy];</span><br><span class="line">&#125;</span><br><span class="line">blk([NSObject new]);</span><br><span class="line">blk([NSObject new]);</span><br><span class="line">blk([NSObject new]);</span><br></pre></td></tr></table></figure>

<p>输出打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_demo[28963:1629127] array count = 1</span><br><span class="line">block_demo[28963:1629127] array count = 2</span><br><span class="line">block_demo[28963:1629127] array count = 3</span><br></pre></td></tr></table></figure>

<p>我们把上面的代码翻译成C++看下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  id array;//截获的对象</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Objc中，C结构体里不能含有被<code>__strong</code>修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是Objc的运行时库能够准确把握<code>Block</code>从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过<code>__TestClass__testMethods_block_copy_0</code>函数和<code>__TestClass__testMethods_block_dispose_0</code>函数进行的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __TestClass__testMethods_block_copy_0(struct __TestClass__testMethods_block_impl_0*dst, struct __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;  </span><br><span class="line">static void __TestClass__testMethods_block_dispose_0(struct __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_Block_object_assign</code>相当于retain操作,将对象赋值在对象类型的结构体成员变量中.</p>
</li>
<li><p><code>_Block_object_dispose</code>相当于release操作.</p>
</li>
</ul>
<p>这两个函数调用的时机是在什么时候呢？</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>被调用时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>__TestClass__testMethods_block_copy_0</code></td>
<td>从栈复制到堆时</td>
</tr>
<tr>
<td><code>__TestClass__testMethods_block_dispose_0</code></td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody></table>
<h5 id="什么时候栈上的Block会被复制到堆呢？"><a href="#什么时候栈上的Block会被复制到堆呢？" class="headerlink" title="什么时候栈上的Block会被复制到堆呢？"></a>什么时候栈上的Block会被复制到堆呢？</h5><ul>
<li><p>调用block的copy函数时。</p>
</li>
<li><p>Block作为函数返回值返回时。</p>
</li>
<li><p>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。</p>
</li>
<li><p>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</p>
</li>
</ul>
<h5 id="什么时候Block被废弃呢？"><a href="#什么时候Block被废弃呢？" class="headerlink" title="什么时候Block被废弃呢？"></a>什么时候Block被废弃呢？</h5><ul>
<li>堆上的Block被释放后,谁都不再持有Block时调用dispose函数。</li>
</ul>
<p>以上就是变量被block捕获的内容</p>
<hr>
<h3 id="4-block在修改NSMutableArray，需不需要添加-block"><a href="#4-block在修改NSMutableArray，需不需要添加-block" class="headerlink" title="4.block在修改NSMutableArray，需不需要添加__block"></a>4.<code>block</code>在修改<code>NSMutableArray</code>，需不需要添加<code>__block</code></h3><ul>
<li>如修改<code>NSMutableArray</code>的存储内容的话,是不需要添加<code>__block</code>修饰的。</li>
<li>如修改<code>NSMutableArray</code>对象的本身,那必须添加<code>__block</code>修饰。</li>
</ul>
<h3 id="5-怎么进行内存管理的"><a href="#5-怎么进行内存管理的" class="headerlink" title="5.怎么进行内存管理的?"></a>5.怎么进行内存管理的?</h3><p>在上面Block的构造函数<code>__TestClass__testMethods_block_impl_0</code>中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中.</p>
<table>
<thead>
<tr>
<th>block内存操作</th>
<th>存储域&#x2F;存储位置</th>
<th>copy操作的影响</th>
</tr>
</thead>
<tbody><tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈拷贝到堆</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<ul>
<li><p>全局Block:<code>_NSConcreteGlobalBlock</code>的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件:</p>
<ul>
<li>记述全局变量的地方有block语法时.</li>
<li>block不截获的自动变量.</li>
</ul>
<blockquote>
<p>以上两个条件只要满足一个就可以产生全局Block. <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903474312773646#heading-13">参考</a></p>
</blockquote>
</li>
<li><p>栈Block:<code>_NSConcreteStackBlock</code>在生成Block以后，如果这个Block不是全局Block,那它就是栈Block,生命周期在其所属的变量作用域内.(也就是说如果销毁取决于所属的变量作用域).如果Block变量和<code>__block</code>变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block.</p>
</li>
<li><p>堆Block:<code>_NSConcreteMallocBlock</code>将栈block复制到堆以后，block结构体的isa成员变量变成了<code>_NSConcreteMallocBlock</code>。</p>
</li>
</ul>
<h3 id="6-block可以用strong修饰吗"><a href="#6-block可以用strong修饰吗" class="headerlink" title="6.block可以用strong修饰吗?"></a>6.block可以用strong修饰吗?</h3><p>在ARC中可以，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作.</p>
<p>在MRC中不行,因为要有拷贝过程.如果执行copy用strong的话会crash, <code>strong</code>是ARC中引入的关键字.如果使用retain相当于忽视了block的copy过程.</p>
<h3 id="7-解决循环引用时为什么要用-strong、-weak修饰"><a href="#7-解决循环引用时为什么要用-strong、-weak修饰" class="headerlink" title="7.解决循环引用时为什么要用__strong、__weak修饰?"></a>7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰?</h3><p>首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上<code>__weak</code>,在Block内部使用<code>__strong</code>修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,但是持有的是我们上面加了<code>__weak</code>所以行程了比消此长的链条,刚好能解决block延迟销毁的时候对外部对象生命周期造成的影响.如果不这样做很容易造成循环引用.</p>
<h3 id="8-block发生copy时机"><a href="#8-block发生copy时机" class="headerlink" title="8.block发生copy时机?"></a>8.block发生copy时机?</h3><p>在ARC中,编译器将创建在栈中的block会自动拷贝到堆内存中,而block作为方法或函数的参数传递时,编译器不会做copy操作.</p>
<ul>
<li><p>调用block的copy函数时。</p>
</li>
<li><p>Block作为函数返回值返回时。</p>
</li>
<li><p>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。</p>
</li>
<li><p>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</p>
</li>
</ul>
<h3 id="9-Block访问对象类型的auto变量时，在ARC和MRC下有什么区别"><a href="#9-Block访问对象类型的auto变量时，在ARC和MRC下有什么区别" class="headerlink" title="9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?"></a>9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?</h3><p><a target="_blank" rel="noopener" href="https://github.com/LGBamboo/iOS-article.02/blob/main/%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BBlock%EF%BC%88%E9%99%84%E7%AD%94%E6%A1%88%EF%BC%89.md#9block%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84auto%E5%8F%98%E9%87%8F%E6%97%B6%E5%9C%A8arc%E5%92%8Cmrc%E4%B8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"></a></p>
<p>ARC下会对这个对象强引用，MRC下不会</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T09:16:02.000Z" title="2024/3/1 17:16:02">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">14 分钟读完 (大约2119个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/">大厂常问iOS面试题--数据结构篇</a></p><div class="content"><h2 id="1-数据结构的存储一般常用的有几种？各有什么特点？"><a href="#1-数据结构的存储一般常用的有几种？各有什么特点？" class="headerlink" title="1.数据结构的存储一般常用的有几种？各有什么特点？"></a>1.数据结构的存储一般常用的有几种？各有什么特点？</h2><p>数据结构的存储一般常用的有两种 顺序存储结构 和 链式存储结构</p>
<ul>
<li><p>顺序存储结构:</p>
<p>比如，数组，1-2-3-4-5-6-7-8-9-10，存储是按顺序的。再比如栈和队列等</p>
</li>
<li><p>链式存储结构:</p>
<p>比如，数组，1-2-3-4-5-6-7-8-9-10，链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序</p>
</li>
</ul>
<h2 id="2-集合结构-线性结构-树形结构-图形结构"><a href="#2-集合结构-线性结构-树形结构-图形结构" class="headerlink" title="2.集合结构 线性结构 树形结构 图形结构"></a>2.集合结构 线性结构 树形结构 图形结构</h2><ul>
<li><p>集合结构</p>
<p>一个集合，就是一个圆圈中有很多个元素，元素与元素之间没有任何关系 这个很简单</p>
</li>
<li><p>线性结构</p>
<p>一个条线上站着很多个人。 这条线不一定是直的。也可以是弯的。也可以是值的 相当于一条线被分成了好几段的样子 （发挥你的想象力）。 线性结构是一对一的关系</p>
</li>
<li><p>树形结构</p>
<p>做开发的肯定或多或少的知道xml 解析 树形结构跟他非常类似。也可以想象成一个金字塔。树形结构是一对多的关系</p>
</li>
<li><p>图形结构</p>
<p>这个就比较复杂了。他呢 无穷。无边 无向（没有方向）图形机构 你可以理解为多对多 类似于我们人的交集关系</p>
</li>
</ul>
<h2 id="3-单向链表-双向链表-循环链表"><a href="#3-单向链表-双向链表-循环链表" class="headerlink" title="3.单向链表 双向链表 循环链表"></a>3.单向链表 双向链表 循环链表</h2><ul>
<li><p>单向链表 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑 <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/196abfe10e3b09e7967706d0ac6523e55dcf04a746d1207e15584b31dc01f485/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31373439353331372d626538636137396237303935393033322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="/images/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.jpg" alt="单向链表"></a></p>
</li>
<li><p>双向链表 <a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/46d63215a014f0662671867ecfd1637ecf83dcf9c97abf89526efe19b4f0a762/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31373439353331372d313165663863643962643835386537622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" alt="双向链表"></a></p>
</li>
<li><p>循环链表</p>
<p>循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;A. 绕成一个圈。就像蛇吃自己的这就是循环 不需要去死记硬背哪些理论知识。</p>
</li>
</ul>
<h2 id="4-数组和链表区别"><a href="#4-数组和链表区别" class="headerlink" title="4.数组和链表区别"></a>4.数组和链表区别</h2><ul>
<li><p>数组</p>
<p>数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况</p>
</li>
<li><p>链表</p>
<p>链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高</p>
</li>
</ul>
<h2 id="5-堆、栈和队列"><a href="#5-堆、栈和队列" class="headerlink" title="5.堆、栈和队列"></a>5.堆、栈和队列</h2><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：</p>
<p>1）堆中某个节点的值总是不大于或不小于其父节点的值；</p>
<p>2）堆总是一棵完全二叉树。</p>
</li>
<li><p>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。</p>
</li>
<li><p>堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><p>栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</p>
</li>
<li><p>栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。</p>
</li>
<li><p>堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p>
</li>
<li><p>栈的应用—递归</p>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p>
</li>
<li><p>队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。</p>
</li>
</ul>
<h2 id="6-输入一棵二叉树的根结点，求该树的深度？"><a href="#6-输入一棵二叉树的根结点，求该树的深度？" class="headerlink" title="6.输入一棵二叉树的根结点，求该树的深度？"></a>6.输入一棵二叉树的根结点，求该树的深度？</h2><p>二叉树的结点定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue ；</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinarvTreeNode* m_pRight ；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一棵树只有一个结点，它的深度为1。</li>
<li>如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。</li>
<li>如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int TreeDepth(TreeNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(pRoot == nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    int left = TreeDepth(pRoot-&gt;left);</span><br><span class="line">    int right = TreeDepth(pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    return (left&gt;right) ? (left+1) : (right+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-输入一课二叉树的根结点，判断该树是不是平衡二叉树？"><a href="#7-输入一课二叉树的根结点，判断该树是不是平衡二叉树？" class="headerlink" title="7.输入一课二叉树的根结点，判断该树是不是平衡二叉树？"></a>7.输入一课二叉树的根结点，判断该树是不是平衡二叉树？</h2><ul>
<li><p>重复遍历结点</p>
<p>先求出根结点的左右子树的深度，然后判断它们的深度相差不超过1，如果否，则不是一棵二叉树；如果是，再用同样的方法分别判断左子树和右子树是否为平衡二叉树，如果都是，则这就是一棵平衡二叉树。</p>
</li>
<li><p>遍历一遍结点</p>
<p>遍历结点的同时记录下该结点的深度，避免重复访问。</p>
</li>
</ul>
<p>方法1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int TreeDepth(TreeNode* pRoot)&#123;</span><br><span class="line">    if(pRoot==NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    int left=TreeDepth(pRoot-&gt;left);</span><br><span class="line">    int right=TreeDepth(pRoot-&gt;right);</span><br><span class="line">    return left&gt;right?(left+1):(right+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsBalanced(TreeNode* pRoot)&#123;</span><br><span class="line">    if(pRoot==NULL)</span><br><span class="line">        return true;</span><br><span class="line">    int left=TreeDepth(pRoot-&gt;left);</span><br><span class="line">    int right=TreeDepth(pRoot-&gt;right);</span><br><span class="line">    int diff=left-right;</span><br><span class="line">    if(diff&gt;1 || diff&lt;-1)</span><br><span class="line">        return false;</span><br><span class="line">    return IsBalanced(pRoot-&gt;left) &amp;&amp; IsBalanced(pRoot-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced_1(TreeNode* pRoot,int&amp; depth)&#123;</span><br><span class="line">    if(pRoot==NULL)&#123;</span><br><span class="line">        depth=0;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    int left,right;</span><br><span class="line">    int diff;</span><br><span class="line">    if(IsBalanced_1(pRoot-&gt;left,left) &amp;&amp; IsBalanced_1(pRoot-&gt;right,right))&#123;</span><br><span class="line">        diff=left-right;</span><br><span class="line">        if(diff&lt;=1 || diff&gt;=-1)&#123;</span><br><span class="line">            depth=left&gt;right?left+1:right+1;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsBalancedTree(TreeNode* pRoot)&#123;</span><br><span class="line">    int depth=0;</span><br><span class="line">    return IsBalanced_1(pRoot,depth);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T09:11:14.000Z" title="2024/3/1 17:11:14">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">16 分钟读完 (大约2429个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95%E7%AF%87/">大厂常问iOS面试题--算法篇</a></p><div class="content"><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h2><ul>
<li><p>时间频度</p>
<p>一个算法执行所耗费的时间,从理论上是不能算出来的,必须上机运行测试才能知道.但我们不可能也没有必要对每个算法都上机测试,只需知道哪个算法花费的时间多,哪个算法花费的时间少就可以了.并且一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n).</p>
</li>
<li><p>时间复杂度</p>
<p>一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)&#x2F;f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)&#x3D;O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.</p>
</li>
<li><p>在各种不同算法中,若算法中语句执行次数为一个常数,则时间复杂度为O(1),另外,在时间频度不相同时,时间复杂度有可能相同,如T(n)&#x3D;n2+3n+4与T(n)&#x3D;4n2+2n+1它们的频度不同,但时间复杂度相同,都为O(n2).</p>
</li>
<li><p>按数量级递增排列,常见的时间复杂度有：</p>
<p>O(1)称为常量级，算法的时间复杂度是一个常数。</p>
<p>O(n)称为线性级，时间复杂度是数据量n的线性函数。</p>
<p>O(n²)称为平方级，与数据量n的二次多项式函数属于同一数量级。</p>
<p>O(n³)称为立方级，是n的三次多项式函数。</p>
<p>O(logn)称为对数级，是n的对数函数。</p>
<p>O(nlogn)称为介于线性级和平方级之间的一种数量级</p>
<p>O(2ⁿ)称为指数级，与数据量n的指数函数是一个数量级。</p>
<p>O(n!)称为阶乘级，与数据量n的阶乘是一个数量级。</p>
<p>它们之间的关系是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)，随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低.</p>
</li>
</ul>
<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.空间复杂度"></a>2.空间复杂度</h2><ul>
<li>评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。不包括算法程序代码和所处理的数据本身所占空间部分。通常用所使用额外空间的字节数表示。其算法比较简单，记为S(n)&#x3D;O(f(n))，其中，n表示问题规模。</li>
</ul>
<h2 id="3-常用的排序算法"><a href="#3-常用的排序算法" class="headerlink" title="3.常用的排序算法"></a>3.常用的排序算法</h2><ul>
<li><p>选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</p>
<p>都将数组分为已排序部分和未排序部分。</p>
<p>选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</p>
<p>冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</p>
<p>插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> *    【选择排序】：最值出现在起始端</span><br><span class="line"> *    </span><br><span class="line"> *    第1趟：在n个数中找到最小(大)数与第一个数交换位置</span><br><span class="line"> *    第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置</span><br><span class="line"> *    重复这样的操作...依次与第三个、第四个...数交换位置</span><br><span class="line"> *    第n-1趟，最终可实现数据的升序（降序）排列。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">void selectSort(int *arr, int length) &#123;</span><br><span class="line">    for (int i = 0; i &lt; length - 1; i++) &#123; //趟数</span><br><span class="line">        for (int j = i + 1; j &lt; length; j++) &#123; //比较次数</span><br><span class="line">            if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                int temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> *    【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾</span><br><span class="line"> *    第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置</span><br><span class="line"> *    第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置</span><br><span class="line"> *     ……   ……</span><br><span class="line"> *    第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置    </span><br><span class="line"> */</span><br><span class="line">void bublleSort(int *arr, int length) &#123;</span><br><span class="line">    for(int i = 0; i &lt; length - 1; i++) &#123; //趟数</span><br><span class="line">        for(int j = 0; j &lt; length - i - 1; j++) &#123; //比较次数</span><br><span class="line">            if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *    折半查找：优化查找时间（不用遍历全部数据）</span><br><span class="line"> *</span><br><span class="line"> *    折半查找的原理：</span><br><span class="line"> *   1&gt; 数组必须是有序的</span><br><span class="line"> *   2&gt; 必须已知min和max（知道范围）</span><br><span class="line"> *   3&gt; 动态计算mid的值，取出mid对应的值进行比较</span><br><span class="line"> *   4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1</span><br><span class="line"> *   5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1</span><br><span class="line"> *</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 </span><br><span class="line">int findKey(int *arr, int length, int key) &#123;</span><br><span class="line">    int min = 0, max = length - 1, mid;</span><br><span class="line">    while (min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / 2; //计算中间值</span><br><span class="line">        if (key &gt; arr[mid]) &#123;</span><br><span class="line">            min = mid + 1;</span><br><span class="line">        &#125; else if (key &lt; arr[mid]) &#123;</span><br><span class="line">            max = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-字符串反转"><a href="#4-字符串反转" class="headerlink" title="4.字符串反转"></a>4.字符串反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void char_reverse (char *cha) &#123;</span><br><span class="line"></span><br><span class="line">    // 定义头部指针</span><br><span class="line">    char *begin = cha;</span><br><span class="line">    // 定义尾部指针</span><br><span class="line">    char *end = cha + strlen(cha) -1;</span><br><span class="line"></span><br><span class="line">    while (begin &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">        char temp = *begin;</span><br><span class="line">        *(begin++) = *end;</span><br><span class="line">        *(end--) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-链表反转（头差法）"><a href="#5-链表反转（头差法）" class="headerlink" title="5.链表反转（头差法）"></a>5.链表反转（头差法）</h2><p>.h声明文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">// 定义一个链表</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface ReverseList : NSObject</span><br><span class="line"></span><br><span class="line">// 链表反转</span><br><span class="line">struct Node* reverseList(struct Node *head);</span><br><span class="line"></span><br><span class="line">// 构造一个链表</span><br><span class="line">struct Node* constructList(void);</span><br><span class="line"></span><br><span class="line">// 打印链表中的数据</span><br><span class="line">void printList(struct Node *head);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>.m实现文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ReverseList.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ReverseList</span><br><span class="line"></span><br><span class="line">struct Node* reverseList(struct Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    // 定义遍历指针，初始化为头结点</span><br><span class="line">    struct Node *p = head;</span><br><span class="line"></span><br><span class="line">    // 反转后的链表头部</span><br><span class="line">    struct Node *newH = NULL;</span><br><span class="line"></span><br><span class="line">    // 遍历链表</span><br><span class="line">    while (p != NULL) &#123;</span><br><span class="line"></span><br><span class="line">        // 记录下一个结点</span><br><span class="line">        struct Node *temp = p-&gt;next;</span><br><span class="line">        // 当前结点的next指向新链表头部</span><br><span class="line">        p-&gt;next = newH;</span><br><span class="line">        // 更改新链表头部为当前结点</span><br><span class="line">        newH = p;</span><br><span class="line">        // 移动p指针</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回反转后的链表头结点</span><br><span class="line">    return newH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node* constructList(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 头结点定义</span><br><span class="line">    struct Node *head = NULL;</span><br><span class="line">    // 记录当前尾结点</span><br><span class="line">    struct Node *cur = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">        struct Node *node = malloc(sizeof(struct Node));</span><br><span class="line">        node-&gt;data = i;</span><br><span class="line"></span><br><span class="line">        // 头结点为空，新结点即为头结点</span><br><span class="line">        if (head == NULL) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前结点的next为新结点</span><br><span class="line">        else&#123;</span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置当前结点为新结点</span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printList(struct Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct Node* temp = head;</span><br><span class="line">    while (temp != NULL) &#123;</span><br><span class="line">        printf(&quot;node is %d \n&quot;, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="6-有序数组合并"><a href="#6-有序数组合并" class="headerlink" title="6.有序数组合并"></a>6.有序数组合并</h2><p>.h声明文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MergeSortedList : NSObject</span><br><span class="line">// 将有序数组a和b的值合并到一个数组result当中，且仍然保持有序</span><br><span class="line">void mergeList(int a[], int aLen, int b[], int bLen, int result[]);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>.m实现文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MergeSortedList.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MergeSortedList</span><br><span class="line"></span><br><span class="line">void mergeList(int a[], int aLen, int b[], int bLen, int result[])</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0; // 遍历数组a的指针</span><br><span class="line">    int q = 0; // 遍历数组b的指针</span><br><span class="line">    int i = 0; // 记录当前存储位置</span><br><span class="line"></span><br><span class="line">    // 任一数组没有到达边界则进行遍历</span><br><span class="line">    while (p &lt; aLen &amp;&amp; q &lt; bLen) &#123;</span><br><span class="line">        // 如果a数组对应位置的值小于b数组对应位置的值</span><br><span class="line">        if (a[p] &lt;= b[q]) &#123;</span><br><span class="line">            // 存储a数组的值</span><br><span class="line">            result[i] = a[p];</span><br><span class="line">            // 移动a数组的遍历指针</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            // 存储b数组的值</span><br><span class="line">            result[i] = b[q];</span><br><span class="line">            // 移动b数组的遍历指针</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 指向合并结果的下一个存储位置</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果a数组有剩余</span><br><span class="line">    while (p &lt; aLen) &#123;</span><br><span class="line">        // 将a数组剩余部分拼接到合并结果的后面</span><br><span class="line">        result[i] = a[p++];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果b数组有剩余</span><br><span class="line">    while (q &lt; bLen) &#123;</span><br><span class="line">        // 将b数组剩余部分拼接到合并结果的后面</span><br><span class="line">        result[i] = b[q++];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="7-查找第一个只出现一次的字符（Hash查找）"><a href="#7-查找第一个只出现一次的字符（Hash查找）" class="headerlink" title="7.查找第一个只出现一次的字符（Hash查找）"></a>7.查找第一个只出现一次的字符（Hash查找）</h2><p>.h声明文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface HashFind : NSObject</span><br><span class="line"></span><br><span class="line">// 查找第一个只出现一次的字符</span><br><span class="line">char findFirstChar(char* cha);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>.m实现文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;HashFind.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation HashFind</span><br><span class="line"></span><br><span class="line">char findFirstChar(char* cha)</span><br><span class="line">&#123;</span><br><span class="line">    char result = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    // 定义一个数组 用来存储各个字母出现次数</span><br><span class="line">    int array[256];</span><br><span class="line"></span><br><span class="line">    // 对数组进行初始化操作</span><br><span class="line">    for (int i=0; i&lt;256; i++) &#123;</span><br><span class="line">        array[i] =0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个指针 指向当前字符串头部</span><br><span class="line">    char* p = cha;</span><br><span class="line">    // 遍历每个字符</span><br><span class="line">    while (*p != &#x27;\0&#x27;) &#123;</span><br><span class="line">        // 在字母对应存储位置 进行出现次数+1操作</span><br><span class="line">        array[*(p++)]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将P指针重新指向字符串头部</span><br><span class="line">    p = cha;</span><br><span class="line">    // 遍历每个字母的出现次数</span><br><span class="line">    while (*p != &#x27;\0&#x27;) &#123;</span><br><span class="line">        // 遇到第一个出现次数为1的字符，打印结果</span><br><span class="line">        if (array[*p] == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            result = *p;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 反之继续向后遍历</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="8-查找两个子视图的共同父视图"><a href="#8-查找两个子视图的共同父视图" class="headerlink" title="8.查找两个子视图的共同父视图"></a>8.查找两个子视图的共同父视图</h2><p>.h声明文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface CommonSuperFind : NSObject</span><br><span class="line"></span><br><span class="line">// 查找两个视图的共同父视图</span><br><span class="line">- (NSArray&lt;UIView *&gt; *)findCommonSuperView:(UIView *)view other:(UIView *)viewOther;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>.m实现文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CommonSuperFind.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CommonSuperFind</span><br><span class="line"></span><br><span class="line">- (NSArray &lt;UIView *&gt; *)findCommonSuperView:(UIView *)viewOne other:(UIView *)viewOther</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *result = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    // 查找第一个视图的所有父视图</span><br><span class="line">    NSArray *arrayOne = [self findSuperViews:viewOne];</span><br><span class="line">    // 查找第二个视图的所有父视图</span><br><span class="line">    NSArray *arrayOther = [self findSuperViews:viewOther];</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    // 越界限制条件</span><br><span class="line">    while (i &lt; MIN((int)arrayOne.count, (int)arrayOther.count)) &#123;</span><br><span class="line">        // 倒序方式获取各个视图的父视图</span><br><span class="line">        UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1];</span><br><span class="line">        UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1];</span><br><span class="line"></span><br><span class="line">        // 比较如果相等 则为共同父视图</span><br><span class="line">        if (superOne == superOther) &#123;</span><br><span class="line">            [result addObject:superOne];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果不相等，则结束遍历</span><br><span class="line">        else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray &lt;UIView *&gt; *)findSuperViews:(UIView *)view</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化为第一父视图</span><br><span class="line">    UIView *temp = view.superview;</span><br><span class="line">    // 保存结果的数组</span><br><span class="line">    NSMutableArray *result = [NSMutableArray array];</span><br><span class="line">    while (temp) &#123;</span><br><span class="line">        [result addObject:temp];</span><br><span class="line">        // 顺着superview指针一直向上查找</span><br><span class="line">        temp = temp.superview;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="9-无序数组中的中位数-快排思想"><a href="#9-无序数组中的中位数-快排思想" class="headerlink" title="9.无序数组中的中位数(快排思想)"></a>9.无序数组中的中位数(快排思想)</h2><p>.h声明文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MedianFind : NSObject</span><br><span class="line"></span><br><span class="line">// 无序数组中位数查找</span><br><span class="line">int findMedian(int a[], int aLen);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.m实现文件</span><br><span class="line">#import &quot;MedianFind.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MedianFind</span><br><span class="line"></span><br><span class="line">//求一个无序数组的中位数</span><br><span class="line">int findMedian(int a[], int aLen)</span><br><span class="line">&#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = aLen - 1;</span><br><span class="line"></span><br><span class="line">    int mid = (aLen - 1) / 2;</span><br><span class="line">    int div = PartSort(a, low, high);</span><br><span class="line"></span><br><span class="line">    while (div != mid)</span><br><span class="line">    &#123;</span><br><span class="line">        if (mid &lt; div)</span><br><span class="line">        &#123;</span><br><span class="line">            //左半区间找</span><br><span class="line">            div = PartSort(a, low, div - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //右半区间找</span><br><span class="line">            div = PartSort(a, div + 1, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到了</span><br><span class="line">    return a[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int PartSort(int a[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    int low = start;</span><br><span class="line">    int high = end;</span><br><span class="line"></span><br><span class="line">    //选取关键字</span><br><span class="line">    int key = a[end];</span><br><span class="line"></span><br><span class="line">    while (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        //左边找比key大的值</span><br><span class="line">        while (low &lt; high &amp;&amp; a[low] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //右边找比key小的值</span><br><span class="line">        while (low &lt; high &amp;&amp; a[high] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            //找到之后交换左右的值</span><br><span class="line">            int temp = a[low];</span><br><span class="line">            a[low] = a[high];</span><br><span class="line">            a[high] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp = a[high];</span><br><span class="line">    a[high] = a[end];</span><br><span class="line">    a[end] = temp;</span><br><span class="line"></span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="10-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"><a href="#10-给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。" class="headerlink" title="10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。"></a>10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</h2><p><a target="_blank" rel="noopener" href="https://github.com/LGBamboo/iOS-article.02/blob/main/iOS%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95%E7%AF%87.md#10%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%80%BC%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSArray *oriArray = @[@(2),@(3),@(6),@(7),@(22),@(12)];</span><br><span class="line"></span><br><span class="line">    BOOL isHaveNums =  [self twoNumSumWithTarget:9 Array:oriArray];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%d&quot;,isHaveNums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)twoNumSumWithTarget:(int)target Array:(NSArray&lt;NSNumber *&gt; *)array &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableArray *finalArray = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        for (int j = i + 1; j &lt; array.count; j++) &#123;</span><br><span class="line"></span><br><span class="line">            if ([array[i] intValue] + [array[j] intValue] == target) &#123;</span><br><span class="line"></span><br><span class="line">                [finalArray addObject:array[i]];</span><br><span class="line">                [finalArray addObject:array[j]];</span><br><span class="line">                NSLog(@&quot;%@&quot;,finalArray);</span><br><span class="line"></span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T08:58:36.000Z" title="2024/3/1 16:58:36">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">8 分钟读完 (大约1231个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%AF%87/">大厂常问iOS面试题--组件化篇</a></p><div class="content"><h2 id="1-组件化有什么好处？"><a href="#1-组件化有什么好处？" class="headerlink" title="1.组件化有什么好处？"></a>1.组件化有什么好处？</h2><ul>
<li><p>业务分层、解耦，使代码变得可维护；</p>
</li>
<li><p>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</p>
</li>
<li><p>便于各业务功能拆分、抽离，实现真正的功能复用；</p>
</li>
<li><p>业务隔离，跨团队开发代码控制和版本风险控制的实现；</p>
</li>
<li><p>模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</p>
</li>
<li><p>在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</p>
</li>
</ul>
<h2 id="2-你是如何组件化解耦的？"><a href="#2-你是如何组件化解耦的？" class="headerlink" title="2.你是如何组件化解耦的？"></a>2.你是如何组件化解耦的？</h2><ul>
<li><p>分层</p>
<p>基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制；</p>
<p>基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计</p>
<p>业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供；</p>
</li>
<li><p>中间件：target-action，url-block，protocol-class</p>
</li>
</ul>
<h2 id="3-为什么CTMediator方案优于基于Router的方案？"><a href="#3-为什么CTMediator方案优于基于Router的方案？" class="headerlink" title="3.为什么CTMediator方案优于基于Router的方案？"></a>3.为什么CTMediator方案优于基于Router的方案？</h2><p>Router的缺点：</p>
<ul>
<li><p>在组件化的实施过程中，注册URL并不是充分必要条件。组件是不需要向组件管理器注册URL的，注册了URL之后，会造成不必要的内存常驻。注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过runtime做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。</p>
</li>
<li><p>在iOS领域里，一定是组件化的中间件为openURL提供服务，而不是openURL方式为组件化提供服务。如果在给App实施组件化方案的过程中是基于openURL的方案的话，有一个致命缺陷：非常规对象(不能被字符串化到URL中的对象，例如UIImage)无法参与本地组件间调度。 在本地调用中使用URL的方式其实是不必要的，如果业务工程师在本地间调度时需要给出URL，那么就不可避免要提供params，在调用时要提供哪些params是业务工程师很容易懵逼的地方。</p>
</li>
<li><p>为了支持传递非常规参数，蘑菇街的方案采用了protocol，这个会侵入业务。由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖public Protocol。这对于将来的业务迁移是有非常大的影响的。</p>
</li>
</ul>
<p>CTMediator的优点：</p>
<ul>
<li><p>调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。</p>
</li>
<li><p>组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。</p>
</li>
<li><p>方便传递各种类型的参数。</p>
</li>
</ul>
<h2 id="4-基于CTMediator的组件化方案，有哪些核心组成？"><a href="#4-基于CTMediator的组件化方案，有哪些核心组成？" class="headerlink" title="4.基于CTMediator的组件化方案，有哪些核心组成？"></a>4.基于CTMediator的组件化方案，有哪些核心组成？</h2><ul>
<li><p>CTMediator中间件：集成就可以了</p>
</li>
<li><p>模块Target_%@：模块的实现及提供对外的方法调用Action_methodName，需要传参数时，都统一以NSDictionary*的形式传入。</p>
</li>
<li><p>CTMediator+%@扩展：扩展里声明了模块业务的对外接口，参数明确，这样外部调用者可以很容易理解如何调用接口。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T08:21:53.000Z" title="2024/3/1 16:21:53">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">16 分钟读完 (大约2382个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/">大厂常问iOS面试题--性能优化篇</a></p><div class="content"><h2 id="1-造成tableView卡顿的原因有哪些？"><a href="#1-造成tableView卡顿的原因有哪些？" class="headerlink" title="1.造成tableView卡顿的原因有哪些？"></a>1.造成tableView卡顿的原因有哪些？</h2><ul>
<li><p>1.最常用的就是cell的重用， 注册重用标识符</p>
<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</p>
<p>如果有很多数据的时候，就会堆积很多cell。</p>
<p>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</p>
</li>
<li><p>2.避免cell的重新布局</p>
<p>cell的布局填充等操作 比较耗时，一般创建时就布局好</p>
<p>如可以将cell单独放到一个自定义类，初始化时就布局好</p>
</li>
<li><p>3.提前计算并缓存cell的属性及内容</p>
<p>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</p>
<p>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>
</li>
<li><p>4.减少cell中控件的数量</p>
<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</p>
<p>不适用的可以先隐藏</p>
</li>
<li><p>5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>
<p>渲染耗时比较长</p>
</li>
<li><p>6.使用局部更新</p>
<p>如果只是更新某组的话，使用reloadSection进行局部更</p>
</li>
<li><p>7.加载网络数据，下载图片，使用异步加载，并缓存</p>
</li>
<li><p>8.少使用addView 给cell动态添加view</p>
</li>
<li><p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>
</li>
<li><p>10.不要实现无用的代理方法，tableView只遵守两个协议</p>
</li>
<li><p>11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</p>
</li>
<li><p>12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
</li>
<li><p>13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</p>
</li>
<li><p>14.使用正确的数据结构来存储数据。</p>
</li>
</ul>
<h2 id="2-如何提升-tableview-的流畅度？"><a href="#2-如何提升-tableview-的流畅度？" class="headerlink" title="2.如何提升 tableview 的流畅度？"></a>2.如何提升 tableview 的流畅度？</h2><ul>
<li><p>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。</p>
<p>CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制</p>
<p>GPU：纹理的渲染</p>
</li>
<li><p>卡顿优化在 CPU 层面</p>
<p>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</p>
<p>不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改</p>
<p>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</p>
<p>Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</p>
<p>图片的 size 最好刚好跟 UIImageView 的 size 保持一致</p>
<p>控制一下线程的最大并发数量</p>
<p>尽量把耗时的操作放到子线程</p>
<p>文本处理（尺寸计算、绘制）</p>
<p>图片处理（解码、绘制）</p>
</li>
<li><p>卡顿优化在 GPU层面</p>
<p>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</p>
<p>GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</p>
<p>尽量减少视图数量和层次</p>
<p>减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES</p>
<p>尽量避免出现离屏渲染</p>
</li>
<li><p>iOS 保持界面流畅的技巧</p>
<p>1.预排版，提前计算</p>
<p>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。</p>
<p>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式</p>
<p>2.预渲染，提前绘制</p>
<p>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了</p>
<p>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。</p>
<p>3.异步绘制</p>
<p>4.全局并发线程</p>
<p>5.高效的图片异步加载</p>
</li>
</ul>
<h2 id="3-APP启动时间应从哪些方面优化？"><a href="#3-APP启动时间应从哪些方面优化？" class="headerlink" title="3.APP启动时间应从哪些方面优化？"></a>3.APP启动时间应从哪些方面优化？</h2><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手</p>
<ul>
<li><p>dylib loading time</p>
<p>核心思想是减少dylibs的引用</p>
<p>合并现有的dylibs（最好是6个以内）</p>
<p>使用静态库</p>
</li>
<li><p>rebase&#x2F;binding time</p>
<p>核心思想是减少DATA块内的指针</p>
<p>减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）</p>
<p>减少c++虚函数</p>
<p>多使用Swift结构体（推荐使用swift）</p>
</li>
<li><p>ObjC setup time</p>
<p>核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时</p>
<p>initializer time</p>
</li>
<li><p>使用initialize替代load方法</p>
<p>减少使用c&#x2F;c++的attribute((constructor))；推荐使用dispatch_once() pthread_once() std:once()等方法</p>
<p>推荐使用swift</p>
<p>不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁</p>
<p>不要在初始化中创建线程</p>
</li>
</ul>
<h2 id="4-如何降低APP包的大小"><a href="#4-如何降低APP包的大小" class="headerlink" title="4.如何降低APP包的大小"></a>4.如何降低APP包的大小</h2><p>降低包大小需要从两方面着手</p>
<ul>
<li><p>可执行文件</p>
<p>编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</p>
<p>编写LLVM插件检测出重复代码、未被调用的代码</p>
</li>
<li><p>资源（图片、音频、视频 等）</p>
<p>优化的方式可以对资源进行无损的压缩</p>
<p>去除没有用到的资源</p>
</li>
</ul>
<h2 id="5-如何检测离屏渲染与优化"><a href="#5-如何检测离屏渲染与优化" class="headerlink" title="5.如何检测离屏渲染与优化"></a>5.如何检测离屏渲染与优化</h2><ul>
<li><p>检测，通过勾选Xcode的Debug-&gt;View Debugging–&gt;Rendering-&gt;Run-&gt;Color Offscreen-Rendered Yellow项。</p>
</li>
<li><p>优化，如阴影，在绘制时添加阴影的路径</p>
</li>
</ul>
<h2 id="6-怎么检测图层混合"><a href="#6-怎么检测图层混合" class="headerlink" title="6.怎么检测图层混合"></a>6.怎么检测图层混合</h2><p>1、模拟器debug中color blended layers红色区域表示图层发生了混合</p>
<p>2、Instrument-选中Core Animation-勾选Color Blended Layers</p>
<p>避免图层混合：</p>
<ul>
<li><p>确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明</p>
</li>
<li><p>如无特殊需要，不要设置低于1的alpha值</p>
</li>
<li><p>确保UIImage没有alpha通道</p>
</li>
</ul>
<p>UILabel图层混合解决方法：</p>
<p>iOS8以后设置背景色为非透明色并且设置label.layer.masksToBounds&#x3D;YES让label只会渲染她的实际size区域，就能解决UILabel的图层混合问题</p>
<p>iOS8 之前只要设置背景色为非透明的就行</p>
<p>为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？</p>
<p>UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</p>
<h2 id="7-日常如何检查内存泄露？"><a href="#7-日常如何检查内存泄露？" class="headerlink" title="7.日常如何检查内存泄露？"></a>7.日常如何检查内存泄露？</h2><ul>
<li><p>目前我知道的方式有以下几种</p>
<p>Memory Leaks</p>
<p>Alloctions</p>
<p>Analyse</p>
<p>Debug Memory Graph</p>
<p>MLeaksFinder</p>
</li>
<li><p>泄露的内存主要有以下两种：</p>
<p>Laek Memory 这种是忘记 Release 操作所泄露的内存。</p>
<p>Abandon Memory 这种是循环引用，无法释放掉的内存。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T06:51:50.000Z" title="2024/3/1 14:51:50">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">16 分钟读完 (大约2432个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/">大厂常问iOS面试题--多线程篇</a></p><div class="content"><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><ul>
<li><p>进程：</p>
<p>1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.</p>
<p>2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.</p>
<p>3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源</p>
</li>
<li><p>线程</p>
<p>1.程序执行流的最小单元，线程是进程中的一个实体.</p>
<p>2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程</p>
</li>
<li><p>进程和线程的关系</p>
<p>1.线程是进程的执行单元，进程的所有任务都在线程中执行</p>
<p>2.线程是 CPU 分配资源和调度的最小单位</p>
<p>3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程</p>
<p>4.同一个进程内的线程共享进程资源</p>
</li>
</ul>
<h2 id="2-什么是多线程？"><a href="#2-什么是多线程？" class="headerlink" title="2.什么是多线程？"></a>2.什么是多线程？</h2><ul>
<li><p>多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。</p>
</li>
<li><p>如果是多核CPU就真的可以同时处理多个线程了。</p>
</li>
<li><p>多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。</p>
</li>
</ul>
<h2 id="3-多线程的优点和缺点"><a href="#3-多线程的优点和缺点" class="headerlink" title="3.多线程的优点和缺点"></a>3.多线程的优点和缺点</h2><ul>
<li><p>优点:</p>
<p>能适当提高程序的执行效率</p>
<p>能适当提高资源利用率（CPU、内存利用率）</p>
</li>
<li><p>缺点:</p>
<p>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</p>
<p>线程越多，CPU在调度线程上的开销就越大</p>
<p>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p>
</li>
</ul>
<h2 id="4-多线程的-并行-和-并发-有什么区别？"><a href="#4-多线程的-并行-和-并发-有什么区别？" class="headerlink" title="4.多线程的 并行 和 并发 有什么区别？"></a>4.多线程的 并行 和 并发 有什么区别？</h2><ul>
<li><p>并行：充分利用计算机的多核，在多个线程上同步进行</p>
</li>
<li><p>并发：在一条线程上通过快速切换，让人感觉在同步进行</p>
</li>
</ul>
<h2 id="5-iOS中实现多线程的几种方案，各自有什么特点？"><a href="#5-iOS中实现多线程的几种方案，各自有什么特点？" class="headerlink" title="5.iOS中实现多线程的几种方案，各自有什么特点？"></a>5.iOS中实现多线程的几种方案，各自有什么特点？</h2><ul>
<li><p>NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。</p>
</li>
<li><p>GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。</p>
</li>
<li><p>NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。</p>
</li>
</ul>
<h2 id="6-多个网络请求完成后执行下一步"><a href="#6-多个网络请求完成后执行下一步" class="headerlink" title="6.多个网络请求完成后执行下一步"></a>6.多个网络请求完成后执行下一步</h2><ul>
<li><p>使用GCD的dispatch_group_t</p>
<p>创建一个dispatch_group_t</p>
<p>每次网络请求前先dispatch_group_enter,请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。</p>
<p>当所有enter的block都leave后，会执行dispatch_group_notify的block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_group_leave(downloadGroup);</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用GCD的信号量dispatch_semaphore_t</p>
<p>dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。dispatch_semaphore_signal(semaphore)为计数+1操作,dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。</p>
<p>创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        count++;</span><br><span class="line">        if (count==10) &#123;</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-多个网络请求顺序执行后执行下一步"><a href="#7-多个网络请求顺序执行后执行下一步" class="headerlink" title="7.多个网络请求顺序执行后执行下一步"></a>7.多个网络请求顺序执行后执行下一步</h2><ul>
<li><p>使用信号量semaphore</p>
<p>每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#8-异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="8.异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>8.异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><ul>
<li><p>这里使用dispatch_barrier_async栅栏方法即可实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-多线程中的死锁？"><a href="#9-多线程中的死锁？" class="headerlink" title="9.多线程中的死锁？"></a>9.多线程中的死锁？</h2><p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p>
<ul>
<li><p>互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
</li>
<li><p>请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
</li>
<li><p>不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
</li>
<li><p>环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<p>最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">// 什么也不会打印，直接报错</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-GCD执行原理？"><a href="#10-GCD执行原理？" class="headerlink" title="10.GCD执行原理？"></a>10.GCD执行原理？</h2><p><a target="_blank" rel="noopener" href="https://github.com/LGBamboo/iOS-article.02/blob/main/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98--%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87.md#10gcd%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"></a></p>
<ul>
<li><p>GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？） 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。</p>
</li>
<li><p>如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。</p>
</li>
<li><p>如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。</p>
</li>
<li><p>这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5–8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3–5条最为合理。</p>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/">1</a></li><li><a class="pagination-link" href="/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/logoNew.svg" alt="置身于正，勇于攀登"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">置身于正，勇于攀登</p><p class="is-size-6 is-block">大丈夫生于天地间 岂能郁郁久居人下</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">44</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">96</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/WTF_C69"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://qm.qq.com/cgi-bin/qm/qr?k=rTH0EcmelH7hsRL9MkYD1Xw8m7RT4NNV&amp;jump_from=webapi&amp;authKey=B+kszDp7XNLzePIu1HeGOokQtbHdJW79aOFDatCgh/dWveDNDOJ+KHAbSdrvelkR" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS审核上架交流群</span></span><span class="level-right"><span class="level-item tag">qm.qq.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">iOS开发</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="level-start"><span class="level-item">面试题</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/"><span class="level-start"><span class="level-item">好文收录</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/"><span class="level-start"><span class="level-item">缠论原文</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/07/"><span class="level-start"><span class="level-item">七月 2025</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4191566366727150" data-ad-slot="4095483014" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-05T15:45:12.000Z">2025-07-05</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A820%EF%BC%9A%E7%BC%A0%E4%B8%AD%E8%AF%B4%E7%A6%85%E8%B5%B0%E5%8A%BF%E4%B8%AD%E6%9E%A2%E7%BA%A7%E5%88%AB%E6%89%A9%E5%BC%A0%E5%8F%8A%E7%AC%AC%E4%B8%89%E7%B1%BB%E4%B9%B0%E5%8D%96%E7%82%B9/">教你炒股票20：缠中说禅走势中枢级别扩张及第三类买卖点</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-05T15:44:12.000Z">2025-07-05</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A819%EF%BC%9A%E5%AD%A6%E4%B9%A0%E7%BC%A0%E4%B8%AD%E8%AF%B4%E7%A6%85%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E7%90%86%E8%AE%BA%E7%9A%84%E5%85%B3%E9%94%AE/">教你炒股票19：学习缠中说禅技术分析理论的关键</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-05T15:43:51.000Z">2025-07-05</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A818%EF%BC%9A%E4%B8%8D%E8%A2%AB%E9%9D%A2%E9%A6%96%E7%9A%84%E9%9B%8F%E7%94%B7%E6%98%AF%E4%B8%8D%E5%AE%8C%E7%BE%8E%E7%9A%84%E3%80%82/">教你炒股票18：不被面首的雏男是不完美的</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-05T15:42:51.000Z">2025-07-05</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A817%EF%BC%9A%E8%B5%B0%E5%8A%BF%E7%BB%88%E5%AE%8C%E7%BE%8E/">教你炒股票17：走势终完美</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-05T15:41:51.000Z">2025-07-05</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A816%EF%BC%9A%E4%B8%AD%E5%B0%8F%E8%B5%84%E9%87%91%E7%9A%84%E9%AB%98%E6%95%88%E4%B9%B0%E5%8D%96%E6%B3%95/">教你炒股票16：中小资金的高效买卖法</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a><p class="is-size-7"><span>&copy; 2025 人间正道</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>