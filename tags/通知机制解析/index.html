<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta name="google-site-verification" content="4xeRrGz75ndIdizFDms5sFLsaZXJ4UfzKvxLBsSZKS8"><meta name="robots" content="index, follow"><title>标签: 通知机制解析 - 人间正道</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="人间正道是沧桑"><meta name="msapplication-TileImage" content="images/faviconNew.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="人间正道是沧桑"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:type" content="blog"><meta property="og:title" content="人间正道"><meta property="og:url" content="https://despacito2.github.io/"><meta property="og:site_name" content="人间正道"><meta property="og:description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://despacito2.github.io/img/og_image.png"><meta property="article:author" content="人间正道"><meta property="article:tag" content="编程"><meta property="article:tag" content="技术博客"><meta property="article:tag" content="工具推荐"><meta property="article:tag" content="人间正道"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://despacito2.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://despacito2.github.io/"},"headline":"人间正道","image":["https://despacito2.github.io/img/og_image.png"],"author":{"@type":"Person","name":"人间正道"},"publisher":{"@type":"Organization","name":"人间正道","logo":{"@type":"ImageObject","url":"https://despacito2.github.io/images/logo.png"}},"description":"一个记录编程笔记、技术工具和个人成长思考的博客。"}</script><link rel="icon" href="/images/faviconNew.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-4191566366727150" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/page">好文收录</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">通知机制解析</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:38:52.000Z" title="2024/3/2 22:38:52">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">28 分钟读完 (大约4194个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E7%AF%87/">大厂常问iOS面试题--通知机制解析篇</a></p><div class="content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是针对<code>iOS通知机制</code>的全面解析，从接口到原理面面俱到。同时也解决了<code>阿里、字节：一套高效的iOS面试题</code>中关于通知的问题，相信看完此文再也不怕面试官问我任何通知相关问题了</p>
<p>由于苹果没有对相关源码开放，所以以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计</p>
<h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>先把之前的问题列出来，详细读完本文之后，你会找到答案</p>
<ol>
<li>实现原理（结构设计、通知如何存储的、<code>name&amp;observer&amp;SEL</code>之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li><code>NSNotificationCenter</code>接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li><code>NSNotificationQueue</code>是异步还是同步发送？在哪个线程响应</li>
<li><code>NSNotificationQueue</code>和<code>runloop</code>的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="关键类结构"><a href="#关键类结构" class="headerlink" title="关键类结构"></a>关键类结构</h1><h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><p>用于描述通知的类，一个<code>NSNotification</code>对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line">...</span><br><span class="line">/* Querying a Notification Object */</span><br><span class="line"></span><br><span class="line">- (NSString*) name; // 通知的name</span><br><span class="line">- (id) object; // 携带的对象</span><br><span class="line">- (NSDictionary*) userInfo; // 配置信息</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般用于发送通知时使用，常用api如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而<code>NSNotificationCenter</code>类主要负责三件事</p>
<ol>
<li>添加通知</li>
<li>发送通知</li>
<li>移除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加通知</span><br><span class="line">- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">// 发送通知</span><br><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">// 删除通知</span><br><span class="line">- (void)removeObserver:(id)observer;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用<code>NSNotificationCenter</code>的发送接口进行发送通知，这么看<code>NSNotificationQueue</code>最终还是调用<code>NSNotificationCenter</code>进行消息的分发</p>
<p>另外<code>NSNotificationQueue</code>是依赖<code>runloop</code>的，所以如果线程的<code>runloop</code>未开启则无效，至于为什么依赖<code>runloop</code>下面会解释</p>
<p><code>NSNotificationQueue</code>主要做了两件事：</p>
<ol>
<li>添加通知到队列</li>
<li>删除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍</span><br><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</span><br><span class="line">// 删除通知，把满足合并条件的通知从队列中删除</span><br><span class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="队列的合并策略和发送时机"><a href="#队列的合并策略和发送时机" class="headerlink" title="队列的合并策略和发送时机"></a>队列的合并策略和发送时机</h3><p>把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br><span class="line">// 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</span><br><span class="line">    NSNotificationNoCoalescing = 0, // 默认不合并</span><br><span class="line">    NSNotificationCoalescingOnName = 1, // 只要name相同，就认为是相同通知</span><br><span class="line">    NSNotificationCoalescingOnSender = 2  // object相同</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="GSNotificationObserver"><a href="#GSNotificationObserver" class="headerlink" title="GSNotificationObserver"></a>GSNotificationObserver</h2><p>这个类是<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码中定义的，它的作用是代理观察者，主要用来实现接口：<code>addObserverForName：object: queue: usingBlock:</code>时用到，即要实现在指定队列回调block，那么<code>GSNotificationObserver</code>对象保存了<code>queue</code>和<code>block</code>信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把<code>block</code>抛到指定<code>queue</code>中执行，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@implementation GSNotificationObserver</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *_queue; // 保存传入的队列</span><br><span class="line">    GSNotificationBlock _block; // 保存传入的block</span><br><span class="line">&#125;</span><br><span class="line">- (id) initWithQueue: (NSOperationQueue *)queue </span><br><span class="line">               block: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">......初始化操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) dealloc</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">// 响应接收通知的方法，并在指定队列中执行block</span><br><span class="line">- (void) didReceiveNotification: (NSNotification *)notif</span><br><span class="line">&#123;</span><br><span class="line">    if (_queue != nil)</span><br><span class="line">    &#123;</span><br><span class="line">        GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] </span><br><span class="line">            initWithNotification: notif block: _block];</span><br><span class="line"></span><br><span class="line">        [_queue addOperation: op];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        CALL_BLOCK(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="存储容器"><a href="#存储容器" class="headerlink" title="存储容器"></a>存储容器</h2><p>上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation        *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable        nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable        named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct    Obs &#123;</span><br><span class="line">  id        observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL        selector;    /* 响应方法        */</span><br><span class="line">  struct Obs    *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h1><p>正式开始“注册通知”的深入研究，注册通知有几个常用方法，但只需要研究典型的一两个就够了，原理都是一样的</p>
<p>目前只介绍<code>NSNotificationCenter</code>的注册流程，<code>NSNotificationQueue</code>的方式在下面章节单独拎出来解释</p>
<h2 id="接口1"><a href="#接口1" class="headerlink" title="接口1"></a>接口1</h2><h3 id="直接看源码（精简版便于理解）"><a href="#直接看源码（精简版便于理解）" class="headerlink" title="直接看源码（精简版便于理解）"></a>直接看源码（精简版便于理解）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer：观察者，即通知的接收者</span><br><span class="line">selector：接收到通知时的响应方法</span><br><span class="line">name: 通知name</span><br><span class="line">object：携带对象</span><br><span class="line">*/</span><br><span class="line">- (void) addObserver: (id)observer</span><br><span class="line">            selector: (SEL)selector</span><br><span class="line">                name: (NSString*)name </span><br><span class="line">                object: (id)object &#123;</span><br><span class="line">  // 前置条件判断</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它</span><br><span class="line">  o = obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">/*======= case1： 如果name存在 =======*/</span><br><span class="line">  if (name) &#123;</span><br><span class="line">     //-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable</span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</span><br><span class="line">      if (n == 0) &#123; // 不存在，则创建 </span><br><span class="line">          m = mapNew(TABLE); // 先取缓存，如果缓存没有则新建一个map</span><br><span class="line">          GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在则把值取出来 赋值给m</span><br><span class="line">          m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">      &#125;</span><br><span class="line">     //-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节</span><br><span class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      if (n == 0) &#123;// 不存在，则创建 </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next = list-&gt;next;</span><br><span class="line">          list-&gt;next = o;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case2：如果name为空，但object不为空 =======*/</span><br><span class="line">  else if (object) &#123;</span><br><span class="line">      // 以object为key，从nameless字典中取出对应的value，value是个链表结构</span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      // 不存在则新建链表，并存到map中</span><br><span class="line">      if (n == 0) &#123; </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在 则把值接到链表的节点上</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case3：name 和 object 都为空 则存储到wildcard链表中 =======*/</span><br><span class="line">  else &#123;</span><br><span class="line">      o-&gt;next = WILDCARD;</span><br><span class="line">      WILDCARD = o;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>从上面介绍的<code>存储容器</code>中我们了解到<code>NCTable</code>结构体中核心的三个变量以及功能：<code>wildcard</code>、<code>named</code>、<code>nameless</code>，在源码中直接用宏定义表示了：<code>WILDCARD</code>、<code>NAMELESS</code>、<code>NAMED</code>，下面逻辑会用到</p>
<p>建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图</p>
<h4 id="case1-存在name（无论object是否存在）"><a href="#case1-存在name（无论object是否存在）" class="headerlink" title="case1: 存在name（无论object是否存在）"></a>case1: 存在<code>name</code>（无论object是否存在）</h4><ol>
<li>注册通知，如果通知的<code>name</code>存在，则以<code>name</code>为key从<code>named</code>字典中取出值<code>n</code>(这个<code>n</code>其实被<code>MapNode</code>包装了一层，便于理解这里直接认为没有包装)，这个<code>n</code>还是个字典，各种判空新建逻辑不讨论</li>
<li>然后以<code>object</code>为key，从字典<code>n</code>中取出对应的值，这个值就是<code>Observation</code>类型(后面简称<code>obs</code>)的链表，然后把刚开始创建的<code>obs</code>对象<code>o</code>存储进去</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p>这里就回答了上述<code>问题列表</code>的问题1的一部分，现在梳理下存储关系</p>
<p><img src="/images/NSNotification1.jpg"></p>
<p>如果注册通知时传入<code>name</code>，那么会是一个双层的存储结构</p>
<ol>
<li>找到<code>NCTable</code>中的<code>named</code>表，这个表存储了还有<code>name</code>的通知</li>
<li>以<code>name</code>作为key，找到<code>value</code>，这个<code>value</code>依然是一个<code>map</code></li>
<li><code>map</code>的结构是以<code>object</code>作为key，<code>obs</code>对象为value，这个<code>obs</code>对象的结构上面已经解释，主要存储了<code>observer &amp; SEL</code></li>
</ol>
<h4 id="case2-只存在object"><a href="#case2-只存在object" class="headerlink" title="case2: 只存在object"></a>case2: 只存在object</h4><ol>
<li>以<code>object</code>为key，从<code>nameless</code>字典中取出value，此value是个<code>obs</code>类型的链表</li>
<li>把创建的<code>obs</code>类型的对象<code>o</code>存储到链表中</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>只存在<code>object</code>时存储只有一层，那就是<code>object</code>和<code>obs</code>对象之间的映射</p>
<h4 id="case3-没有name和object"><a href="#case3-没有name和object" class="headerlink" title="case3: 没有name和object"></a>case3: 没有name和object</h4><p>这种情况直接把<code>obs</code>对象存放在了<code>Observation  *wildcard</code>  链表结构中</p>
<h2 id="接口2"><a href="#接口2" class="headerlink" title="接口2"></a>接口2</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>接口功能：</strong> 此接口实现的功能是在接收到通知时，在指定队列<code>queue</code>执行<code>block</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 这个api使用频率较低，怎么实现在指定队列回调block的，值得研究</span><br><span class="line">- (id) addObserverForName: (NSString *)name </span><br><span class="line">                   object: (id)object </span><br><span class="line">                    queue: (NSOperationQueue *)queue </span><br><span class="line">               usingBlock: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个临时观察者</span><br><span class="line">    GSNotificationObserver *observer = </span><br><span class="line">        [[GSNotificationObserver alloc] initWithQueue: queue block: block];</span><br><span class="line">    // 调用了接口1的注册方法</span><br><span class="line">    [self addObserver: observer </span><br><span class="line">             selector: @selector(didReceiveNotification:) </span><br><span class="line">                 name: name </span><br><span class="line">               object: object];</span><br><span class="line"></span><br><span class="line">    return observer;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明-1"><a href="#逻辑说明-1" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>这个接口依赖于<code>接口1</code>，只是多了一层代理观察者<code>GSNotificationObserver</code>，在<code>关键类结构</code>中已经介绍了它，设计思路值得学习</p>
<ol>
<li>创建一个<code>GSNotificationObserver</code>类型的对象<code>observer</code>，并把<code>queue</code>和<code>block</code>保存下来</li>
<li>调用接口1进行通知的注册</li>
<li>接收到通知时会响应<code>observer</code>的<code>didReceiveNotification:</code>方法，然后在<code>didReceiveNotification:</code>中把<code>block</code>抛给指定的<code>queue</code>去执行</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>从上述介绍可以总结，存储是以<code>name</code>和<code>object</code>为维度的，即判定是不是同一个通知要从<code>name</code>和<code>object</code>区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的，<code>问题列表</code>中的第九题也迎刃而解了</li>
<li>理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑</li>
<li>存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次</li>
</ol>
<h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>发送通知的核心逻辑比较简单，基本上就是查找和调用响应方法，核心函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">- (void) postNotificationName: (NSString*)name</span><br><span class="line">               object: (id)object</span><br><span class="line">             userInfo: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line">// 构造一个GSNotification对象， GSNotification继承了NSNotification</span><br><span class="line">  GSNotification    *notification;</span><br><span class="line">  notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone());</span><br><span class="line">  notification-&gt;_name = [name copyWithZone: [self zone]];</span><br><span class="line">  notification-&gt;_object = [object retain];</span><br><span class="line">  notification-&gt;_info = [info retain];</span><br><span class="line"></span><br><span class="line">  // 进行发送操作</span><br><span class="line">  [self _postAndRelease: notification];</span><br><span class="line">&#125;</span><br><span class="line">//发送通知的核心函数，主要做了三件事：查找通知、发送、释放资源</span><br><span class="line">- (void) _postAndRelease: (NSNotification*)notification &#123;</span><br><span class="line">    //step1: 从named、nameless、wildcard表中查找对应的通知</span><br><span class="line">    ...</span><br><span class="line">    //step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的</span><br><span class="line">       [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                    withObject: notification];</span><br><span class="line">    //step3: 释放资源</span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="逻辑说明-2"><a href="#逻辑说明-2" class="headerlink" title="逻辑说明"></a>逻辑说明</h2><p>其实上述代码注释说的很清晰了，主要做了三件事</p>
<ol>
<li>通过<code>name &amp; object</code> 查找到所有的<code>obs</code>对象(保存了<code>observer</code>和<code>sel</code>)，放到数组中</li>
<li>通过<code>performSelector：</code>逐一调用<code>sel</code>，这是个同步操作</li>
<li>释放<code>notification</code>对象</li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>从源码逻辑可以看出发送过程的概述：从三个存储容器中：<code>named</code>、<code>nameless</code>、<code>wildcard</code>去查找对应的<code>obs</code>对象，然后通过<code>performSelector：</code>逐一调用响应方法，这就完成了发送流程</p>
<p><strong>核心点：</strong></p>
<ol>
<li>同步发送</li>
<li>遍历所有列表，即注册多次通知就会响应多次</li>
</ol>
<h1 id="删除通知"><a href="#删除通知" class="headerlink" title="删除通知"></a>删除通知</h1><p>这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">源码</a>看下吧 <strong>要注意的点：</strong></p>
<ol>
<li>查找时仍然以<code>name</code>和<code>object</code>为维度的，再加上<code>observer</code>做区分</li>
<li>因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 删除已经注册的通知</span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">           name: (NSString*)name</span><br><span class="line">                 object: (id)object &#123;</span><br><span class="line">  if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil)</span><br><span class="line">      return;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">&#123;</span><br><span class="line">  if (observer == nil)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  [self removeObserver: observer name: nil object: nil];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h1><p>上面介绍的<code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了<code>runloop</code>的时机来触发的</p>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>下面为精简版的源码，看源码的注释，基本上能明白大致逻辑</p>
<ol>
<li>根据<code>coalesceMask</code>参数判断是否合并通知</li>
<li>接着根据<code>postingStyle</code>参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：<code>_asapQueue</code>、<code>_idleQueue</code></li>
</ol>
<p>核心点：</p>
<ol>
<li>队列是双向链表实现</li>
<li>当postingStyle值是立即发送时，调用的是<code>NSNotificationCenter</code>进行发送的，所以<code>NSNotificationQueue</code>还是依赖<code>NSNotificationCenter</code>进行发送</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 把要发送的通知添加到队列，等待发送</span><br><span class="line">* NSPostingStyle 和 coalesceMask在上面的类结构中有介绍</span><br><span class="line">* modes这个就和runloop有关了，指的是runloop的mode</span><br><span class="line">*/ </span><br><span class="line">- (void) enqueueNotification: (NSNotification*)notification</span><br><span class="line">        postingStyle: (NSPostingStyle)postingStyle</span><br><span class="line">        coalesceMask: (NSUInteger)coalesceMask</span><br><span class="line">            forModes: (NSArray*)modes</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">  // 判断是否需要合并通知</span><br><span class="line">  if (coalesceMask != NSNotificationNoCoalescing) &#123;</span><br><span class="line">      [self dequeueNotificationsMatching: notification</span><br><span class="line">                coalesceMask: coalesceMask];</span><br><span class="line">  &#125;</span><br><span class="line">  switch (postingStyle) &#123;</span><br><span class="line">      case NSPostNow: &#123;</span><br><span class="line">          ...</span><br><span class="line">          // 如果是立马发送，则调用NSNotificationCenter进行发送</span><br><span class="line">         [_center postNotification: notification];</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      case NSPostASAP:</span><br><span class="line">          // 添加到_asapQueue队列，等待发送</span><br><span class="line">        add_to_queue(_asapQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case NSPostWhenIdle:</span><br><span class="line">        // 添加到_idleQueue队列，等待发送</span><br><span class="line">        add_to_queue(_idleQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="发送通知-1"><a href="#发送通知-1" class="headerlink" title="发送通知"></a>发送通知</h2><p>这里截取了发送通知的核心代码，这个发送通知逻辑如下：</p>
<ol>
<li><code>runloop</code>触发某个时机，调用<code>GSPrivateNotifyASAP()</code>和<code>GSPrivateNotifyIdle()</code>方法，这两个方法最终都调用了<code>notify()</code>方法</li>
<li><code>notify()</code>所做的事情就是调用<code>NSNotificationCenter</code>的<code>postNotification:</code>进行发送通知</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void notify(NSNotificationCenter *center, </span><br><span class="line">                   NSNotificationQueueList *list,</span><br><span class="line">                   NSString *mode, NSZone *zone)</span><br><span class="line">&#123;</span><br><span class="line">     ......</span><br><span class="line">    // 循环遍历发送通知</span><br><span class="line">    for (pos = 0; pos &lt; len; pos++)</span><br><span class="line">    &#123;</span><br><span class="line">      NSNotification    *n = (NSNotification*)ptr[pos];</span><br><span class="line"></span><br><span class="line">      [center postNotification: n];</span><br><span class="line">      RELEASE(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br><span class="line">// 发送_asapQueue中的通知</span><br><span class="line">void GSPrivateNotifyASAP(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_asapQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line">// 发送_idleQueue中的通知</span><br><span class="line">void GSPrivateNotifyIdle(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_idleQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>对于<code>NSNotificationQueue</code>总结如下</p>
<ol>
<li>依赖<code>runloop</code>，所以如果在其他子线程使用<code>NSNotificationQueue</code>，需要开启runloop</li>
<li>最终还是通过<code>NSNotificationCenter</code>进行发送通知，所以这个角度讲它还是同步的</li>
<li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li>
</ol>
<h1 id="主线程响应通知"><a href="#主线程响应通知" class="headerlink" title="主线程响应通知"></a>主线程响应通知</h1><p>异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？</p>
<p>其实也是比较常见的问题了，基本上解决方式如下几种：</p>
<ol>
<li>使用<code>addObserverForName: object: queue: usingBlock</code>方法注册通知，指定在<code>mainqueue</code>上响应<code>block</code></li>
<li>在主线程注册一个<code>machPort</code>，它是用来做线程通信的，当在异步线程收到通知，然后给<code>machPort</code>发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文写的内容比较多，以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，全面阐述了通知的存储、发送、异步发送等原理，对研究学习有很大帮助</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/logoNew.svg" alt="置身于正，勇于攀登"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">置身于正，勇于攀登</p><p class="is-size-6 is-block">大丈夫生于天地间 岂能郁郁久居人下</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">74</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/WTF_C69"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://qm.qq.com/cgi-bin/qm/qr?k=rTH0EcmelH7hsRL9MkYD1Xw8m7RT4NNV&amp;jump_from=webapi&amp;authKey=B+kszDp7XNLzePIu1HeGOokQtbHdJW79aOFDatCgh/dWveDNDOJ+KHAbSdrvelkR" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS审核上架交流群</span></span><span class="level-right"><span class="level-item tag">qm.qq.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">iOS开发</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="level-start"><span class="level-item">面试题</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/"><span class="level-start"><span class="level-item">好文收录</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/"><span class="level-start"><span class="level-item">缠论原文</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/07/"><span class="level-start"><span class="level-item">七月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4191566366727150" data-ad-slot="4095483014" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T15:45:00.000Z">2025-07-04</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A810%EF%BC%9A2005%E5%B9%B46%E6%9C%88%EF%BC%8C%E6%9C%ACID%E4%B8%BA%E4%BD%95%E6%97%B6%E9%9A%94%E5%9B%9B%E5%B9%B4%E5%90%8E%E9%87%8D%E7%9C%8B%E8%82%A1%E7%A5%A8/">教你炒股票10：2005年6月，本ID为何时隔四年后重看股票</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T15:44:51.000Z">2025-07-04</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A89%EF%BC%9A%E7%94%84%E5%88%AB%E2%80%9C%E6%97%A9%E6%B3%84%E2%80%9D%E7%94%B7%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E5%88%99%EF%BC%81/">教你炒股票9：甄别“早泄”男的数学原则！</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T15:43:51.000Z">2025-07-04</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A88%EF%BC%9A%E6%8A%95%E8%B5%84%E5%A6%82%E9%80%89%E9%9D%A2%E9%A6%96%EF%BC%8CG%E7%82%B9%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%8C%E6%8B%92%E7%BB%9DED%E7%94%B7%EF%BC%81/">教你炒股票8：投资如选面首，G点为中心，拒绝ED男！</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T15:42:51.000Z">2025-07-04</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A87%EF%BC%9A%E7%BB%99%E8%B5%9A%E4%BA%86%E6%8C%87%E6%95%B0%E4%BA%8F%E4%BA%86%E9%92%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%A0%E5%91%8A/">教你炒股票7：给赚了指数亏了钱的一些忠告</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T15:41:51.000Z">2025-07-04</time></p><p class="title"><a href="/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A86%EF%BC%9A%E6%9C%ACID%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%94%E7%B2%AE%E6%B6%B2%E3%80%81%E5%8C%85%E9%92%A2%E6%9D%83%E8%AF%81%E4%B8%8A%E6%8F%90%E6%AC%BE%E7%9A%84%EF%BC%81/">教你炒股票6：本ID如何在五粮液、包钢权证上提款的！</a></p><p class="categories"><a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/">好文收录</a> / <a href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/">缠论原文</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a><p class="is-size-7"><span>&copy; 2025 人间正道</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>