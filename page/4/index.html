<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="google-site-verification" content="4xeRrGz75ndIdizFDms5sFLsaZXJ4UfzKvxLBsSZKS8"><meta name="robots" content="index, follow"><title>人间正道</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="人间正道是沧桑"><meta name="msapplication-TileImage" content="images/faviconNew.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="人间正道是沧桑"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:type" content="blog"><meta property="og:title" content="人间正道"><meta property="og:url" content="https://despacito2.github.io/"><meta property="og:site_name" content="人间正道"><meta property="og:description" content="一个记录编程笔记、技术工具和个人成长思考的博客。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://despacito2.github.io/img/og_image.png"><meta property="article:author" content="人间正道"><meta property="article:tag" content="编程"><meta property="article:tag" content="技术博客"><meta property="article:tag" content="工具推荐"><meta property="article:tag" content="人间正道"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://despacito2.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://despacito2.github.io/"},"headline":"人间正道","image":["https://despacito2.github.io/img/og_image.png"],"author":{"@type":"Person","name":"人间正道"},"publisher":{"@type":"Organization","name":"人间正道","logo":{"@type":"ImageObject","url":"https://despacito2.github.io/images/logo.png"}},"description":"一个记录编程笔记、技术工具和个人成长思考的博客。"}</script><link rel="icon" href="/images/faviconNew.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-4191566366727150" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95">好文收录</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:23:39.000Z" title="2024/3/2 23:23:39">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-03T16:00:00.000Z" title="2025/7/4 00:00:00">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">8 分钟读完 (大约1233个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/9fcf0002/">百度 iOS 面试真题总结（含一二三面深度解析）</a></p><div class="content"><p>本文记录了百度 iOS 岗位的三轮面试经历，涵盖 iOS 基础、UI 响应链、内存管理、多线程、源码阅读、OpenGL 渲染、跨语言知识（如 Python &amp; JVM）等内容，适合希望进入百度等大厂的 iOS 工程师参考。</p>
<hr>
<h2 id="百度一面：基础知识-跨平台能力"><a href="#百度一面：基础知识-跨平台能力" class="headerlink" title="百度一面：基础知识 + 跨平台能力"></a>百度一面：基础知识 + 跨平台能力</h2><h3 id="1-iOS-基础知识点"><a href="#1-iOS-基础知识点" class="headerlink" title="1. iOS 基础知识点"></a>1. iOS 基础知识点</h3><p>涉及 UIViewController 生命周期、视图加载时机、UI 响应链、图片加载、图标内存大小估算等。</p>
<h3 id="2-Python-基础知识"><a href="#2-Python-基础知识" class="headerlink" title="2. Python 基础知识"></a>2. Python 基础知识</h3><p>考察线程安全、多线程与集合类、类继承、JVM 基础等跨平台知识点，体现广度能力。</p>
<h3 id="3-iOS-源码阅读经验"><a href="#3-iOS-源码阅读经验" class="headerlink" title="3. iOS 源码阅读经验"></a>3. iOS 源码阅读经验</h3><p>面试官关注是否阅读过 AFNetworking、YYModel、Masonry 等三方库源码，建议提前准备一两处代码逻辑作为回答素材。</p>
<h3 id="4-OpenGL-GLSurfaceView-基础"><a href="#4-OpenGL-GLSurfaceView-基础" class="headerlink" title="4. OpenGL &amp; GLSurfaceView 基础"></a>4. OpenGL &amp; GLSurfaceView 基础</h3><p>图形绘制流程，包括 Shader 编程、FrameBuffer 配置、OpenGL 渲染管线的调用流程。</p>
<h3 id="5-项目优化实践"><a href="#5-项目优化实践" class="headerlink" title="5. 项目优化实践"></a>5. 项目优化实践</h3><p>主要围绕你负责的模块、性能优化方法（如卡顿检测、图片内存优化）、Crash 分析与修复方案等展开。</p>
<h3 id="6-多进程通信机制"><a href="#6-多进程通信机制" class="headerlink" title="6. 多进程通信机制"></a>6. 多进程通信机制</h3><p>提到 Android 的 Binder&#x2F;AIDL 机制，如果你有了解，也是体现技术深度和广度的加分项。</p>
<hr>
<h2 id="百度二面：深入理解-iOS-原理"><a href="#百度二面：深入理解-iOS-原理" class="headerlink" title="百度二面：深入理解 iOS 原理"></a>百度二面：深入理解 iOS 原理</h2><h3 id="1-Delegate、Notification-和-KVO-对比"><a href="#1-Delegate、Notification-和-KVO-对比" class="headerlink" title="1. Delegate、Notification 和 KVO 对比"></a>1. Delegate、Notification 和 KVO 对比</h3><ul>
<li>KVO：适合属性观察，自动触发，容易产生内存泄漏；</li>
<li>Notification：解耦强，适合广播型通信；</li>
<li>Delegate：一对一，强类型，结构清晰。</li>
</ul>
<h3 id="2-UI-中心视图实现方式"><a href="#2-UI-中心视图实现方式" class="headerlink" title="2. UI 中心视图实现方式"></a>2. UI 中心视图实现方式</h3><p>考察 AutoLayout（约束）、frame 手动设置、居中布局等方法的灵活掌握。</p>
<h3 id="3-触摸事件响应机制"><a href="#3-触摸事件响应机制" class="headerlink" title="3. 触摸事件响应机制"></a>3. 触摸事件响应机制</h3><ul>
<li>事件传递路径：UIApplication → UIWindow → ViewController → View；</li>
<li>FirstResponder 的确定；</li>
<li>UIResponder 链关系。</li>
</ul>
<h3 id="4-UIViewController-生命周期问题"><a href="#4-UIViewController-生命周期问题" class="headerlink" title="4. UIViewController 生命周期问题"></a>4. UIViewController 生命周期问题</h3><p>重点考察 <code>loadView</code>、<code>viewDidLoad</code> 的调用时机，以及仅 alloc 未使用的 VC 是否触发视图加载。</p>
<h3 id="5-UILabel-vs-drawRect-性能比较"><a href="#5-UILabel-vs-drawRect-性能比较" class="headerlink" title="5. UILabel vs drawRect 性能比较"></a>5. UILabel vs drawRect 性能比较</h3><p>系统控件（UILabel）通常自带优化；自绘方式性能高但复杂，适用于高度定制需求。</p>
<h3 id="6-AFNetworking-是否支持-IPv6？"><a href="#6-AFNetworking-是否支持-IPv6？" class="headerlink" title="6. AFNetworking 是否支持 IPv6？"></a>6. AFNetworking 是否支持 IPv6？</h3><p>考察是否了解苹果对 App 上架网络兼容性的要求，AF 在 iOS9+ 使用 NSURLSession 支持 IPv6。</p>
<h3 id="7-64-位架构与-i386-区别"><a href="#7-64-位架构与-i386-区别" class="headerlink" title="7. 64 位架构与 i386 区别"></a>7. 64 位架构与 i386 区别</h3><ul>
<li>i386 是 32 位模拟器架构；</li>
<li>x86_64 是 64 位；</li>
<li>arm64 是真机架构；</li>
<li>64 位系统提供更大的寻址空间、更高性能。</li>
</ul>
<h3 id="8-iOS-应用状态及后台执行"><a href="#8-iOS-应用状态及后台执行" class="headerlink" title="8. iOS 应用状态及后台执行"></a>8. iOS 应用状态及后台执行</h3><p>iOS 应用状态包括：Not running、Inactive、Active、Background、Suspended。退到后台时可使用任务保持短时间执行。</p>
<h3 id="9-图片内存计算"><a href="#9-图片内存计算" class="headerlink" title="9. 图片内存计算"></a>9. 图片内存计算</h3><p>例如 200×300 RGBA 图片：<code>200 × 300 × 4 = 240000 bytes ≈ 234KB</code>。</p>
<h3 id="10-Block-内存泄漏问题"><a href="#10-Block-内存泄漏问题" class="headerlink" title="10. Block 内存泄漏问题"></a>10. Block 内存泄漏问题</h3><p>Block 默认强引用外部变量（如 self），容易造成 retain cycle，需使用 <code>__weak</code> 或 <code>__block</code>。</p>
<h3 id="11-object-copy-是浅拷贝还是深拷贝？"><a href="#11-object-copy-是浅拷贝还是深拷贝？" class="headerlink" title="11. [object copy] 是浅拷贝还是深拷贝？"></a>11. [object copy] 是浅拷贝还是深拷贝？</h3><p>多数情况下是浅拷贝，除非手动实现 <code>copyWithZone:</code> 方法。需遵循 <code>NSCopying</code> 协议。</p>
<h3 id="12-Images-xcassets-的优势"><a href="#12-Images-xcassets-的优势" class="headerlink" title="12. Images.xcassets 的优势"></a>12. Images.xcassets 的优势</h3><p>支持 @2x&#x2F;@3x 自动加载、内存优化、打包统一管理等，推荐使用。</p>
<hr>
<h2 id="百度三面：底层机制-架构理解"><a href="#百度三面：底层机制-架构理解" class="headerlink" title="百度三面：底层机制 + 架构理解"></a>百度三面：底层机制 + 架构理解</h2><p>这一面偏重对核心知识点的深度理解，问题极其细致。</p>
<h3 id="1-内存管理原理"><a href="#1-内存管理原理" class="headerlink" title="1. 内存管理原理"></a>1. 内存管理原理</h3><p>涉及 ARC 自动引用计数、弱引用释放机制、AutoreleasePool 生命周期等。</p>
<h3 id="2-多线程基础"><a href="#2-多线程基础" class="headerlink" title="2. 多线程基础"></a>2. 多线程基础</h3><p>了解 GCD、NSOperationQueue 的实现与使用场景。</p>
<h3 id="3-队列与线程模型"><a href="#3-队列与线程模型" class="headerlink" title="3. 队列与线程模型"></a>3. 队列与线程模型</h3><p>主队列、串行&#x2F;并发队列、栅栏函数、线程同步策略的优劣。</p>
<h3 id="4-线程锁机制"><a href="#4-线程锁机制" class="headerlink" title="4. 线程锁机制"></a>4. 线程锁机制</h3><ul>
<li>@synchronized：简单但性能差；</li>
<li>NSLock、NSRecursiveLock、dispatch_semaphore、pthread_mutex 的应用场景；</li>
<li>死锁成因及避免方式。</li>
</ul>
<h3 id="5-MVVM-架构设计"><a href="#5-MVVM-架构设计" class="headerlink" title="5. MVVM 架构设计"></a>5. MVVM 架构设计</h3><p>数据与视图的解耦思维、数据绑定技术（如 KVO、RAC）、MVVM 和 MVC 的取舍。</p>
<hr>
<h2 id="面试总结-准备建议"><a href="#面试总结-准备建议" class="headerlink" title="面试总结 &amp; 准备建议"></a>面试总结 &amp; 准备建议</h2><p>百度的 iOS 面试难度不低，知识广度 + 深度要求都较高。涵盖了语言底层、UI 响应机制、网络、多线程、内存优化、架构设计等多个维度。</p>
<p>🎯 <strong>推荐重点准备方向：</strong></p>
<ul>
<li>Objective-C Runtime、KVO 实现、消息转发机制</li>
<li>ARC 内存管理 + Retain Cycle 处理策略</li>
<li>多线程并发处理（GCD、锁机制）</li>
<li>网络栈基本流程、IPv6 支持</li>
<li>自定义 UI 控件、性能优化</li>
<li>架构能力（MVC&#x2F;MVVM、组件化）</li>
</ul>
<hr>
<p>💡 希望这篇《百度 iOS 面试真题总结》对你有所帮助！如果你正在准备大厂面试，不妨将这些问题整理成知识图谱，逐个击破，祝你早日拿到满意 offer 🚀</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:22:11.000Z" title="2024/3/2 23:22:11">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">5 分钟读完 (大约787个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/d7c5f517/">拼多多最新iOS面试真题总结（JSON解析、多线程、安全性、架构设计）</a></p><div class="content"><h1 id="拼多多最新-iOS-面试真题总结"><a href="#拼多多最新-iOS-面试真题总结" class="headerlink" title="拼多多最新 iOS 面试真题总结"></a>拼多多最新 iOS 面试真题总结</h1><p>本文整理了拼多多 iOS 岗位面试中常见的真题，涵盖 JSON 转模型、夜间模式、架构设计、多线程安全、Block 机制等重点知识，适合拼多多及其他互联网公司 iOS 面试准备参考。</p>
<hr>
<h2 id="一面题目"><a href="#一面题目" class="headerlink" title="一面题目"></a>一面题目</h2><ol>
<li><p><strong>JSON 转模型实现方式</strong>  </p>
<ul>
<li>讨论如何将服务器返回的 JSON 数据转换为本地模型对象，涉及手写、第三方库（如 <code>YYModel</code>、<code>MJExtension</code>）等实现方式。</li>
</ul>
</li>
<li><p><strong>夜间模式设计</strong>  </p>
<ul>
<li>如何设计和实现夜间模式，切换颜色、样式及避免 UI 重绘卡顿。</li>
</ul>
</li>
<li><p><strong>播放器架构设计</strong>  </p>
<ul>
<li>简述播放器的模块划分、数据流及解码流程。</li>
</ul>
</li>
<li><p><strong>请求流程</strong>  </p>
<ul>
<li>网络请求从发起到接收响应的整个过程，包括 DNS 解析、TCP 连接、HTTP 协议。</li>
</ul>
</li>
<li><p><strong>服务端返回数据格式</strong>  </p>
<ul>
<li>除 JSON 外，还有哪些格式（XML、Protobuf、Thrift 等）。</li>
</ul>
</li>
<li><p><strong>哪些 Objective-C 对象是线程安全的</strong>  </p>
<ul>
<li>例如 <code>NSString</code>、<code>NSArray</code> 的不可变版本是线程安全的。</li>
</ul>
</li>
<li><p><strong>为什么要在主线程更新 UI</strong>  </p>
<ul>
<li>UIKit 线程模型及主线程限制。</li>
</ul>
</li>
<li><p><strong>如何保证 OC 容器在多线程下的数据安全性</strong>  </p>
<ul>
<li>使用锁机制、线程安全的集合类或 GCD。</li>
</ul>
</li>
<li><p><strong>SDWebImage 内存设计及更新原则</strong>  </p>
<ul>
<li>缓存策略、内存缓存与磁盘缓存的区别及更新时机。</li>
</ul>
</li>
<li><p><strong>算法题</strong>  </p>
<ul>
<li>判断括号匹配性（如 <code>()[]&#123;&#125;</code> 是否匹配）  </li>
<li>只有一种括号的情况下，计算最少需要加多少括号才能满足匹配</li>
</ul>
</li>
</ol>
<hr>
<h2 id="二面题目"><a href="#二面题目" class="headerlink" title="二面题目"></a>二面题目</h2><ol>
<li><p><strong>+load 和 +initialize 的理解与调用时机</strong>  </p>
<ul>
<li>讨论两者区别、调用顺序，父类与子类重写情况。</li>
</ul>
</li>
<li><p><strong>Objective-C 的动态性理解</strong>  </p>
<ul>
<li>运行时机制、消息发送、动态绑定。</li>
</ul>
</li>
<li><p><strong>消息转发机制及系统 API</strong>  </p>
<ul>
<li>消息重定向过程、<code>forwardInvocation:</code>、<code>methodSignatureForSelector:</code> 等。</li>
</ul>
</li>
<li><p><strong>Block 的理解</strong>  </p>
<ul>
<li>定义、使用场景。</li>
</ul>
</li>
<li><p><strong>Block 的变量捕获机制</strong>  </p>
<ul>
<li>变量如何捕获，捕获的变量类型（全局、栈、堆）。</li>
</ul>
</li>
<li><p><strong>__block 关键字实现原理</strong>  </p>
<ul>
<li>允许变量被修改，底层实现细节。</li>
</ul>
</li>
<li><p><strong>内存管理机制</strong>  </p>
<ul>
<li>ARC、MRC 的基本原理，引用计数机制。</li>
</ul>
</li>
<li><p><strong>用户点击屏幕后系统事件响应流程</strong>  </p>
<ul>
<li>如何找到触摸点对应的 View，事件传递链（Hit Testing 机制）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拼多多 iOS 面试注重基础扎实，涵盖数据解析、多线程安全、内存管理和运行时机制等方面，建议重点复习：</p>
<ul>
<li>JSON 与模型映射技巧  </li>
<li>夜间模式和架构设计思路  </li>
<li>Objective-C 运行时和消息机制  </li>
<li>Block 和变量捕获原理  </li>
<li>多线程下数据安全设计  </li>
<li>iOS 事件响应机制</li>
</ul>
<hr>
<p>欢迎大家留言交流，探讨更多面试技巧和知识点。祝你面试顺利，成功拿下拼多多 iOS 岗位！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:21:17.000Z" title="2024/3/2 23:21:17">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">10 分钟读完 (大约1563个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/320dce05/">抖音最新 iOS 面试真题汇总（2024年一二三面完整整理）</a></p><div class="content"><blockquote>
<p>本文整理了抖音 iOS 面试过程中遇到的<strong>最新真题汇总</strong>（涵盖一面、二面、三面），内容涉及数据结构、网络协议、系统架构、iOS 多线程、性能优化、底层原理等多个模块，适合准备大厂 iOS 岗位的开发者系统复习。</p>
</blockquote>
<hr>
<h2 id="🙋-面试前说明"><a href="#🙋-面试前说明" class="headerlink" title="🙋 面试前说明"></a>🙋 面试前说明</h2><p>由于时间有限，未能对所有题目撰写详解答案，但整体内容覆盖全面，记录了<strong>真实的面试题与准备过程</strong>，希望能为正在面试或准备面试的同学提供参考与帮助。欢迎交流讨论。</p>
<hr>
<h2 id="📌-一面面试题（技术基础-网络-多线程）"><a href="#📌-一面面试题（技术基础-网络-多线程）" class="headerlink" title="📌 一面面试题（技术基础 + 网络 + 多线程）"></a>📌 一面面试题（技术基础 + 网络 + 多线程）</h2><ol>
<li><p><strong>求二叉树两个节点的最近公共父节点</strong>  </p>
<ul>
<li>输入两个节点，可能为 null，可能不在树中。</li>
</ul>
</li>
<li><p><strong>反转链表</strong>（经典算法题）</p>
</li>
<li><p><strong>HTTP 基础与 HTTP&#x2F;2.0 新特性</strong>  </p>
<ul>
<li>多路复用、二进制帧、服务器推送等。</li>
</ul>
</li>
<li><p><strong>iOS9 - iOS13 每个版本说一个新特性</strong>  </p>
<ul>
<li>iOS 9：App Transport Security  </li>
<li>iOS 10：UserNotifications 框架  </li>
<li>iOS 11：大文件下载、拖拽  </li>
<li>iOS 12：性能优化，Screen Time  </li>
<li>iOS 13：深色模式、Combine 框架、SwiftUI</li>
</ul>
</li>
<li><p><strong>多个任务执行完后统一处理的方法有哪些？</strong>  </p>
<ul>
<li>使用 <code>dispatch_group</code>、信号量 <code>dispatch_semaphore</code>、栅栏 <code>dispatch_barrier_async</code></li>
</ul>
</li>
<li><p><strong>不用 SDWebImage 如何实现图片加载与缓存？</strong>  </p>
<ul>
<li>图片下载 → Memory Cache + Disk Cache → 显示  </li>
<li>简述 SDWebImage 核心架构：异步下载 + 缓存策略 + HashKey 管理</li>
</ul>
</li>
<li><p><strong>TableView 中多个 Cell 同时请求同一个图片 URL，如何避免重复请求？</strong>  </p>
<ul>
<li>请求去重（缓存或 URL 任务池）  </li>
<li>建立 url-task 映射池，任务完成后统一回调更新所有 UIImageView</li>
</ul>
</li>
<li><p><strong>滑动 TableView 时，GIF 动图为何不动？</strong>  </p>
<ul>
<li>RunLoop 切换为 <code>UITrackingRunLoopMode</code>，暂停了 <code>NSDefaultRunLoopMode</code> 下的任务</li>
</ul>
</li>
<li><p><strong>了解 WebSocket 吗？说一下作用和使用场景</strong>  </p>
<ul>
<li>长连接协议，适用于实时通讯（如 IM、弹幕、直播互动等）</li>
</ul>
</li>
</ol>
<hr>
<h2 id="📌-二面面试题（系统设计-网络协议-多线程）"><a href="#📌-二面面试题（系统设计-网络协议-多线程）" class="headerlink" title="📌 二面面试题（系统设计 + 网络协议 + 多线程）"></a>📌 二面面试题（系统设计 + 网络协议 + 多线程）</h2><ol>
<li><p><strong>如何不用递归遍历 UIView 的所有 subviews？</strong>  </p>
<ul>
<li>使用栈结构模拟 DFS 或 BFS</li>
</ul>
</li>
<li><p><strong>设计一个图片缓存系统（Memory + Disk）并代码实现</strong>  </p>
<ul>
<li>可借鉴 NSCache + 沙盒持久化逻辑</li>
</ul>
</li>
<li><p><strong>介绍 Clang&#x2F;LLVM 静态分析的基本原理</strong>  </p>
<ul>
<li>AST 抽象语法树 → 语义分析 → 规则检测（如 Xcode 的静态分析功能）</li>
</ul>
</li>
<li><p><strong>计算机网络的七层协议栈简述</strong></p>
</li>
<li><p><strong>HTTP 属于哪一层协议？</strong>  </p>
<ul>
<li>应用层协议</li>
</ul>
</li>
<li><p><strong>HTTP 常见返回码及含义？</strong>  </p>
<ul>
<li>200 OK、301&#x2F;302 重定向、403 禁止访问、404 找不到资源、500 服务器错误</li>
</ul>
</li>
<li><p><strong>HTTP 除了 GET&#x2F;POST，还有哪些方法？</strong>  </p>
<ul>
<li>PUT、DELETE、HEAD、OPTIONS、PATCH</li>
</ul>
</li>
<li><p><strong>HTTPS 简要介绍</strong>  </p>
<ul>
<li>基于 HTTP + TLS&#x2F;SSL 加密协议  </li>
<li>包含对称加密、非对称加密、数字证书</li>
</ul>
</li>
<li><p><strong>HTTPS 能防止中间人攻击吗？为什么？</strong>  </p>
<ul>
<li>是的。通过证书校验和加密通信防止篡改与监听</li>
</ul>
</li>
<li><p><strong>TCP 与 UDP 的区别？</strong></p>
</li>
<li><p><strong>线程与进程的区别？</strong></p>
</li>
<li><p><strong>线程之间如何通信？</strong></p>
</li>
<li><p><strong>不用 GCD 如何保证线程安全？</strong></p>
</li>
</ol>
<ul>
<li>使用锁机制（如 NSLock、pthread_mutex）</li>
</ul>
<ol start="14">
<li><strong>iOS 多线程实现方式有哪些？</strong></li>
</ol>
<ul>
<li>NSThread、GCD、NSOperationQueue</li>
</ul>
<ol start="15">
<li><p><strong>同步与异步的区别？</strong></p>
</li>
<li><p><strong>串行队列与并发队列区别？</strong></p>
</li>
<li><p><strong>队列和线程的关系？</strong></p>
</li>
<li><p><strong>死锁是如何产生的？有哪些必要条件？</strong></p>
</li>
</ol>
<ul>
<li>互斥、请求保持、不可剥夺、循环等待</li>
</ul>
<hr>
<h2 id="📌-三面面试题（网络底层-性能优化-系统架构）"><a href="#📌-三面面试题（网络底层-性能优化-系统架构）" class="headerlink" title="📌 三面面试题（网络底层 + 性能优化 + 系统架构）"></a>📌 三面面试题（网络底层 + 性能优化 + 系统架构）</h2><ol>
<li><p><strong>合并两个有序链表（LeetCode 经典题）</strong></p>
</li>
<li><p><strong>HTTPS 使用对称加密还是非对称加密？</strong>  </p>
<ul>
<li>握手阶段用非对称，通信阶段用对称加密</li>
</ul>
</li>
<li><p><strong>TCP 的慢启动、拥塞控制、快重传介绍</strong></p>
</li>
<li><p><strong>客户端发起网络请求到响应的全过程？</strong>  </p>
<ul>
<li>DNS解析 → TCP握手 → HTTPS握手 → 发送请求 → 接收响应 → 渲染页面</li>
</ul>
</li>
<li><p><strong>DNS 查询过程中的 ISP 服务器不可用，会怎样？</strong>  </p>
<ul>
<li>递归或迭代请求下一级 DNS 服务器，如根域名服务器 → 顶级域名服务器 → 权威 DNS</li>
</ul>
</li>
<li><p><strong>字典转模型的架构设计 + 夜间模式的设计</strong>  </p>
<ul>
<li>字典转模型可采用 KVC、Swift Codable  </li>
<li>夜间模式基于主题管理中心&#x2F;通知机制更新 UI</li>
</ul>
</li>
<li><p><strong>为何不使用第三方库如 YYModel、MJExtension？</strong>  </p>
<ul>
<li>可控性差、不灵活、依赖大，调试困难  </li>
<li>自定义方案更轻量、更好维护</li>
</ul>
</li>
<li><p><strong>夜间模式的缺点与优化？</strong>  </p>
<ul>
<li>缺点：耗电、维护成本高  </li>
<li>优化：使用动态色值、样式隔离</li>
</ul>
</li>
<li><p><strong>iOS 中的锁有哪些？</strong>  </p>
<ul>
<li>OSSpinLock（已废弃）、NSLock、@synchronized、dispatch_semaphore、pthread_mutex</li>
</ul>
</li>
<li><p><strong>常见数据存储方式？你项目中怎么用的？</strong></p>
</li>
</ol>
<ul>
<li>UserDefaults、Plist、Keychain、SQLite（FMDB）</li>
</ul>
<ol start="11">
<li><strong>线程安全错误的常见表现？</strong></li>
</ol>
<ul>
<li>数据竞争、崩溃、数据错乱，常发生在 UI 更新或共享资源访问时</li>
</ul>
<hr>
<h2 id="✅-总结：抖音-iOS-面试知识结构梳理"><a href="#✅-总结：抖音-iOS-面试知识结构梳理" class="headerlink" title="✅ 总结：抖音 iOS 面试知识结构梳理"></a>✅ 总结：抖音 iOS 面试知识结构梳理</h2><table>
<thead>
<tr>
<th>模块</th>
<th>涉及题型</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>链表反转、合并链表、树的最近公共祖先</td>
</tr>
<tr>
<td>网络</td>
<td>HTTP&#x2F;2、HTTPS、WebSocket、TCP&#x2F;UDP、七层协议</td>
</tr>
<tr>
<td>多线程</td>
<td>GCD、信号量、栅栏、死锁、线程通信</td>
</tr>
<tr>
<td>系统设计</td>
<td>图片缓存系统、夜间模式、字典转模型</td>
</tr>
<tr>
<td>工具原理</td>
<td>LLVM、静态分析</td>
</tr>
<tr>
<td>项目经验</td>
<td>SDWebImage 实现、缓存优化、DNS 故障处理</td>
</tr>
</tbody></table>
<hr>
<p>🧠 <strong>建议准备：</strong></p>
<ul>
<li>常见算法题练熟（链表、二叉树、排序）</li>
<li>网络协议 &amp; HTTPS 握手过程深入理解</li>
<li>多线程调度机制（GCD、NSOperation）掌握细节</li>
<li>项目经验表达清晰，能举出优化点</li>
<li>iOS 系统架构底层原理适当了解</li>
</ul>
<hr>
<p>📎 如果你正在准备 iOS 面试，欢迎点赞收藏，持续更新更多真题汇总与答案详解。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:19:11.000Z" title="2024/3/2 23:19:11">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">6 分钟读完 (大约953个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/885f2aac/">头条-最新iOS面试真题总结</a></p><div class="content"><h1 id="头条最新iOS面试真题总结"><a href="#头条最新iOS面试真题总结" class="headerlink" title="头条最新iOS面试真题总结"></a>头条最新iOS面试真题总结</h1><p>本文汇总了头条iOS面试中的经典真题，涵盖基础知识、算法、架构设计及多线程等方面。内容来源于真实面试经验，适合准备iOS相关岗位面试的同学参考。</p>
<blockquote>
<p><strong>温馨提示：</strong><br>本文侧重题目整理，部分知识点可结合官方文档和经典书籍深入学习。欢迎留言交流，互相提升。</p>
</blockquote>
<hr>
<h2 id="一面题目汇总"><a href="#一面题目汇总" class="headerlink" title="一面题目汇总"></a>一面题目汇总</h2><ol>
<li>自我介绍及项目相关介绍  </li>
<li>如何自定义导航跳转  </li>
<li>Runtime的理解与应用  </li>
<li>KVC（键值编码）的用途及原理  </li>
<li>Method Swizzling的注意事项  </li>
<li>引用计数机制的理解  </li>
<li>RunLoop的理解与状态  </li>
<li>AutoreleasePool的使用场景  </li>
<li>TableView性能优化，如何减少卡顿  </li>
<li>属性关键字：copy、assign、retain、weak的区别和使用场景  </li>
<li>JSON转Model的实现思路  </li>
<li>代码布局规范  </li>
<li>多屏幕适配方案  </li>
<li>HTTP请求头与响应头解析  </li>
<li>Cookie机制  </li>
<li>NSCache缓存机制介绍  </li>
<li>自己设计一个缓存器的思路  </li>
<li>LRU缓存算法的实现方式  </li>
<li>SDWebImage的基本原理  </li>
<li>二叉树先序遍历（递归和非递归实现）</li>
</ol>
<hr>
<h2 id="二面题目汇总"><a href="#二面题目汇总" class="headerlink" title="二面题目汇总"></a>二面题目汇总</h2><ol>
<li>MVC架构存在的缺点  </li>
<li>介绍其他架构模式（如MVVM、VIPER等）  </li>
<li>常见编码方式（UTF-8、UTF-16等）  </li>
<li>字符串翻转算法设计  </li>
<li>多线程实现方式及其区别（NSThread、GCD、NSOperation）  </li>
<li>队列和线程的关系  </li>
<li>线程安全相关题目及解决方案  </li>
<li>各种锁的类型及区别（互斥锁、自旋锁、读写锁等）  </li>
<li>属性关键字的详细解释  </li>
<li>assign是否可以用于OC对象，及其风险  </li>
<li>copy与strong的区别  </li>
<li>weak是如何实现自动赋nil的  </li>
<li>为什么不可变对象属性使用copy更安全  </li>
<li>assign在对象中的使用注意点  </li>
<li>pod update与pod install的区别  </li>
<li>layoutIfNeeded与setNeedsLayout的区别  </li>
<li>抓包工具如何抓取HTTPS请求的原理  </li>
<li>isEqual与hash方法的关系  </li>
<li>Bitmap数据结构介绍  </li>
<li>可变数组的实现原理  </li>
<li>如何hook一个对象的方法而不影响其他对象  </li>
<li>代码中如何避免大量if else写法  </li>
<li>自旋锁和互斥锁的区别及使用场景</li>
</ol>
<hr>
<h2 id="三面题目汇总"><a href="#三面题目汇总" class="headerlink" title="三面题目汇总"></a>三面题目汇总</h2><ol>
<li>详细介绍项目经验，重点讲自己擅长的技术点  </li>
<li>数组copy后，里面的元素是否复制一份新对象？  </li>
<li>浅拷贝和深拷贝的区别与实现方式  </li>
<li>TCP为什么是三次握手，四次挥手？原理解析</li>
</ol>
<hr>
<h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p>头条iOS面试通常采用视频形式，一条龙流程服务较完善。面试内容覆盖基础知识广泛，既有理论考察，也注重实际项目经验和算法能力。建议候选人重点夯实以下方面：</p>
<ul>
<li>Objective-C及Swift语言基础  </li>
<li>iOS常用设计模式与架构  </li>
<li>Runtime机制和相关技术（如Method Swizzling、消息转发等）  </li>
<li>多线程与并发编程（GCD、NSOperation、锁机制等）  </li>
<li>网络协议和请求处理（HTTP&#x2F;HTTPS、TCP&#x2F;IP）  </li>
<li>算法与数据结构基础（字符串处理、树、链表、排序等）  </li>
<li>项目经验梳理，能够清晰描述技术细节和难点</li>
</ul>
<hr>
<p>欢迎大家收藏与分享，也可以留言补充或提问，一起进步！</p>
<hr>
<p><strong>相关资源推荐：</strong></p>
<ul>
<li>《Objective-C高级编程》  </li>
<li>《iOS开发者面试宝典》  </li>
<li>Ray Wenderlich iOS教程  </li>
<li>LeetCode算法题刷题平台</li>
</ul>
<p>祝你面试顺利，早日拿到理想offer！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:15:31.000Z" title="2024/3/2 23:15:31">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">13 分钟读完 (大约1929个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/1fe28a79/">快手-最新iOS面试真题总结</a></p><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面的是快手X3岗位，视频面试，不支持周末，但是可以选择晚上时间。视频面试是通过牛客网进行的，以下是记下来的各轮面试题，对于一些iOS基础知识就不做解答了。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>1、用递归写一个算法，计算从1到100的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func sum(value: Int) -&gt; Int &#123;</span><br><span class="line">    if value &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    var number = value</span><br><span class="line">    return value + sum(value: number - 1)</span><br><span class="line">&#125;</span><br><span class="line">// 计算过程</span><br><span class="line">let result = sum(value: 100)</span><br><span class="line">print(result)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>写完算法之后又围绕着问了几个问题，都是算法基础：</p>
<ul>
<li>算法的时间复杂度是多少</li>
<li>递归会有什么缺点</li>
<li>不用递归能否实现，复杂度能否降到O(1)</li>
</ul>
<p>2、<code>property</code>的作用是什么，有哪些关键词，分别是什么含义？</p>
<p>3、父类的<code>property</code>是如何查找的？</p>
<p>4、<code>NSArray</code>、<code>NSDictionary</code>应该如何选关键词？</p>
<p>5、<code>copy</code>和<code>muteCopy</code>有什么区别，深复制和浅复制是什么意思，如何实现深复制？</p>
<p>6、用<code>runtime</code>做过什么事情？<code>runtime</code>中的方法交换是如何实现的？</p>
<p>7、讲一下对KVC合KVO的了解，KVC是否会调用<code>setter</code>方法？</p>
<p>8、<code>__block</code>有什么作用</p>
<p>9、说一下对GCD的了解，它有那些方法，分别是做什么用的？</p>
<p>10、对二叉树是否了解？</p>
<p>面试官是想接着问这方面的问题的。我当时说了不了解，然后就没有后续了。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>1、ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？</p>
<p>2、在MRC下执行<code>[object autorelease]</code>会发生什么，<code>autorelease</code>是如何实现的？</p>
<p>3、OC如何实现多继承？</p>
<p>这个当时没有答好。其实借助于消息转发，<code>protocol</code>和类别都可以间接实现多继承。</p>
<p>4、对设计模式有什么了解，讲一下其中一种是如何使用的。</p>
<p>5、有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。</p>
<p>6、一张100*100，RGBA的png图像解压之后占多大内存空间。</p>
<p>5、算法题</p>
<p>题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。</p>
<p>这个并没有要求写出来，说是提供思路就行了。我当时给的方案是在便利数组的时候，用一个字典把便利的元素存起来，如果在后面的便利过程中新元素在字典中存在过就说明，有重复数字出现。时间复杂度是O(n)。</p>
<p>当时也问了有没有办法进行优化，我当时想到了将数组转成<code>Set</code>，然后和原数组比较，两个集合的数量是否变化。</p>
<p>7、因为我跟他介绍自己Swift用的多一些，然后问了些Swift跟OC的区别，各自的优缺点。</p>
<p>8、为什么离职，有什么职业规划。</p>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>1、给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个是leetcode的<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/">179题</a>，难度中等。面试官让先说思路，再去做题。事先说一下这个题我没有做过。当时的思路是用冒泡法进行排序，排序的前提是将较少位数的数字进行循环补齐，例如3和30的比较，变成33和30的比较，34和4的比较变成34和44的比较，然后将结果从大到小整合成字符串输出。</p>
<p>但是做题是却发现没那么简单，位数的补齐对于2位和3位数的比较还需要求位数的最小公倍数，将他们都转成6位数才能比较。在挣扎了5分钟做了就做罢了。</p>
<p>后来再去做这道题，其实这就是一个排序而已，只不过他的规则是按高位优先级更高的原则，而这一点跟字符串的比较保持一致，如果再加一些Swift的高阶函数，就可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func largestNumber(_ nums: [Int]) -&gt; String &#123;</span><br><span class="line">    let sort = nums.map &#123;&quot;\($0)&quot;&#125;.sorted &#123; (lStr, rStr) -&gt; Bool in</span><br><span class="line">        return lStr + rStr &gt; rStr + lStr</span><br><span class="line">    &#125;</span><br><span class="line">    let result = sort.joined()</span><br><span class="line">    if result.prefix(1) == &quot;0&quot; &#123;</span><br><span class="line">        return &quot;0&quot;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%BF%AB%E6%89%8B1.jpg"></p>
<p>2、项目中有这么一个方法<code>func findfile(dir: String suffix: String) -&gt; [String]</code> ，可以通过输入文件夹目录，和后缀检索出所需的文件。</p>
<p>例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？</p>
<p>我首先想到的是这么多需求不可能一个方法就完成，需要根据不同场景拆出不同的方法，但是这些同属于文件操作，会有一个共同使用的方法就是检索文件。这个方法需要传入文件目录，然后递归的返回当前目录所有文件路径。外部不同场景的调用逻辑就用一个<code>enum</code>完成，不同值对应相同范围的不同种类。</p>
<p>面试官比较关注内部共用的文件检索怎么写，他说子文件如果过多怎么办，如何优化。我有点懵，查找文件至少是要遍历一遍的，子文件过多，这个应该是没法优化的啊。中间卡了一段时间，后来他给了提示说是不是可以用block实现，将文件路径返回出去，由外部决定当前文件是否可用，最终外部的调用类是这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//我的方案</span><br><span class="line">//func findDir(_ dir: String) -&gt; [String]</span><br><span class="line">//block方案</span><br><span class="line">func findDir(_ dir: String, block: ((String) -&gt; Bool))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我想来确实没毛病，用block返回内容至少不会将该目录的所有文件都由一个对象持有，而前面一堆的铺垫其实也都是为验证block方案的好处。</p>
<p>其实事后想下这个问题没啥难的，这种写法自己也有写过，但当时就是没想起来，可能前面一圈的铺垫给我带偏了吧，说亏也不亏，以后多多努力吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a target="_blank" rel="noopener" href="https://github.com/LGBamboo/iOS-article.01/blob/main/iOS%E9%9D%A2%E8%AF%95--%E6%9C%80%E6%96%B0%E5%BF%AB%E6%89%8BiOS%E9%9D%A2%E8%AF%95%E9%A2%98.md#%E6%80%BB%E7%BB%93"></a></p>
<p>整体来看，快手的面试题跟我在别处看到的iOS面试题对比要简单些。一面主要是基础知识，二面考察更全面一些，更多让自己谈一些对技术的理解，三面则是更偏实践一些。</p>
<p>算法虽然三轮都有，但相对比较简单，即使写不出来，有思路也是可以的。当然写出来肯定是加分项，所以大家准备面试时，应该都看一下。算法相关的，排序，数组，二叉树，这几类是重点。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T15:12:18.000Z" title="2024/3/2 23:12:18">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">5 分钟读完 (大约748个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/5a0f7207/">字节跳动-最新iOS面试真题</a></p><div class="content"><h1 id="字节跳动最新iOS面试真题总结"><a href="#字节跳动最新iOS面试真题总结" class="headerlink" title="字节跳动最新iOS面试真题总结"></a>字节跳动最新iOS面试真题总结</h1><p>以下内容基于字节跳动iOS面试中真实遇到的题目，涵盖基础知识、算法、网络、多线程和系统设计等多个方面。适合面试准备者系统复习。</p>
<hr>
<h2 id="一面题目"><a href="#一面题目" class="headerlink" title="一面题目"></a>一面题目</h2><ol>
<li>自我介绍  </li>
<li>介绍简历中的一个项目  </li>
<li>面向对象的三个要素（封装、继承、多态）  </li>
<li>多态的理解  </li>
<li>Java、Python、Objective-C运行效率比较  </li>
<li>Property详解，copy修饰符如何工作？  </li>
<li>Property(nonatomic, copy)修饰NSMutableArray会有什么问题？  </li>
<li>copy和mutableCopy的区别  </li>
<li>类别（Category）的原理及实现  </li>
<li>封装和重载的解释  </li>
<li>Objective-C是否支持多重继承？  </li>
<li>UITableView的复用原理  </li>
<li>UITableView滑动卡顿的优化方法  </li>
<li>viewDidLoad和viewDidAppear的调用时机及调用次数差异  </li>
<li>页面间传值方式（属性传值、协议、Block、通知、extern全局变量、NSUserDefaults）  </li>
<li>通知与代理（delegate）的区别  </li>
<li>通知发送和接收是否在同一线程？  </li>
<li>HTTP与HTTPS的区别  </li>
<li>Objective-C中多线程的几种实现方案  </li>
<li>NSURLConnection与NSURLSession的了解  </li>
<li>NSURLSession的实现原理  </li>
<li>HTTP常见的状态码及含义  </li>
<li>编程题：实现二叉树的倒置</li>
</ol>
<hr>
<h2 id="二面题目"><a href="#二面题目" class="headerlink" title="二面题目"></a>二面题目</h2><ol>
<li>博弈论题：老虎吃羊问题  </li>
<li>算法题：青蛙跳格子问题（斐波那契数列）  </li>
<li>熟悉使用的框架介绍  </li>
<li>如何实现SDWebImage的二级缓存机制  </li>
<li>@autoreleasepool { NSString *s; } 与 NSString *s; 的区别  </li>
<li>对autorelease的理解  </li>
<li>HTTP的理解  </li>
<li>HTTP返回状态码详解  </li>
<li>为什么说HTTP是无状态协议  </li>
<li>为什么不用原生APNS实现推送  </li>
<li>GCD的了解  </li>
<li>dispatch_group_t与dispatch_barrier_sync的区别  </li>
<li>NSOperation的使用及理解  </li>
<li>NSOperationQueue的使用</li>
</ol>
<hr>
<h2 id="三面题目"><a href="#三面题目" class="headerlink" title="三面题目"></a>三面题目</h2><ol>
<li>算法题：仅包含三种元素的数组排序，要求时间复杂度O(n)  </li>
<li>Objective-C程序的编译和链接过程理解  </li>
<li>内存管理相关操作（ARC、MRC等）  </li>
<li>响应链原理  </li>
<li>hitTest方法是否尝试过重写，重写的场景和注意点  </li>
<li>HTTP、Session和Cookie的区别和联系  </li>
<li>线程和队列的关系  </li>
<li>CALayer与UIView的关系和区别</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字节跳动的iOS面试涵盖了语言基础、架构设计、网络、多线程、算法以及系统底层机制，难度较高，注重应试者对核心概念的理解和实际编码能力。建议结合项目经验，系统复习基础知识和算法，熟悉面试中常见的设计题和编程题，提升解决问题的思路和表达能力。</p>
<hr>
<p><strong>推荐复习资料：</strong></p>
<ul>
<li>《Objective-C高级编程》  </li>
<li>《iOS开发者面试宝典》  </li>
<li>LeetCode经典算法题库  </li>
<li>Apple官方文档关于Runtime和内存管理章节</li>
</ul>
<p>祝你面试顺利，成功拿到Offer！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:55:35.000Z" title="2024/3/2 22:55:35">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">14 分钟读完 (大约2073个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/ef543022/">大厂常问iOS面试题--视图和图形篇</a></p><div class="content"><p>本篇我们来讲一下 【iOS面试题的视图&amp;图形】相关的问题.</p>
<h2 id="视图-图像相关"><a href="#视图-图像相关" class="headerlink" title="视图&amp;图像相关"></a>视图&amp;图像相关</h2><p>主要问题列表如下:</p>
<ol>
<li>AutoLayout的原理，性能如何</li>
<li>UIView &amp; CALayer的区别</li>
<li>事件响应链</li>
<li>drawrect &amp; layoutsubviews调用时机</li>
<li>UI的刷新原理</li>
<li>隐式动画 &amp; 显示动画区别</li>
<li>什么是离屏渲染</li>
<li>imageName&amp;imageWithContentsOfFile区别</li>
<li>多个相同的图片，会重复加载吗</li>
<li>图片是什么时候解码的，如何优化</li>
<li>图片渲染怎么优化</li>
<li>如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</li>
</ol>
<h3 id="1-AutoLayout的原理，性能如何"><a href="#1-AutoLayout的原理，性能如何" class="headerlink" title="1.AutoLayout的原理，性能如何?"></a>1.AutoLayout的原理，性能如何?</h3><h4 id="AutoLayout的原理"><a href="#AutoLayout的原理" class="headerlink" title="AutoLayout的原理"></a>AutoLayout的原理</h4><blockquote>
<p>来历 一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（<a target="_blank" rel="noopener" href="http://constraints.cs.washington.edu/solvers/uist97.html">论文地址:http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的<a target="_blank" rel="noopener" href="http://constraints.cs.washington.edu/cassowary/">Cassowary网站上http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的<a target="_blank" rel="noopener" href="https://github.com/pybee/cassowary%E3%80%82%E8%87%AA%E4%BB%8E%E5%AE%83%E5%8F%91%E5%B8%83%E4%BB%A5%E6%9D%A5JavaScript%EF%BC%8C.NET%EF%BC%8CJAVA%EF%BC%8CSmalltall%E5%92%8CC++%E9%83%BD%E6%9C%89%E7%9B%B8%E5%BA%94%E7%9A%84%E5%BA%93%E3%80%822011%E5%B9%B4%E8%8B%B9%E6%9E%9C%E5%B0%86%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E8%BF%90%E7%94%A8%E5%88%B0%E4%BA%86%E8%87%AA%E5%AE%B6%E7%9A%84%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E%E4%B8%AD%EF%BC%8C%E7%BE%8E%E5%85%B6%E5%90%8D%E6%9B%B0Auto">https://github.com/pybee/cassowary。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto</a> Layout。</p>
</blockquote>
<p>论文下载链接比较慢,我下载了一份<a target="_blank" rel="noopener" href="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/Cassowary.pdf">Cassowary原文放到了我的博客 大家可以自由下载</a>.</p>
<p><strong>AutoLayout的原理就是用Cassowary算法来将布局问题抽象成线性不等式，并分解成多个位置间的约束</strong> 因为多了计算视图大小frame的过程,所以性能肯定没有指定Frame坐标要快.</p>
<p>详细的原理以及高阶原理请参考戴铭老师的文章 <a target="_blank" rel="noopener" href="http://www.starming.com/2015/11/03/deeply-analyse-autolayout/">戴铭老师写的 深入剖析Auto Layout，分析iOS各版本新增特性</a></p>
<h4 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何?"></a>性能如何?</h4><p>下面是<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/220/">WWDC2018 High Performance Auto Layout</a>中对比的iOS12和iOS11下分别使用自动布局的性能对比现场.</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/HighPerformanceAutoLayoutiOS11iOS12Compare.gif"><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A21.gif"></a></p>
<p>经过实验得出如下图标结论:</p>
<p><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A22.jpg"></p>
<p>iOS12之前，视图嵌套的数量对性能的影响是呈指数级增长的，而iOS12优化之后对性能的影响是线性增长，对性能消耗不大。</p>
<p>无论如何优化也肯定不如CGRectFrame那样的设置更加直接,性能更好.</p>
<h3 id="2-UIView-CALayer的区别"><a href="#2-UIView-CALayer的区别" class="headerlink" title="2.UIView &amp; CALayer的区别"></a>2.UIView &amp; CALayer的区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>UIView</th>
<th>CALayer</th>
</tr>
</thead>
<tbody><tr>
<td>继承父类</td>
<td>UIView:UIResponder:NSObject</td>
<td>CALayer:NSObject</td>
</tr>
<tr>
<td>用途</td>
<td>可以处理触摸事件</td>
<td>不处理用户的交互,不参与响应事件传递</td>
</tr>
<tr>
<td>两者关系</td>
<td>有一个CALayer成员变量 eg: view.layer</td>
<td>是UIView的成员变量</td>
</tr>
<tr>
<td>分工</td>
<td>处理交互层事件并包装各种图形的简单设置</td>
<td>底层渲染图形,支持动画</td>
</tr>
</tbody></table>
<h3 id="3-事件响应链"><a href="#3-事件响应链" class="headerlink" title="3.事件响应链"></a>3.事件响应链</h3><p>下面这篇文章我已经在前几篇将runloop的时候提了不止一次,前列建议阅读,快手的同事大部分都以这个理解为标准</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a></p>
<h3 id="4-drawrect-layoutsubviews调用时机"><a href="#4-drawrect-layoutsubviews调用时机" class="headerlink" title="4. drawrect &amp; layoutsubviews调用时机"></a>4. drawrect &amp; layoutsubviews调用时机</h3><p><code>layoutSubviews:</code>(相当于layoutSubviews()函数)在以下情况下会被调用：</p>
<ol>
<li>init初始化不会触发layoutSubviews。</li>
<li>addSubview会触发layoutSubviews。</li>
<li>设置view的Frame会触发layoutSubviews (frame发生变化触发)。</li>
<li>滚动一个UIScrollView会触发layoutSubviews。</li>
<li>旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>直接调用setLayoutSubviews。</li>
</ol>
<p><code>drawrect:</code>(drawrect()函数)在以下情况下会被调用：</p>
<ol>
<li><code>drawrect:</code>是在UIViewController的<code>loadView:</code>和<code>ViewDidLoad:</code>方法之后调用.</li>
<li>当我们调用<code>[UIFont的 sizeToFit]</code>后,会触发系统自动调用<code>drawRect:</code></li>
<li>当设置UIView的contentMode或者Frame后会立即触发触发系统调用<code>drawRect:</code></li>
<li>直接调用<code>setNeedsDisplay</code>设置标记 或<code>setNeedsDisplayInRect:</code>的时候会触发<code>drawRect:</code></li>
</ol>
<blockquote>
<p>知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a120d6c64d88">UIView的渲染过程</a>.</p>
</blockquote>
<h3 id="5-UI的刷新原理"><a href="#5-UI的刷新原理" class="headerlink" title="5.UI的刷新原理"></a>5.UI的刷新原理</h3><p>这个问题我不知道问的是不是iOS离屏渲染过程,我来简单的回到一下这个吧</p>
<p>iOS 的<code>MainRunloop</code> 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕在这过程中要完成以下的工作:</p>
<ul>
<li>view的缓冲区创建</li>
<li>view内容的绘制(如果重写了 drawRect)</li>
<li>接收和处理系统的触摸事件</li>
</ul>
<p>我们看到的UI图形实际上是CPU和GPU不断配合工作的结果.经过<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a120d6c64d88">UIView的渲染过程</a> 后我们的UI会不间断的接收系统图给我们的事件.</p>
<p>由于主线程的runloop 一直在回调,我们的UI就得到了刷新的窗口,是渲染还是处理事件都是因为runloop不断工作的结果.前几篇我们学过 main线程的runloop默认是启动的.因为我们响应交互.</p>
<p>不知道我这样回答是否满足这个问题的答案.如果回答的不对烦请下方评论区留言 告知我将持续改进.</p>
<h3 id="6-隐式动画-显示动画区别"><a href="#6-隐式动画-显示动画区别" class="headerlink" title="6.隐式动画 &amp; 显示动画区别"></a>6.隐式动画 &amp; 显示动画区别</h3><p>隐式动画一直存在 如需关闭需设置 显式动画是不存在，如需显式 要开启</p>
<p>只需要观察动画执行完成的结果 比如: 一个简单UIView的frame移动 如果从A点移动到B点 移动完成 回到原始位置就是隐式动画</p>
<p>Core Animation 是显式动画.因为它既可以直接对其layer属性做动画，也可以覆盖默认的图层行为.</p>
<h3 id="7-imageName-imageWithContentsOfFile区别"><a href="#7-imageName-imageWithContentsOfFile区别" class="headerlink" title="7.imageName&amp;imageWithContentsOfFile区别"></a>7.imageName&amp;imageWithContentsOfFile区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>UIView</th>
<th>imageWithContentsOfFile</th>
</tr>
</thead>
<tbody><tr>
<td>不同点</td>
<td>会图片缓存到内存中</td>
<td>无缓存</td>
</tr>
</tbody></table>
<h3 id="8-什么是离屏渲染"><a href="#8-什么是离屏渲染" class="headerlink" title="8.什么是离屏渲染"></a>8.什么是离屏渲染</h3><p><img src="/images/%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A23.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72653360">iOS离屏渲染的深入研究</a></p>
<h3 id="9-多个相同的图片，会重复加载吗"><a href="#9-多个相同的图片，会重复加载吗" class="headerlink" title="9.多个相同的图片，会重复加载吗"></a>9.多个相同的图片，会重复加载吗</h3><p>不会,GPU有 像素点缓存的mask.</p>
<h3 id="10-图片是什么时候解码的，如何优化"><a href="#10-图片是什么时候解码的，如何优化" class="headerlink" title="10.图片是什么时候解码的，如何优化"></a>10.图片是什么时候解码的，如何优化</h3><p>是加载到内存中,从UIImge-&gt;CGImage-&gt;CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码.</p>
<h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><p>自己手动操作图片的编码API</p>
<p>CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库.</p>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/pinterest/PINRemoteImage">PINRemoteImage</a>或者<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYWebImage">YYWebImage</a>开源</p>
<h3 id="11-图片渲染怎么优化"><a href="#11-图片渲染怎么优化" class="headerlink" title="11.图片渲染怎么优化"></a>11.图片渲染怎么优化</h3><p>可以从阴影,圆角入手.帧率,电量,图片的锯齿等等.</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/748f9abafff8">iOS开发-视图渲染与性能优化</a></p>
<h3 id="12-如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决"><a href="#12-如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决" class="headerlink" title="12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决"></a>12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</h3><p>现象是 图形清晰,场景逼真,但是一般arm芯片的GPU 刷新超过60Hz一定会超级费电,手机发热导致降频.FPS降低,因为低能耗电量不足,无法支持GPU高刷新率</p>
<p>解决办法只能用xcode自带工具检测,看渲染过程哪里可以优化.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单回答了一些图形相关的问题,大部分都是iOS离屏渲染,这个地方大家要认真学习.很多资料看起来比较耗时.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:38:52.000Z" title="2024/3/2 22:38:52">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.931Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">28 分钟读完 (大约4194个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/a5c69c69/">大厂常问iOS面试题--通知机制解析篇</a></p><div class="content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是针对<code>iOS通知机制</code>的全面解析，从接口到原理面面俱到。同时也解决了<code>阿里、字节：一套高效的iOS面试题</code>中关于通知的问题，相信看完此文再也不怕面试官问我任何通知相关问题了</p>
<p>由于苹果没有对相关源码开放，所以以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计</p>
<h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>先把之前的问题列出来，详细读完本文之后，你会找到答案</p>
<ol>
<li>实现原理（结构设计、通知如何存储的、<code>name&amp;observer&amp;SEL</code>之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li><code>NSNotificationCenter</code>接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li><code>NSNotificationQueue</code>是异步还是同步发送？在哪个线程响应</li>
<li><code>NSNotificationQueue</code>和<code>runloop</code>的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="关键类结构"><a href="#关键类结构" class="headerlink" title="关键类结构"></a>关键类结构</h1><h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><p>用于描述通知的类，一个<code>NSNotification</code>对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line">...</span><br><span class="line">/* Querying a Notification Object */</span><br><span class="line"></span><br><span class="line">- (NSString*) name; // 通知的name</span><br><span class="line">- (id) object; // 携带的对象</span><br><span class="line">- (NSDictionary*) userInfo; // 配置信息</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般用于发送通知时使用，常用api如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而<code>NSNotificationCenter</code>类主要负责三件事</p>
<ol>
<li>添加通知</li>
<li>发送通知</li>
<li>移除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加通知</span><br><span class="line">- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">// 发送通知</span><br><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">// 删除通知</span><br><span class="line">- (void)removeObserver:(id)observer;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用<code>NSNotificationCenter</code>的发送接口进行发送通知，这么看<code>NSNotificationQueue</code>最终还是调用<code>NSNotificationCenter</code>进行消息的分发</p>
<p>另外<code>NSNotificationQueue</code>是依赖<code>runloop</code>的，所以如果线程的<code>runloop</code>未开启则无效，至于为什么依赖<code>runloop</code>下面会解释</p>
<p><code>NSNotificationQueue</code>主要做了两件事：</p>
<ol>
<li>添加通知到队列</li>
<li>删除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍</span><br><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</span><br><span class="line">// 删除通知，把满足合并条件的通知从队列中删除</span><br><span class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="队列的合并策略和发送时机"><a href="#队列的合并策略和发送时机" class="headerlink" title="队列的合并策略和发送时机"></a>队列的合并策略和发送时机</h3><p>把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br><span class="line">// 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</span><br><span class="line">    NSNotificationNoCoalescing = 0, // 默认不合并</span><br><span class="line">    NSNotificationCoalescingOnName = 1, // 只要name相同，就认为是相同通知</span><br><span class="line">    NSNotificationCoalescingOnSender = 2  // object相同</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="GSNotificationObserver"><a href="#GSNotificationObserver" class="headerlink" title="GSNotificationObserver"></a>GSNotificationObserver</h2><p>这个类是<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码中定义的，它的作用是代理观察者，主要用来实现接口：<code>addObserverForName：object: queue: usingBlock:</code>时用到，即要实现在指定队列回调block，那么<code>GSNotificationObserver</code>对象保存了<code>queue</code>和<code>block</code>信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把<code>block</code>抛到指定<code>queue</code>中执行，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@implementation GSNotificationObserver</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *_queue; // 保存传入的队列</span><br><span class="line">    GSNotificationBlock _block; // 保存传入的block</span><br><span class="line">&#125;</span><br><span class="line">- (id) initWithQueue: (NSOperationQueue *)queue </span><br><span class="line">               block: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">......初始化操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) dealloc</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">// 响应接收通知的方法，并在指定队列中执行block</span><br><span class="line">- (void) didReceiveNotification: (NSNotification *)notif</span><br><span class="line">&#123;</span><br><span class="line">    if (_queue != nil)</span><br><span class="line">    &#123;</span><br><span class="line">        GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] </span><br><span class="line">            initWithNotification: notif block: _block];</span><br><span class="line"></span><br><span class="line">        [_queue addOperation: op];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        CALL_BLOCK(_block, notif);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="存储容器"><a href="#存储容器" class="headerlink" title="存储容器"></a>存储容器</h2><p>上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation        *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable        nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable        named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct    Obs &#123;</span><br><span class="line">  id        observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL        selector;    /* 响应方法        */</span><br><span class="line">  struct Obs    *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h1><p>正式开始“注册通知”的深入研究，注册通知有几个常用方法，但只需要研究典型的一两个就够了，原理都是一样的</p>
<p>目前只介绍<code>NSNotificationCenter</code>的注册流程，<code>NSNotificationQueue</code>的方式在下面章节单独拎出来解释</p>
<h2 id="接口1"><a href="#接口1" class="headerlink" title="接口1"></a>接口1</h2><h3 id="直接看源码（精简版便于理解）"><a href="#直接看源码（精简版便于理解）" class="headerlink" title="直接看源码（精简版便于理解）"></a>直接看源码（精简版便于理解）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer：观察者，即通知的接收者</span><br><span class="line">selector：接收到通知时的响应方法</span><br><span class="line">name: 通知name</span><br><span class="line">object：携带对象</span><br><span class="line">*/</span><br><span class="line">- (void) addObserver: (id)observer</span><br><span class="line">            selector: (SEL)selector</span><br><span class="line">                name: (NSString*)name </span><br><span class="line">                object: (id)object &#123;</span><br><span class="line">  // 前置条件判断</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它</span><br><span class="line">  o = obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">/*======= case1： 如果name存在 =======*/</span><br><span class="line">  if (name) &#123;</span><br><span class="line">     //-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable</span><br><span class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</span><br><span class="line">      if (n == 0) &#123; // 不存在，则创建 </span><br><span class="line">          m = mapNew(TABLE); // 先取缓存，如果缓存没有则新建一个map</span><br><span class="line">          GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在则把值取出来 赋值给m</span><br><span class="line">          m = (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">      &#125;</span><br><span class="line">     //-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节</span><br><span class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      if (n == 0) &#123;// 不存在，则创建 </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          list = (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next = list-&gt;next;</span><br><span class="line">          list-&gt;next = o;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case2：如果name为空，但object不为空 =======*/</span><br><span class="line">  else if (object) &#123;</span><br><span class="line">      // 以object为key，从nameless字典中取出对应的value，value是个链表结构</span><br><span class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      // 不存在则新建链表，并存到map中</span><br><span class="line">      if (n == 0) &#123; </span><br><span class="line">          o-&gt;next = ENDOBS;</span><br><span class="line">          GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123; // 存在 则把值接到链表的节点上</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/*======= case3：name 和 object 都为空 则存储到wildcard链表中 =======*/</span><br><span class="line">  else &#123;</span><br><span class="line">      o-&gt;next = WILDCARD;</span><br><span class="line">      WILDCARD = o;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>从上面介绍的<code>存储容器</code>中我们了解到<code>NCTable</code>结构体中核心的三个变量以及功能：<code>wildcard</code>、<code>named</code>、<code>nameless</code>，在源码中直接用宏定义表示了：<code>WILDCARD</code>、<code>NAMELESS</code>、<code>NAMED</code>，下面逻辑会用到</p>
<p>建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图</p>
<h4 id="case1-存在name（无论object是否存在）"><a href="#case1-存在name（无论object是否存在）" class="headerlink" title="case1: 存在name（无论object是否存在）"></a>case1: 存在<code>name</code>（无论object是否存在）</h4><ol>
<li>注册通知，如果通知的<code>name</code>存在，则以<code>name</code>为key从<code>named</code>字典中取出值<code>n</code>(这个<code>n</code>其实被<code>MapNode</code>包装了一层，便于理解这里直接认为没有包装)，这个<code>n</code>还是个字典，各种判空新建逻辑不讨论</li>
<li>然后以<code>object</code>为key，从字典<code>n</code>中取出对应的值，这个值就是<code>Observation</code>类型(后面简称<code>obs</code>)的链表，然后把刚开始创建的<code>obs</code>对象<code>o</code>存储进去</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p>这里就回答了上述<code>问题列表</code>的问题1的一部分，现在梳理下存储关系</p>
<p><img src="/images/NSNotification1.jpg"></p>
<p>如果注册通知时传入<code>name</code>，那么会是一个双层的存储结构</p>
<ol>
<li>找到<code>NCTable</code>中的<code>named</code>表，这个表存储了还有<code>name</code>的通知</li>
<li>以<code>name</code>作为key，找到<code>value</code>，这个<code>value</code>依然是一个<code>map</code></li>
<li><code>map</code>的结构是以<code>object</code>作为key，<code>obs</code>对象为value，这个<code>obs</code>对象的结构上面已经解释，主要存储了<code>observer &amp; SEL</code></li>
</ol>
<h4 id="case2-只存在object"><a href="#case2-只存在object" class="headerlink" title="case2: 只存在object"></a>case2: 只存在object</h4><ol>
<li>以<code>object</code>为key，从<code>nameless</code>字典中取出value，此value是个<code>obs</code>类型的链表</li>
<li>把创建的<code>obs</code>类型的对象<code>o</code>存储到链表中</li>
</ol>
<p><strong>数据结构关系图</strong></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>只存在<code>object</code>时存储只有一层，那就是<code>object</code>和<code>obs</code>对象之间的映射</p>
<h4 id="case3-没有name和object"><a href="#case3-没有name和object" class="headerlink" title="case3: 没有name和object"></a>case3: 没有name和object</h4><p>这种情况直接把<code>obs</code>对象存放在了<code>Observation  *wildcard</code>  链表结构中</p>
<h2 id="接口2"><a href="#接口2" class="headerlink" title="接口2"></a>接口2</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>接口功能：</strong> 此接口实现的功能是在接收到通知时，在指定队列<code>queue</code>执行<code>block</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 这个api使用频率较低，怎么实现在指定队列回调block的，值得研究</span><br><span class="line">- (id) addObserverForName: (NSString *)name </span><br><span class="line">                   object: (id)object </span><br><span class="line">                    queue: (NSOperationQueue *)queue </span><br><span class="line">               usingBlock: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    // 创建一个临时观察者</span><br><span class="line">    GSNotificationObserver *observer = </span><br><span class="line">        [[GSNotificationObserver alloc] initWithQueue: queue block: block];</span><br><span class="line">    // 调用了接口1的注册方法</span><br><span class="line">    [self addObserver: observer </span><br><span class="line">             selector: @selector(didReceiveNotification:) </span><br><span class="line">                 name: name </span><br><span class="line">               object: object];</span><br><span class="line"></span><br><span class="line">    return observer;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="逻辑说明-1"><a href="#逻辑说明-1" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><p>这个接口依赖于<code>接口1</code>，只是多了一层代理观察者<code>GSNotificationObserver</code>，在<code>关键类结构</code>中已经介绍了它，设计思路值得学习</p>
<ol>
<li>创建一个<code>GSNotificationObserver</code>类型的对象<code>observer</code>，并把<code>queue</code>和<code>block</code>保存下来</li>
<li>调用接口1进行通知的注册</li>
<li>接收到通知时会响应<code>observer</code>的<code>didReceiveNotification:</code>方法，然后在<code>didReceiveNotification:</code>中把<code>block</code>抛给指定的<code>queue</code>去执行</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>从上述介绍可以总结，存储是以<code>name</code>和<code>object</code>为维度的，即判定是不是同一个通知要从<code>name</code>和<code>object</code>区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的，<code>问题列表</code>中的第九题也迎刃而解了</li>
<li>理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑</li>
<li>存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次</li>
</ol>
<h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>发送通知的核心逻辑比较简单，基本上就是查找和调用响应方法，核心函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">- (void) postNotificationName: (NSString*)name</span><br><span class="line">               object: (id)object</span><br><span class="line">             userInfo: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line">// 构造一个GSNotification对象， GSNotification继承了NSNotification</span><br><span class="line">  GSNotification    *notification;</span><br><span class="line">  notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone());</span><br><span class="line">  notification-&gt;_name = [name copyWithZone: [self zone]];</span><br><span class="line">  notification-&gt;_object = [object retain];</span><br><span class="line">  notification-&gt;_info = [info retain];</span><br><span class="line"></span><br><span class="line">  // 进行发送操作</span><br><span class="line">  [self _postAndRelease: notification];</span><br><span class="line">&#125;</span><br><span class="line">//发送通知的核心函数，主要做了三件事：查找通知、发送、释放资源</span><br><span class="line">- (void) _postAndRelease: (NSNotification*)notification &#123;</span><br><span class="line">    //step1: 从named、nameless、wildcard表中查找对应的通知</span><br><span class="line">    ...</span><br><span class="line">    //step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的</span><br><span class="line">       [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                    withObject: notification];</span><br><span class="line">    //step3: 释放资源</span><br><span class="line">    RELEASE(notification);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="逻辑说明-2"><a href="#逻辑说明-2" class="headerlink" title="逻辑说明"></a>逻辑说明</h2><p>其实上述代码注释说的很清晰了，主要做了三件事</p>
<ol>
<li>通过<code>name &amp; object</code> 查找到所有的<code>obs</code>对象(保存了<code>observer</code>和<code>sel</code>)，放到数组中</li>
<li>通过<code>performSelector：</code>逐一调用<code>sel</code>，这是个同步操作</li>
<li>释放<code>notification</code>对象</li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>从源码逻辑可以看出发送过程的概述：从三个存储容器中：<code>named</code>、<code>nameless</code>、<code>wildcard</code>去查找对应的<code>obs</code>对象，然后通过<code>performSelector：</code>逐一调用响应方法，这就完成了发送流程</p>
<p><strong>核心点：</strong></p>
<ol>
<li>同步发送</li>
<li>遍历所有列表，即注册多次通知就会响应多次</li>
</ol>
<h1 id="删除通知"><a href="#删除通知" class="headerlink" title="删除通知"></a>删除通知</h1><p>这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">源码</a>看下吧 <strong>要注意的点：</strong></p>
<ol>
<li>查找时仍然以<code>name</code>和<code>object</code>为维度的，再加上<code>observer</code>做区分</li>
<li>因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 删除已经注册的通知</span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">           name: (NSString*)name</span><br><span class="line">                 object: (id)object &#123;</span><br><span class="line">  if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil)</span><br><span class="line">      return;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) removeObserver: (id)observer</span><br><span class="line">&#123;</span><br><span class="line">  if (observer == nil)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  [self removeObserver: observer name: nil object: nil];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h1><p>上面介绍的<code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了<code>runloop</code>的时机来触发的</p>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>下面为精简版的源码，看源码的注释，基本上能明白大致逻辑</p>
<ol>
<li>根据<code>coalesceMask</code>参数判断是否合并通知</li>
<li>接着根据<code>postingStyle</code>参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：<code>_asapQueue</code>、<code>_idleQueue</code></li>
</ol>
<p>核心点：</p>
<ol>
<li>队列是双向链表实现</li>
<li>当postingStyle值是立即发送时，调用的是<code>NSNotificationCenter</code>进行发送的，所以<code>NSNotificationQueue</code>还是依赖<code>NSNotificationCenter</code>进行发送</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 把要发送的通知添加到队列，等待发送</span><br><span class="line">* NSPostingStyle 和 coalesceMask在上面的类结构中有介绍</span><br><span class="line">* modes这个就和runloop有关了，指的是runloop的mode</span><br><span class="line">*/ </span><br><span class="line">- (void) enqueueNotification: (NSNotification*)notification</span><br><span class="line">        postingStyle: (NSPostingStyle)postingStyle</span><br><span class="line">        coalesceMask: (NSUInteger)coalesceMask</span><br><span class="line">            forModes: (NSArray*)modes</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">  // 判断是否需要合并通知</span><br><span class="line">  if (coalesceMask != NSNotificationNoCoalescing) &#123;</span><br><span class="line">      [self dequeueNotificationsMatching: notification</span><br><span class="line">                coalesceMask: coalesceMask];</span><br><span class="line">  &#125;</span><br><span class="line">  switch (postingStyle) &#123;</span><br><span class="line">      case NSPostNow: &#123;</span><br><span class="line">          ...</span><br><span class="line">          // 如果是立马发送，则调用NSNotificationCenter进行发送</span><br><span class="line">         [_center postNotification: notification];</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      case NSPostASAP:</span><br><span class="line">          // 添加到_asapQueue队列，等待发送</span><br><span class="line">        add_to_queue(_asapQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case NSPostWhenIdle:</span><br><span class="line">        // 添加到_idleQueue队列，等待发送</span><br><span class="line">        add_to_queue(_idleQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="发送通知-1"><a href="#发送通知-1" class="headerlink" title="发送通知"></a>发送通知</h2><p>这里截取了发送通知的核心代码，这个发送通知逻辑如下：</p>
<ol>
<li><code>runloop</code>触发某个时机，调用<code>GSPrivateNotifyASAP()</code>和<code>GSPrivateNotifyIdle()</code>方法，这两个方法最终都调用了<code>notify()</code>方法</li>
<li><code>notify()</code>所做的事情就是调用<code>NSNotificationCenter</code>的<code>postNotification:</code>进行发送通知</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void notify(NSNotificationCenter *center, </span><br><span class="line">                   NSNotificationQueueList *list,</span><br><span class="line">                   NSString *mode, NSZone *zone)</span><br><span class="line">&#123;</span><br><span class="line">     ......</span><br><span class="line">    // 循环遍历发送通知</span><br><span class="line">    for (pos = 0; pos &lt; len; pos++)</span><br><span class="line">    &#123;</span><br><span class="line">      NSNotification    *n = (NSNotification*)ptr[pos];</span><br><span class="line"></span><br><span class="line">      [center postNotification: n];</span><br><span class="line">      RELEASE(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br><span class="line">// 发送_asapQueue中的通知</span><br><span class="line">void GSPrivateNotifyASAP(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_asapQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line">// 发送_idleQueue中的通知</span><br><span class="line">void GSPrivateNotifyIdle(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">    notify(item-&gt;queue-&gt;_center,</span><br><span class="line">        item-&gt;queue-&gt;_idleQueue,</span><br><span class="line">        mode,</span><br><span class="line">        item-&gt;queue-&gt;_zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>对于<code>NSNotificationQueue</code>总结如下</p>
<ol>
<li>依赖<code>runloop</code>，所以如果在其他子线程使用<code>NSNotificationQueue</code>，需要开启runloop</li>
<li>最终还是通过<code>NSNotificationCenter</code>进行发送通知，所以这个角度讲它还是同步的</li>
<li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程</li>
</ol>
<h1 id="主线程响应通知"><a href="#主线程响应通知" class="headerlink" title="主线程响应通知"></a>主线程响应通知</h1><p>异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？</p>
<p>其实也是比较常见的问题了，基本上解决方式如下几种：</p>
<ol>
<li>使用<code>addObserverForName: object: queue: usingBlock</code>方法注册通知，指定在<code>mainqueue</code>上响应<code>block</code></li>
<li>在主线程注册一个<code>machPort</code>，它是用来做线程通信的，当在异步线程收到通知，然后给<code>machPort</code>发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文写的内容比较多，以<a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base">GNUStep</a>源码为基础进行研究，全面阐述了通知的存储、发送、异步发送等原理，对研究学习有很大帮助</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:26:19.000Z" title="2024/3/2 22:26:19">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">12 分钟读完 (大约1866个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/1e8a5be3/">大厂常问iOS面试题--Runloop&amp;KVO篇</a></p><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天这一篇我们来讲一下 Runloop和KVO</p>
<p>本章的主要回答的问题如下:</p>
<h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><ul>
<li>app如何接收到触摸事件的</li>
<li>为什么只有主线程的runloop是开启的</li>
<li>为什么只在主线程刷新UI</li>
<li>PerformSelector和runloop的关系</li>
<li>如何使线程保活</li>
</ul>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><ul>
<li>实现原理</li>
<li>如何手动关闭kvo</li>
<li>通过KVC修改属性会触发KVO么</li>
<li>哪些情况下使用kvo会崩溃，怎么防护崩溃</li>
<li>kvo的优缺点</li>
</ul>
<h2 id="Runloop-1"><a href="#Runloop-1" class="headerlink" title="Runloop"></a>Runloop</h2><p>作为一个合格的iOS开发者必须对runloop有一个更深入的了解,下面我们来回答一下 相关问题</p>
<h3 id="1-app如何接收到触摸事件的"><a href="#1-app如何接收到触摸事件的" class="headerlink" title="1.app如何接收到触摸事件的"></a>1.app如何接收到触摸事件的</h3><p>回答这个问题前请认真阅读一下 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a></p>
<p><img src="/images/Runloop&KVO.jpg"></p>
<p>通过上图可以看出整个流程就是 我们app启动默认会通过machPort监听端口的方式 来接受IOHIDEvent 来接收和处理触摸事件.</p>
<h3 id="2-为什么只有主线程的runloop是开启的"><a href="#2-为什么只有主线程的runloop是开启的" class="headerlink" title="2.为什么只有主线程的runloop是开启的"></a>2.为什么只有主线程的runloop是开启的</h3><p>mian()函数中调用UIApplicationMain，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行并接收事件，所以在主线程中开启一个runloop，让主线程常驻.</p>
<h3 id="3-为什么只在主线程刷新UI"><a href="#3-为什么只在主线程刷新UI" class="headerlink" title="3.为什么只在主线程刷新UI"></a>3.为什么只在主线程刷新UI</h3><p>我们所有用到的UI都是来自于UIKit这个基础库.因为objc不是一门线程安全的语言所以存在多线程读写不同步的问题,如果使用加锁的方式操作系统开销很大,会耗费大量的系统资源(内存、时间片轮转、cpu处理速度…)，加上上面讲到的系统事件的接收处理都在主线程,如果UI异步线程的话 还会存在 同步处理事件的问题,所以多点触摸手势等一些事件要保持和UI在同一个线程相对是最优解.</p>
<p>另一方面是 屏幕的渲染是 60帧(60Hz&#x2F;秒), 也就是1秒钟回调60次的频率,(iPad Pro 是120Hz&#x2F;秒),我们的runloop 理想状态下也会按照时钟周期 回调60次(iPad Pro 120次), 这么高频率的调用是为了 屏幕图像显示能够垂直同步 不卡顿.在异步线程的话是很难保证这个处理过程的同步更新. 即便能保证的话 相对主线程而言 系统资源开销 线程调度等等将会占据大部分资源和在同一个线程只专门干一件事有点得不偿失.</p>
<h3 id="4-PerformSelector和runloop的关系"><a href="#4-PerformSelector和runloop的关系" class="headerlink" title="4.PerformSelector和runloop的关系"></a>4.PerformSelector和runloop的关系</h3><p>当调用NSObect的 performSelector:相关的时候,内部会创建一个timer定时器添加到当前线程的runloop中,如果当前线程没有启动runloop,则该方法不会被调用.</p>
<p>开发中遇到最多的问题就是这个performSelector: 导致对象的延迟释放,这里开发过程中注意一下,可以用单次的NSTimer替代.</p>
<p>详细可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903781755256840">Runloop与performSelector</a></p>
<h3 id="5-如何使线程保活？"><a href="#5-如何使线程保活？" class="headerlink" title="5.如何使线程保活？"></a>5.如何使线程保活？</h3><p>想要线程保活的话就开启该线程的runloop即可,注意:在NSThread执行的方法中添加while(true){}，这样是模拟runloop的运行原理，结合GCD的信号量，在{}代码块中处理任务.</p>
<p>但是注意 开启runloop的方法要正确</p>
<p>如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//测试开启线程</span><br><span class="line">- (void)memoryTest &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">        [thread start];</span><br><span class="line">        [self performSelector:@selector(stopThread) onThread:thread withObject:nil waitUntilDone:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//线程停止</span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSThread *thread = [NSThread currentThread];</span><br><span class="line">    [thread cancel];</span><br><span class="line">&#125;</span><br><span class="line">//运行线程的runloop 注意 意添加的那个空port,否则会出现内存泄露</span><br><span class="line">- (void)run &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        if (!self.emptyPort) &#123;</span><br><span class="line">            self.emptyPort = [NSMachPort port];</span><br><span class="line">        &#125;</span><br><span class="line">        [runLoop addPort:self.emptyPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下列代码用于模拟线程内部做的一些耗时任务</span><br><span class="line">- (void)printSomething &#123;</span><br><span class="line">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    [self performSelector:@selector(printSomething) withObject:nil afterDelay:1];</span><br><span class="line">&#125;</span><br><span class="line">//模拟手动点击按钮 让 runloop停掉</span><br><span class="line">- (void)stopButtonDidClicked:(id)sender &#123;</span><br><span class="line">    [self performSelector:@selector(stopRunloop) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopRunloop &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细请参考:<a target="_blank" rel="noopener" href="https://allluckly.cn/%E6%8A%95%E7%A8%BF/tuogao55">iOS开发深入研究Runloop与线程保活</a></p>
<h2 id="KVO-1"><a href="#KVO-1" class="headerlink" title="KVO"></a>KVO</h2><p>在开发过程中我们经常使用KVO,下面解答一下KVO相关的问题.</p>
<h3 id="KVO的实现原理"><a href="#KVO的实现原理" class="headerlink" title="KVO的实现原理"></a>KVO的实现原理</h3><p>通过<code>runtime</code>派生子类的方式 复写相关需要KVO监听的属性,在该属性setter之前和之后调用NSObject的监听方法,这样KVO就实现了属性变换前后的回调.</p>
<p>KVO派生的子类具体格式应该是:<code>NSKVONotifying_+类名</code>的类 eg: NSKVONotifying_Person</p>
<p>下面示例代码为Person类的name添加KVO的模拟实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    _NSSetObjectValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetObjectValueAndNotify &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [super setName:name];</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">    [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了如何动态创建类呢?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//动态创建XXCustomClass</span><br><span class="line">Class customClass = objc_allocateClassPair([NSObject class], &quot;XXCustomClass&quot;, 0);</span><br><span class="line">// 添加实例变量</span><br><span class="line">class_addIvar(customClass, &quot;age&quot;, sizeof(int), 0, &quot;i&quot;);</span><br><span class="line">// 动态添加方法</span><br><span class="line">class_addMethod(customClass, @selector(hahahha), (IMP)hahahha, &quot;V@:&quot;);</span><br><span class="line"></span><br><span class="line">//需要实现的方法</span><br><span class="line">void hahahha(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;hahahha====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hahahha&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最后注册到运行时环境</span><br><span class="line">objc_registerClassPair(customClass);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">V@:表示方法的参数和返回值</a></p>
</blockquote>
<p>具体原理以及自定义实现KVO可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1136759">KVO详解及底层实现</a></p>
<h3 id="如何手动关闭KVO"><a href="#如何手动关闭KVO" class="headerlink" title="如何手动关闭KVO?"></a>如何手动关闭KVO?</h3><p>被观察的对象复写如下方法 返回<code>NO</code>即可关闭KVO</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关闭后还想触发 KVO的话 修改需要手动调用在变量setter的前后 主动调用 <code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
<h3 id="通过KVC修改属性会触发KVO么"><a href="#通过KVC修改属性会触发KVO么" class="headerlink" title="通过KVC修改属性会触发KVO么?"></a>通过KVC修改属性会触发KVO么?</h3><p>会的</p>
<h3 id="哪些情况下使用kvo会崩溃，怎么防护崩溃？"><a href="#哪些情况下使用kvo会崩溃，怎么防护崩溃？" class="headerlink" title="哪些情况下使用kvo会崩溃，怎么防护崩溃？"></a>哪些情况下使用kvo会崩溃，怎么防护崩溃？</h3><p>使用不当 会crash,比如:</p>
<ul>
<li>添加和移出不是成对出现且存在多线程添加KVO的情况,经常遇到的crash是移出 - 内存dealloc的时候 或者对象销毁前没有正确移出Observer</li>
</ul>
<p>如何防护？</p>
<p>1.注意移出对象 匹配 2.内存野指针问题,一定要在对象销毁前移出观察者 3.可以使用第三方库BlockKit添加KVO,blockkit内部会自动移除Observer避免crash.</p>
<h3 id="KVO的优缺点"><a href="#KVO的优缺点" class="headerlink" title="KVO的优缺点"></a>KVO的优缺点</h3><p>优点:</p>
<ul>
<li>方便两个对象间同步状态(keypath)更加方便,一般都是在A类要观察B类的属性的变化.</li>
<li>非侵入式的得到某内部对象的状态改变并作出响应.(就是在不改变原来对象类的代码情况下即可做出对该对象的状态变化进行监听)</li>
<li>可以嵌入更改前后的两个时机的状态. - 可以通过Keypaths对嵌套对象的监听.</li>
</ul>
<p>缺点:</p>
<ul>
<li>需要手动移除观察者,不移除容易造成crash.</li>
<li>注册和移出成对匹配出现.</li>
<li>keypath参数的类型String, 如果对象的成员变量被重构而变化字符串不会被编译器识别而报错.</li>
<li>实现观察的方式是复写NSObjec的相关KVO的方法,应该更加面向protocol的方式会更好.</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇我们讲了 runloop和KVO相关的内容,这里面最负责的当属runloop如何处理触摸手势事件.建议认真研读相关链接文章.这样才有一个对runloop更深刻的理解。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-02T14:08:39.000Z" title="2024/3/2 22:08:39">2024-03-02</time>发表</span><span class="level-item"><time dateTime="2025-07-04T12:04:56.930Z" title="2025/7/4 20:04:56">2025-07-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/">iOS开发</a><span> / </span><a class="link-muted" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span><span class="level-item">11 分钟读完 (大约1667个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/2bf627ae/">大厂常问iOS面试题--NSNotification篇</a></p><div class="content"><h3 id="主要内容包含如下"><a href="#主要内容包含如下" class="headerlink" title="主要内容包含如下:"></a>主要内容包含如下:</h3><ul>
<li>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li>NSNotificationQueue是异步还是同步发送？在哪个线程响应</li>
<li>NSNotificationQueue和runloop的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>在解释这些内容之前 强烈建议认真研读一下这篇 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5952c0a3fc62">一文全解iOS通知机制(经典收藏)</a>文章 了解一下大概 所有的问题就迎刃而解了.</p>
<h2 id="实现原理（结构设计、通知如何存储的、name-observer-SEL之间的关系等"><a href="#实现原理（结构设计、通知如何存储的、name-observer-SEL之间的关系等" class="headerlink" title="实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等"></a>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等</h2><p>首先通知中心结构大概分为如下几个类</p>
<ul>
<li><code>NSNotification</code> 通知的模型 name、object、userinfo.</li>
<li><code>NSNotificationCenter</code>通知中心 负责发送<code>NSNotification</code></li>
<li><code>NSNotificationQueue</code>通知队列 负责在某些时机触发 调用<code>NSNotificationCenter</code>通知中心 <code>post</code>通知</li>
</ul>
<p>通知是结构体通过双向链表进行数据存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation        *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable        nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable        named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct    Obs &#123;</span><br><span class="line">  id        observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL        selector;    /* 响应方法        */</span><br><span class="line">  struct Obs    *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>

<p>主要是以<code>key</code> <code>value</code>的形式存储,这里需要重点强调一下 通知以 <code>name</code>和<code>object</code>两个纬度来存储相关通知内容,也就是我们添加通知的时候传入的两个不同的方法. </p>
<p><img src="/images/NSNotification1.jpg"></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>简单理解<code>name</code>&amp;<code>observer</code>&amp;<code>SEL</code>之间的关系就是<code>name</code>作为<code>key</code>, <code>observer</code>作为观察者对象,当合适时机触发就会调用<code>observer</code>的<code>SEL</code>.这基本很简单,如果觉得我说的不准确可以看下文章开头的文章.</p>
<h2 id="通知的发送时同步的，还是异步的"><a href="#通知的发送时同步的，还是异步的" class="headerlink" title="通知的发送时同步的，还是异步的"></a>通知的发送时同步的，还是异步的</h2><p>同步发送.因为要调用消息转发.所谓异步，指的是<strong>非实时发送</strong>而是<strong>在合适的时机发送</strong>，并没有开启异步线程.</p>
<h2 id="NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息"><a href="#NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息" class="headerlink" title="NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息"></a>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2><p>是的, 异步线程发送通知则响应函数也是在异步线程.</p>
<p>异步发送通知可以开启异步线程发送即可.</p>
<h2 id="NSNotificationQueue是异步还是同步发送？在哪个线程响应"><a href="#NSNotificationQueue是异步还是同步发送？在哪个线程响应" class="headerlink" title="NSNotificationQueue是异步还是同步发送？在哪个线程响应"></a>NSNotificationQueue是异步还是同步发送？在哪个线程响应</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>NSPostWhenIdle</th>
<th>NSPostASAP</th>
<th>NSPostNow</th>
</tr>
</thead>
<tbody><tr>
<td>NSPostingStyle</td>
<td>异步发送</td>
<td>异步发送</td>
<td>同步发送</td>
</tr>
</tbody></table>
<p><code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为<strong>延时发送</strong>，它是利用了<code>runloop</code>的时机来触发的.</p>
<p>异步线程发送通知则响应函数也是在异步线程,主线程发送则在主线程.</p>
<h2 id="NSNotificationQueue和runloop的关系"><a href="#NSNotificationQueue和runloop的关系" class="headerlink" title="NSNotificationQueue和runloop的关系"></a>NSNotificationQueue和runloop的关系</h2><p><code>NSNotificationQueue</code>依赖<code>runloop</code>. 因为通知队列要在runloop回调的某个时机调用通知中心发送通知.从下面的枚举值就能看出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="如何保证通知接收的线程在主线程"><a href="#如何保证通知接收的线程在主线程" class="headerlink" title="如何保证通知接收的线程在主线程"></a>如何保证通知接收的线程在主线程</h2><p>如果想在主线程响应异步通知的话可以用如下两种方式</p>
<p>1.系统接受通知的API指定队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block</span><br></pre></td></tr></table></figure>

<p>2.<code>NSMachPort</code>的方式 通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可</p>
<h2 id="页面销毁时不移除通知会崩溃吗"><a href="#页面销毁时不移除通知会崩溃吗" class="headerlink" title="页面销毁时不移除通知会崩溃吗?"></a>页面销毁时不移除通知会崩溃吗?</h2><p>iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针.</p>
<p>iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。</p>
<h2 id="多次添加同一个通知会是什么结果？多次移除通知呢"><a href="#多次添加同一个通知会是什么结果？多次移除通知呢" class="headerlink" title="多次添加同一个通知会是什么结果？多次移除通知呢"></a>多次添加同一个通知会是什么结果？多次移除通知呢</h2><p>多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。</p>
<h2 id="下面的方式能接收到通知吗？为什么"><a href="#下面的方式能接收到通知吗？为什么" class="headerlink" title="下面的方式能接收到通知吗？为什么"></a>下面的方式能接收到通知吗？为什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];</span><br></pre></td></tr></table></figure>

<p>不能</p>
<p>首先我们看下通知中心存储通知观察者的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation  *wildcard;    /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable nameless;    /* 存储没有name但是有object的通知    */</span><br><span class="line">  GSIMapTable named;        /* 存储带有name的通知，不管有没有object    */</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef    struct Obs &#123;</span><br><span class="line">  id observer;    /* 观察者，接收通知的对象    */</span><br><span class="line">  SEL selector;    /* 响应方法        */</span><br><span class="line">  struct Obs *next;        /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>

<p><code>nameless</code>与<code>named</code>的具体数据结构如下: </p>
<p><img src="/images/NSNotification1.jpg"></p>
<p><img src="/images/NSNotification2.jpg"></p>
<p>当添加通知监听的时候，我们传入了<code>name</code>和<code>object</code>，所以，观察者的存储链表是这样的：</p>
<p><code>named</code>表：<code>key(name)</code> : <code>value</code>-&gt;<code>key(object)</code> : <code>value(Observation)</code></p>
<p>因此在发送通知的时候，如果只传入<code>name</code>而并没有传入<code>object</code>，是找不到<code>Observation</code>的，也就不能执行观察者回调.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天又重新认识了iOS中的通知中心,希望大家经常温故而知新.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/logoNew.svg" alt="置身于正，勇于攀登"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">置身于正，勇于攀登</p><p class="is-size-6 is-block">大丈夫生于天地间 岂能郁郁久居人下</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">118</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/despacito2"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/WTF_C69"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://qm.qq.com/cgi-bin/qm/qr?k=rTH0EcmelH7hsRL9MkYD1Xw8m7RT4NNV&amp;jump_from=webapi&amp;authKey=B+kszDp7XNLzePIu1HeGOokQtbHdJW79aOFDatCgh/dWveDNDOJ+KHAbSdrvelkR" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS审核上架交流群</span></span><span class="level-right"><span class="level-item tag">qm.qq.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">iOS开发</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="level-start"><span class="level-item">面试题</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/sing-box/"><span class="level-start"><span class="level-item">sing-box</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">配置详解</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/"><span class="level-start"><span class="level-item">好文收录</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/"><span class="level-start"><span class="level-item">缠论原文</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/07/"><span class="level-start"><span class="level-item">七月 2025</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4191566366727150" data-ad-slot="4095483014" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-07T03:30:00.000Z">2025-07-07</time></p><p class="title"><a href="/posts/dns-ip-strategy/">sing-box DNS IP选择策略与负载均衡实战指南：加速解析与智能路由配置</a></p><p class="categories"><a href="/categories/sing-box/">sing-box</a> / <a href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">配置详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-07T03:00:00.000Z">2025-07-07</time></p><p class="title"><a href="/posts/dns-cache-reverse/">sing-box DNS 缓存与反向解析实战指南：原理、配置与性能优化</a></p><p class="categories"><a href="/categories/sing-box/">sing-box</a> / <a href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">配置详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-07T02:30:00.000Z">2025-07-07</time></p><p class="title"><a href="/posts/domain-routing/">sing-box 域名分类与分流策略实战：多 DNS 配置与规则使用详解</a></p><p class="categories"><a href="/categories/sing-box/">sing-box</a> / <a href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">配置详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-07T02:00:00.000Z">2025-07-07</time></p><p class="title"><a href="/posts/dns-protocols/">sing-box DNS 协议全解析：DoH、DoT、DoQ、DNSCrypt 等协议详解</a></p><p class="categories"><a href="/categories/sing-box/">sing-box</a> / <a href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">配置详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-07T01:00:00.000Z">2025-07-07</time></p><p class="title"><a href="/posts/57dee22/">sing-box DNS 功能详解与最佳实践</a></p><p class="categories"><a href="/categories/sing-box/">sing-box</a> / <a href="/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">配置详解</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.png" alt="人间正道" height="28"></a><p class="is-size-7"><span>&copy; 2025 人间正道</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/despacito2"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>