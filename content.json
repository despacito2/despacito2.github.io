{"posts":[{"title":"sing-box DNS IP选择策略与负载均衡实战指南：加速解析与智能路由配置","text":"在网络代理和访问控制中，DNS 的 IP 选择策略（IP Strategy） 是决定访问速度、稳定性和兼容性的关键参数。通过合理配置，可以有效应对多 IP 域名解析、CDN 分流、IPv6 环境不稳定等问题。 📘 目录 1. 什么是 IP 选择策略？ 2. sing-box 中的配置方法 3. 可选策略类型详解 4. 应用场景与推荐策略 5. 多节点负载均衡联动 6. 小结与优化建议 1. 什么是 IP 选择策略？当一个域名解析出多个 IP（如使用了 CDN 或多地区服务器），DNS 会将多个 IP 一并返回，此时客户端需要决定使用哪一个 IP 建立连接。 IP 策略即用于控制这种选择逻辑。 2. sing-box 中的配置方法123&quot;dns&quot;: { &quot;strategy&quot;: &quot;prefer_ipv4&quot;} strategy 参数用于控制 IPv4 与 IPv6 的使用优先级或排除。 3. 可选策略类型详解 策略名称 描述 使用建议 prefer_ipv4 默认，优先使用 IPv4 ✅ 通用，兼容性最强 prefer_ipv6 优先使用 IPv6 ✅ IPv6 网络优质时推荐 ipv4_only 仅使用 IPv4，忽略 IPv6 ✅ 无 IPv6 支持或需避免污染时使用 ipv6_only 仅使用 IPv6，忽略 IPv4 ⚠️ 限制多，需环境全面支持 IPv6 auto 根据系统配置决定优先级 ⚠️ 不够明确，建议手动指定策略 4. 应用场景与推荐策略✅ 推荐表 地区或用途 推荐策略 原因说明 🇨🇳 中国大陆 prefer_ipv4 国内 IPv6 路由复杂，污染可能性大 🇺🇸 美国 / 🇩🇪 欧洲 prefer_ipv6 IPv6 支持广泛，通常更快 🇯🇵 日本 / 🇸🇬 新加坡 prefer_ipv4 虽支持 IPv6，但 CDN 路由优化更偏 IPv4 科学上网 prefer_ipv6 避开某些 IPv4 干扰，隐匿性好 CDN 多线路 prefer_ipv4 or ipv4_only 有助于避免出口不稳定问题 无 IPv6 设备或兼容性问题 ipv4_only 保证连接可靠性 💡 可访问 https://test-ipv6.com/ 检查你是否支持完整 IPv6。 5. 多节点负载均衡联动除了 DNS 层 IP 策略，sing-box 还支持多出口节点的负载均衡： 12345678910111213141516171819&quot;outbounds&quot;: [ { &quot;type&quot;: &quot;selector&quot;, &quot;tag&quot;: &quot;proxy&quot;, &quot;outbounds&quot;: [&quot;hk&quot;, &quot;jp&quot;, &quot;sg&quot;], &quot;default&quot;: &quot;hk&quot;, &quot;health_check&quot;: { &quot;enable&quot;: true, &quot;url&quot;: &quot;https://www.gstatic.com/generate_204&quot;, &quot;interval&quot;: &quot;30s&quot; } }, { &quot;type&quot;: &quot;vmess&quot;, &quot;tag&quot;: &quot;hk&quot;, ... }, ...] 搭配 prefer_ipv6 策略使用，可实现： 国内域名走 IPv4 国外优选 IPv6 通道 多 IP 优选稳定节点连接 6. 小结与优化建议 场景 推荐策略组合 日常国内访问 prefer_ipv4 + 缓存 TTL 科学上网 prefer_ipv6 + fallback 节点 企业办公 ipv4_only + 固定 DNS + selector 异常/污染网络 使用 ipv6_only + DoH DNS ✅ 总结DNS 的 IP 策略配置虽简单，却对整体连接性能、安全性和稳定性影响巨大。推荐默认使用 prefer_ipv4，在已验证环境中逐步启用 prefer_ipv6。 若你配合前文的 DNS 缓存、规则分流、DoH/DoT 使用，整体网络访问体验将有质的提升。 如需完整示例配置文件或集成出口选择、缓存、DNS 分流等功能，请继续告诉我，我可以为你生成专属 sing-box 高级配置模板。","link":"/posts/dns-ip-strategy/"},{"title":"sing-box DNS 功能详解与最佳实践","text":"sing-box 的 dns 模块不仅实现了基本的域名解析功能，还支持诸多进阶特性，广泛适用于分流、隐私保护、广告拦截、性能优化等场景。 🧠 一、基本功能1. DNS 查询解析 支持多种协议： UDP TCP DoH（DNS over HTTPS） DoT（DNS over TLS） DoQ（DNS over QUIC） 可配置多个 DNS 服务器，支持优先级、备用等机制。 2. 自定义域名解析（hosts）可替代系统的 hosts 文件，配置方式如下： 12345{ &quot;hosts&quot;: { &quot;example.com&quot;: &quot;1.2.3.4&quot; }} 🧰 二、增强功能3. 域名分类与分流（规则匹配）可通过 rules 使用不同 DNS 服务器，例如： 123456789101112{ &quot;rules&quot;: [ { &quot;domain&quot;: &quot;geosite:cn&quot;, &quot;server&quot;: &quot;dns_local&quot; }, { &quot;domain&quot;: &quot;geosite:category-ads-all&quot;, &quot;server&quot;: &quot;dns_block&quot; } ]} 4. 域名缓存配置123456&quot;cache&quot;: { &quot;enabled&quot;: true, &quot;size&quot;: 4096, &quot;min_ttl&quot;: 60, &quot;max_ttl&quot;: 86400} 5. 负载均衡（IP 选择策略） 可按 round-robin 等方式选择多个解析结果。 支持 fallback 自动切换。 6. DNS fallback主 DNS 不可用时自动使用备用 DNS。 🧱 三、进阶功能7. DNS 劫持（Hijack）12345678{ &quot;hijack&quot;: [ { &quot;domain&quot;: &quot;example.com&quot;, &quot;ip&quot;: &quot;127.0.0.1&quot; } ]} 8. 广告域名拦截结合规则 geosite:category-ads-all 可实现广告拦截。 9. 过滤污染/无效解析 过滤非 A/AAAA 类型的记录； 屏蔽伪造 IP 返回（如被污染的解析）。 🌐 四、隐私与安全相关10. 支持加密 DNS 协议 ✅ DoH ✅ DoT ✅ DoQ 11. 防泄漏能力 可关闭系统 DNS； 配合 TUN 模式劫持所有 DNS 请求； 本地 DNS 与远程 DNS 联合使用，提升安全性。 🧭 五、与 TUN 分流协同使用 DNS 是 TUN 分流的核心依据； 搭配 sniffing 功能，根据解析出的域名进行策略分流； DNS 结果直接影响实际走哪个节点。 ✅ 功能速查表 功能项 支持情况 UDP/TCP DNS ✅ DoH / DoT / DoQ 支持 ✅ 自定义 hosts ✅ DNS 分流（geosite等规则） ✅ 广告域名拦截 ✅ 缓存 TTL 控制 ✅ fallback 多 DNS 支持 ✅ hijack 劫持域名解析 ✅ DNS 查询隐私保护 ✅ 系统 DNS 禁用 ✅ sniffing 联动 ✅ 如需示例配置文件或完整模板，欢迎留言获取。","link":"/posts/57dee22/"},{"title":"sing-box DNS 协议全解析：DoH、DoT、DoQ、DNSCrypt 等协议详解","text":"DNS（Domain Name System，域名系统）是互联网中最核心的基础设施之一，用于将域名解析为 IP 地址。随着网络安全和隐私需求的提升，DNS 协议也发展出了多种类型。 📌 目录 1. 传统 DNS 协议 2. 加密 DNS 协议（安全增强） 3. 进阶 DNS 协议 4. 本地 DNS 协议 5. DNS 协议对比总结 1. 传统 DNS 协议1.1 DNS over UDP（端口 53） 基于 UDP，速度快、延迟低。 缺点：不加密，易被劫持（如 DNS 污染）。 1.2 DNS over TCP（端口 53） 用于响应较大或传输可靠性要求高的场景。 缺点：效率较低。 2. 加密 DNS 协议（安全增强）2.1 DoT（DNS over TLS，端口 853） 使用 TLS 加密 DNS 请求。 优点：防篡改、防监听。 缺点：握手时间稍长。 2.2 DoH（DNS over HTTPS，端口 443） 通过 HTTPS 封装 DNS。 优点：隐私好、穿透力强、浏览器支持广泛。 缺点：实现复杂、资源占用多。 2.3 DNSCrypt（常用端口 443/5353） 使用签名技术加密 DNS。 优点：轻量、安全。 缺点：兼容性弱，非标准。 3. 进阶 DNS 协议3.1 DoQ（DNS over QUIC，端口 8853） 基于 QUIC（HTTP/3）开发的 DNS 协议。 优点：连接快、低延迟，适合移动设备。 缺点：支持度较低，仍在推广中。 3.2 DoH/3（基于 HTTP/3 的 DoH） 新一代基于 QUIC 的加密 DNS。 优点：结合 DoH 优点与更快速的 QUIC。 缺点：尚处于发展初期。 4. 本地 DNS 协议4.1 mDNS（Multicast DNS，端口 5353） 用于局域网设备名称解析（如 AirPlay）。 优点：无需中央服务器。 缺点：仅限本地网络使用。 4.2 LLMNR（Link-Local Multicast Name Resolution） Windows 下的局域网名称解析协议。 现状：逐步被 mDNS 替代。 5. DNS 协议对比总结 协议 是否加密 默认端口 特点说明 DNS/UDP ❌ 53 快速，但不安全 DNS/TCP ❌ 53 用于大包或容错 DoT ✅ 853 安全性强，主流设备支持 DoH ✅ 443 隐蔽性好，浏览器原生支持 DNSCrypt ✅ 443/5353 安全轻量，兼容性有限 DoQ ✅ 8853 快速新协议，适合移动网络 DoH/3 ✅ 443 最先进协议，速度隐私兼顾 mDNS ❌ 5353 局域网广播，适用于本地发现 LLMNR ❌ 动态分配 Windows 局域网解析，逐渐淘汰 📘 结语随着隐私意识的提高，推荐尽可能使用加密 DNS（如 DoH 或 DoT）。在搭建现代 VPN、代理、广告过滤器、或者企业网络时，合理选择 DNS 协议，不仅影响速度，更关乎数据安全。 如需使用这些协议配置在 sing-box 或类似工具中，可以继续向我咨询配置方法。","link":"/posts/dns-protocols/"},{"title":"sing-box DNS 缓存与反向解析实战指南：原理、配置与性能优化","text":"DNS 缓存与反向解析（Reverse Mapping）是提升代理工具 DNS 能力的关键手段，不仅能加速访问、减轻上游压力，还能提升日志可读性和规则匹配效率。本文将带你全面理解并掌握其配置方式。 📘 目录 1. 什么是 DNS 缓存 2. 缓存配置参数详解 3. 缓存配置示例 4. 什么是反向解析 5. 反向解析配置说明 6. 实战建议与注意事项 1. 什么是 DNS 缓存DNS 缓存是指将 DNS 解析结果保存在本地一段时间，避免对同一域名重复请求，提高解析速度并减少对上游 DNS 的依赖。 作用包括： 提升解析速度，降低延迟 避免频繁 DNS 查询，节省资源 提高离线访问成功率（对 TTL 合理设置） 2. 缓存配置参数详解（sing-box）12345678&quot;dns&quot;: { &quot;cache&quot;: { &quot;enabled&quot;: true, // 是否开启缓存 &quot;size&quot;: 4096, // 最大缓存条目数量 &quot;ttl&quot;: 86400, // 统一缓存时间（秒） &quot;respect_ttl&quot;: true // 是否遵循上游 TTL }} 参数 类型 说明 enabled Boolean 开启或关闭缓存 size Int 设置缓存最多保存多少条解析记录 ttl Int 固定缓存时间（秒），如设置为 86400 即 1 天 respect_ttl Boolean 是否使用上游 DNS 返回的 TTL 3. 缓存配置示例🧪 示例 1：标准缓存设置（推荐）123456&quot;cache&quot;: { &quot;enabled&quot;: true, &quot;size&quot;: 8192, &quot;ttl&quot;: 0, &quot;respect_ttl&quot;: true} ✅ 使用上游 TTL，兼顾准确性与性能。 🧪 示例 2：强缓存策略（速度优先）123456&quot;cache&quot;: { &quot;enabled&quot;: true, &quot;size&quot;: 4096, &quot;ttl&quot;: 86400, &quot;respect_ttl&quot;: false} ⚠️ 所有域名解析结果缓存 24 小时，适合访问域名 IP 比较稳定的用户。 4. 什么是反向解析反向解析（Reverse Mapping）是将 IP 地址反查为域名（PTR 记录），如： IP 142.250.72.68 → 反查 → lax17s34-in-f4.1e100.net 5. 反向解析配置说明（sing-box）123&quot;dns&quot;: { &quot;reverse_mapping&quot;: true} ✅ 应用场景： 场景 说明 日志可读性 在连接日志中显示域名而非 IP 辅助规则匹配 某些规则可以基于反查结果进行更精细的判断 可观测性提升 更方便定位某些 IP 对应的服务来源 ⚠️ 注意事项： 反向解析请求依赖 PTR 记录，不是所有 IP 都支持 会带来额外的 DNS 请求，首次连接可能略有延迟 一般不建议在低性能设备上开启 6. 实战建议与注意事项 场景 建议配置 普通科学上网用户 缓存开启，TTL 使用上游（ttl: 0, respect_ttl: true），关闭反向解析 企业/高并发代理 缓存条目设置高（如 8192+），可开启反向解析便于审计 不稳定节点用户 缓存时间不宜太长，避免 IP 变化失效 日志监控需求高 可开启 reverse_mapping，提升日志可读性 🧾 总结DNS 缓存与反向解析是构建高性能、可观测代理系统的重要组成部分。合理配置可带来显著的解析提速、访问优化与日志清晰度提升，尤其适用于多出口、多 DNS、多规则场景。 若你正在使用 sing-box，可以配合前文中的 DNS 多规则与分流配置，一起构建完整的 DNS 控制系统。 是否需要我提供一份完整的 sing-box 配置文件模板？欢迎继续提问。","link":"/posts/dns-cache-reverse/"},{"title":"sing-box 域名分类与分流策略实战：多 DNS 配置与规则使用详解","text":"在现代网络代理工具（如 sing-box、Clash）中，实现高效、安全的访问控制，域名的分类与分流策略是核心技术之一。通过规则划分不同类型的域名，并指定使用的 DNS 或代理出口，可以实现广告拦截、隐私保护、速度优化等目标。 📘 目录 1. 域名分类概述 2. 分流策略简介 3. 多 DNS 配置与规则使用 4. sing-box 分流配置示例 5. 应用总结与实战建议 1. 域名分类概述常见的域名分类方式如下： 分类方式 说明 示例 功能分类 按网站用途分类，如视频、社交、办公等 youtube.com, office365.com 地域分类 根据域名归属地划分，用于国内国际识别 geosite:cn, geolocation-!cn 风险分类 恶意、广告、色情、钓鱼等黑名单域名 category-ads-all, category-malware 自定义分类 用户自建域名分组 custom-academic, lan-domain 2. 分流策略简介根据分类结果，对不同域名进行差异化处理： 策略 描述 示例配置 国内直连 中国域名走直连 geosite:cn -&gt; direct 国外代理 非中国域名走代理 geosite:geolocation-!cn -&gt; proxy 视频专线 视频类网站使用特定节点 youtube.com -&gt; us-node 拦截广告 广告类域名统一阻断 category-ads-all -&gt; block 自定义出口 某些特殊域名走指定代理或 DNS academic-site -&gt; hk-dns 3. 多 DNS 配置与规则使用在 sing-box 中，可以为不同域名指定不同的 DNS 上游服务器： 123456789101112131415161718192021222324252627282930313233343536{ &quot;dns&quot;: { &quot;servers&quot;: [ { &quot;tag&quot;: &quot;dns_local&quot;, &quot;address&quot;: &quot;223.5.5.5&quot;, &quot;detour&quot;: &quot;direct&quot; }, { &quot;tag&quot;: &quot;dns_doh_google&quot;, &quot;address&quot;: &quot;https://dns.google/dns-query&quot;, &quot;detour&quot;: &quot;proxy&quot; }, { &quot;tag&quot;: &quot;dns_doh_cf&quot;, &quot;address&quot;: &quot;https://1.1.1.1/dns-query&quot;, &quot;detour&quot;: &quot;proxy&quot; } ], &quot;rules&quot;: [ { &quot;domain_suffix&quot;: [&quot;baidu.com&quot;, &quot;bilibili.com&quot;], &quot;server&quot;: &quot;dns_local&quot; }, { &quot;domain_category&quot;: &quot;geolocation-!cn&quot;, &quot;server&quot;: &quot;dns_doh_google&quot; }, { &quot;domain_category&quot;: &quot;category-ads-all&quot;, &quot;server&quot;: &quot;dns_doh_cf&quot; } ], &quot;strategy&quot;: &quot;prefer_ipv4&quot; }} ✅ 提示：DNS 的 detour 可以配合实际节点策略，如 proxy 表示使用代理转发 DNS 查询请求。 4. sing-box 分流配置示例12345678910111213141516171819202122{ &quot;route&quot;: { &quot;rules&quot;: [ { &quot;domain_category&quot;: &quot;category-ads-all&quot;, &quot;outbound&quot;: &quot;block&quot; }, { &quot;domain_category&quot;: &quot;cn&quot;, &quot;outbound&quot;: &quot;direct&quot; }, { &quot;domain_category&quot;: &quot;geolocation-!cn&quot;, &quot;outbound&quot;: &quot;proxy&quot; }, { &quot;domain_suffix&quot;: [&quot;youtube.com&quot;, &quot;netflix.com&quot;], &quot;outbound&quot;: &quot;us&quot; } ] }} 搭配 DNS 规则后，将实现“按域名类型定向 DNS + 按域名分流出口”的双重控制。 5. 应用总结与实战建议 场景 建议策略 科学上网 非国内域名使用 DoH，并走代理 广告拦截 category-ads-all 拦截，避免加载资源 视频/媒体优化访问 指定视频域名走高速节点，并配置专用 DNS 区分办公与娱乐流量 企业域名直连，娱乐流量走代理或拦截 内网解析 内部域名通过本地 DNS（如局域网 DNS）解析 🔚 总结通过灵活组合 DNS 服务器与域名分流规则，我们可以打造一个智能、安全、高效的网络访问系统。无论是用于日常科学上网、广告拦截、企业办公还是网络优化，这套机制都能提供强有力的支持。 如需生成完整配置、导入 geosite、domain-set 或其他分流模板，可继续向我提问。","link":"/posts/domain-routing/"},{"title":"大厂常问iOS面试题--Block篇","text":"这一篇我们来研究一下objc的block并回答一下面试中的下列问题: 1.block的内部实现，结构体是什么样的 2.block是类吗，有哪些类型 3.一个int变量被 __block 修饰与否的区别？block的变量截获 4.block在修改NSMutableArray，需不需要添加__block 5.怎么进行内存管理的 6.block可以用strong修饰吗 7.解决循环引用时为什么要用__strong、__weak修饰 8.block发生copy时机 9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别 在回答所有问题之前我们需要了解一些block背景相关的知识. 如下: 如何查看Block的内部实现,也就是说转换成背后真正的c/c++代码的block是什么样的？以及转换格式或者原理等. -关于变量的作用域 Objective-C 转 C++的方法下面我写了个示例TestClass.m类其中block代码如下 OC代码: 12345678910111213@interface TestClass ()@end@implementation TestClass- (void)testMethods { void (^blockA)(int a) = ^(int a) { NSLog(@&quot;%d&quot;,a); }; if (blockA) { blockA(1990); }}@end 经过上述转换操作我们在TestClass.cpp中最下面发现如下代码 C++代码 12345678910111213141516171819202122232425262728293031323334// @interface TestClass ()/* @end */// @implementation TestClassstruct __TestClass__testMethods_block_impl_0 { struct __block_impl impl; struct __TestClass__testMethods_block_desc_0* Desc; __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_ee18d3_mi_0,a); }static struct __TestClass__testMethods_block_desc_0 { size_t reserved; size_t Block_size;} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)};static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) { void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA)); if (blockA) { ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990); }} 上面的代码生成是通过如下操作: 打开终端，cd到TestClass.m所在文件夹,使用如下命令 1clang -rewrite-objc TestClass.m 就会在当前文件夹内自动生成对应的TestClass.cpp文件 注意: 如果提示clang没有的话 需要安装, 输入如下 12345brew install clang-format或者brew link clang-forma然后输入 下面命令测试是否好使clang-format --help 通过上述代码我们发现Block的其实是一个结构体类型 底层实现 会根据 __类名__方法名_block_impl_下标 (0代表这个方法或者这个类中第0个block 下面如果还有将会 第1个block 第2个…) 1struct __类名__方法名_block_impl_下标 关于变量的作用域c语言的函数中可能使用的参数变量种类 参数类型 自动变量(局部变量) 静态变量(静态局部变量) 静态全局变量 全局变量 由于存储区域特殊,这其中有三种变量是可以在任何时候以任何状态调用的. 静态变量 静态全局变量 全局变量 而其他两种,则是有各自相应的作用域,超过作用域后,会被销毁. 1.block的内部实现，结构体是什么样的看了上面的背景知识我们来回到一下这个问题 block的内部实现如下: 12345678910111213141516171819202122232425262728293031323334struct __TestClass__testMethods_block_impl_0 { struct __block_impl impl; //成员变量 struct __TestClass__testMethods_block_desc_0* Desc; //desc 结构体声明 // 构造函数 // fp 函数指针 // desc 静态全局变量初始化的 __main_block_desc_ 结构体实例指针 // flags block 的负载信息(引用计数和类型信息),按位存储. __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};//将来被调用的block内部的代码：block值被转换为C的函数代码//这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己(相当于C++里的this，OC里的self)//__cself 是指向__TestClass__testMethods_block_impl_0结构体实现的指针//Block结构体就是__TestClass__testMethods_block_impl_0结构体.Block的值就是通过__TestClass__testMethods_block_impl_0构造出来的static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_9f58f7_mi_0,a);}static struct __TestClass__testMethods_block_desc_0 { size_t reserved; size_t Block_size;} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)};static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) { void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA)); if (blockA) { ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990); }} 可以看得出来__TestClass__testMethods_block_impl_0有3个部分组成 impl 函数指针指向__TestClass__testMethods_block_impl_0 123456struct __block_impl { void *isa; int Flags; int Reserved; //今后版本升级所需的区域 void *FuncPtr; //函数指针}; Desc 指向__TestClass__testMethods_block_impl_0的Desc指针,用于描述当前这个block的附加信息的，包括结构体的大小等等信息. 1234static struct __TestClass__testMethods_block_desc_0 { size_t reserved; //今后升级版本所需区域 size_t Block_size; //block的大小} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)}; __TestClass__testMethods_block_impl_0()构造函数,也就是该block的具体实现 123456__TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc;} 此结构体中 isa指针保持这所属类的结构体的实例的指针. struct __TestClass__testMethods_block_impl_0相当于Objective-C类对象的结构体 _NSConcreteStackBlock相当于Block的结构体实例,也就是说block其实就是Objective-C对于闭包的对象实现 讲到这里block的内部实现你看懂了吗?结构体是什么样的你记住了吗? 其实看着繁琐 细心观察代码会发现还是比较简单的. 2.block是类吗，有哪些类型?block也算是个类,因为它有isa指针,block.isa的类型包括 _NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域(.data)中 _NSConcreteStackBlock栈上(前面讲的都是栈上的 block) _NSConcreteMallocBlock 堆上 这个isa可以按位运算 3.一个int变量被 __block 修饰与否的区别？block的变量截获被__block 修饰与否的区别用一段示例代码来解答这个问题吧: 12345678910111213141516__block int a = 10;int b = 20;PrintTwoIntBlock block = ^(){ a -= 10; printf(&quot;%d, %d\\n&quot;,a,b);};block();//0 20a += 20;b += 30;printf(&quot;%d, %d\\n&quot;,a,b);//20 50block();/10 20 通过__block修饰int a,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用. int b没有被__block修饰,block内部对b是值copy.所以在block内部修改b不影响外部b的变化. block的变量截获通过如下代码我们来观察要一下变量的捕获 1234567891011blk_t blk;{ id array = [NSMutableArray new]; blk = [^(id object){ [array addObject:object]; NSLog(@&quot;array count = %ld&quot;,[array count]); } copy];}blk([NSObject new]);blk([NSObject new]);blk([NSObject new]); 输出打印 123block_demo[28963:1629127] array count = 1block_demo[28963:1629127] array count = 2block_demo[28963:1629127] array count = 3 我们把上面的代码翻译成C++看下 1234567891011struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; id array;//截获的对象 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 在Objc中，C结构体里不能含有被__strong修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是Objc的运行时库能够准确把握Block从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过__TestClass__testMethods_block_copy_0函数和__TestClass__testMethods_block_dispose_0函数进行的 123456static void __TestClass__testMethods_block_copy_0(struct __TestClass__testMethods_block_impl_0*dst, struct __TestClass__testMethods_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);} static void __TestClass__testMethods_block_dispose_0(struct __TestClass__testMethods_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);} _Block_object_assign相当于retain操作,将对象赋值在对象类型的结构体成员变量中. _Block_object_dispose相当于release操作. 这两个函数调用的时机是在什么时候呢？ 函数 被调用时机 __TestClass__testMethods_block_copy_0 从栈复制到堆时 __TestClass__testMethods_block_dispose_0 堆上的Block被废弃时 什么时候栈上的Block会被复制到堆呢？ 调用block的copy函数时。 Block作为函数返回值返回时。 将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时。 方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。 什么时候Block被废弃呢？ 堆上的Block被释放后,谁都不再持有Block时调用dispose函数。 以上就是变量被block捕获的内容 4.block在修改NSMutableArray，需不需要添加__block 如修改NSMutableArray的存储内容的话,是不需要添加__block修饰的。 如修改NSMutableArray对象的本身,那必须添加__block修饰。 5.怎么进行内存管理的?在上面Block的构造函数__TestClass__testMethods_block_impl_0中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中. block内存操作 存储域/存储位置 copy操作的影响 _NSConcreteGlobalBlock 程序的数据区域 什么也不做 _NSConcreteStackBlock 栈 从栈拷贝到堆 _NSConcreteMallocBlock 堆 引用计数增加 全局Block:_NSConcreteGlobalBlock的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件: 记述全局变量的地方有block语法时. block不截获的自动变量. 以上两个条件只要满足一个就可以产生全局Block. 参考 栈Block:_NSConcreteStackBlock在生成Block以后，如果这个Block不是全局Block,那它就是栈Block,生命周期在其所属的变量作用域内.(也就是说如果销毁取决于所属的变量作用域).如果Block变量和__block变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block. 堆Block:_NSConcreteMallocBlock将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。 6.block可以用strong修饰吗?在ARC中可以，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作. 在MRC中不行,因为要有拷贝过程.如果执行copy用strong的话会crash, strong是ARC中引入的关键字.如果使用retain相当于忽视了block的copy过程. 7.解决循环引用时为什么要用__strong、__weak修饰?首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上__weak,在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,但是持有的是我们上面加了__weak所以行程了比消此长的链条,刚好能解决block延迟销毁的时候对外部对象生命周期造成的影响.如果不这样做很容易造成循环引用. 8.block发生copy时机?在ARC中,编译器将创建在栈中的block会自动拷贝到堆内存中,而block作为方法或函数的参数传递时,编译器不会做copy操作. 调用block的copy函数时。 Block作为函数返回值返回时。 将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时。 方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。 9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别? ARC下会对这个对象强引用，MRC下不会","link":"/posts/fff5bffc/"},{"title":"大厂常问iOS面试题--NSNotification篇","text":"主要内容包含如下: 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等） 通知的发送时同步的，还是异步的 NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息 NSNotificationQueue是异步还是同步发送？在哪个线程响应 NSNotificationQueue和runloop的关系 如何保证通知接收的线程在主线程 页面销毁时不移除通知会崩溃吗 多次添加同一个通知会是什么结果？多次移除通知呢 下面的方式能接收到通知吗？为什么 1234// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil]; 在解释这些内容之前 强烈建议认真研读一下这篇 一文全解iOS通知机制(经典收藏)文章 了解一下大概 所有的问题就迎刃而解了. 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等首先通知中心结构大概分为如下几个类 NSNotification 通知的模型 name、object、userinfo. NSNotificationCenter通知中心 负责发送NSNotification NSNotificationQueue通知队列 负责在某些时机触发 调用NSNotificationCenter通知中心 post通知 通知是结构体通过双向链表进行数据存储 123456789101112131415// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation; 主要是以key value的形式存储,这里需要重点强调一下 通知以 name和object两个纬度来存储相关通知内容,也就是我们添加通知的时候传入的两个不同的方法. 简单理解name&amp;observer&amp;SEL之间的关系就是name作为key, observer作为观察者对象,当合适时机触发就会调用observer的SEL.这基本很简单,如果觉得我说的不准确可以看下文章开头的文章. 通知的发送时同步的，还是异步的同步发送.因为要调用消息转发.所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程. NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息是的, 异步线程发送通知则响应函数也是在异步线程. 异步发送通知可以开启异步线程发送即可. NSNotificationQueue是异步还是同步发送？在哪个线程响应123456// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送}; NSPostWhenIdle NSPostASAP NSPostNow NSPostingStyle 异步发送 异步发送 同步发送 NSNotificationCenter都是同步发送的，而这里介绍关于NSNotificationQueue的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了runloop的时机来触发的. 异步线程发送通知则响应函数也是在异步线程,主线程发送则在主线程. NSNotificationQueue和runloop的关系NSNotificationQueue依赖runloop. 因为通知队列要在runloop回调的某个时机调用通知中心发送通知.从下面的枚举值就能看出来 123456// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送}; 如何保证通知接收的线程在主线程如果想在主线程响应异步通知的话可以用如下两种方式 1.系统接受通知的API指定队列 1- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block 2.NSMachPort的方式 通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可 页面销毁时不移除通知会崩溃吗?iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针. iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。 多次添加同一个通知会是什么结果？多次移除通知呢多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。 下面的方式能接收到通知吗？为什么1234// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil]; 不能 首先我们看下通知中心存储通知观察者的结构 123456789101112131415// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation; nameless与named的具体数据结构如下: 当添加通知监听的时候，我们传入了name和object，所以，观察者的存储链表是这样的： named表：key(name) : value-&gt;key(object) : value(Observation) 因此在发送通知的时候，如果只传入name而并没有传入object，是找不到Observation的，也就不能执行观察者回调. 总结今天又重新认识了iOS中的通知中心,希望大家经常温故而知新.","link":"/posts/2bf627ae/"},{"title":"大厂常问iOS面试题--Runloop篇","text":"1.Runloop 和线程的关系？ 一个线程对应一个 Runloop。 主线程的默认就有了 Runloop。 子线程的 Runloop 以懒加载的形式创建。 Runloop 存储在一个全局的可变字典里，线程是 key ，Runloop 是 value。 2.RunLoop的运行模式 RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重写启动一个运行模式 12345- kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行- UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）- kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式- UIInitializationRunLoopMode：在刚启动App时进入的第一个Mode，启动完成后就不再使用- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 3.runloop内部逻辑？ 实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 内部逻辑： 通知 Observer 已经进入了 RunLoop 通知 Observer 即将处理 Timer 通知 Observer 即将处理非基于端口的输入源（即将处理 Source0） 处理那些准备好的非基于端口的输入源（处理 Source0） 如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1） 通知 Observer 线程即将休眠 将线程置于休眠状态，直到发生以下事件之一 事件到达基于端口的输入源（port-based input sources）(也就是 Source0) Timer 到时间执行 外部手动唤醒 为 RunLoop 设定的时间超时 通知 Observer 线程刚被唤醒（还没处理事件） 处理待处理事件 如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步 如果输入源被触发，处理该事件（文档上是 deliver the event） 如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步 4.autoreleasePool 在何时被释放？ App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 5.GCD 在Runloop中的使用？ GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。 6.AFNetworking 中如何运用 Runloop? AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }}+ (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start { [self.lock lock]; if ([self isCancelled]) { [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } else if ([self isReady]) { self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } [self.lock unlock];} 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 7.PerformSelector 的实现原理？ 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 8.PerformSelector:afterDelay:这个方法在子线程中是否起作用？ 不起作用，子线程默认没有 Runloop，也就没有 Timer。可以使用 GCD的dispatch_after来实现 9.事件响应的过程？ 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 10.手势识别的过程？ 当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 11.CADisplayLink和Timer哪个更精确CADisplayLink 更精确 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。","link":"/posts/c985851c/"},{"title":"大厂常问iOS面试题--Runloop&amp;KVO篇","text":"前言今天这一篇我们来讲一下 Runloop和KVO 本章的主要回答的问题如下: Runloop app如何接收到触摸事件的 为什么只有主线程的runloop是开启的 为什么只在主线程刷新UI PerformSelector和runloop的关系 如何使线程保活 KVO 实现原理 如何手动关闭kvo 通过KVC修改属性会触发KVO么 哪些情况下使用kvo会崩溃，怎么防护崩溃 kvo的优缺点 Runloop作为一个合格的iOS开发者必须对runloop有一个更深入的了解,下面我们来回答一下 相关问题 1.app如何接收到触摸事件的回答这个问题前请认真阅读一下 iOS触摸事件全家桶 通过上图可以看出整个流程就是 我们app启动默认会通过machPort监听端口的方式 来接受IOHIDEvent 来接收和处理触摸事件. 2.为什么只有主线程的runloop是开启的mian()函数中调用UIApplicationMain，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行并接收事件，所以在主线程中开启一个runloop，让主线程常驻. 3.为什么只在主线程刷新UI我们所有用到的UI都是来自于UIKit这个基础库.因为objc不是一门线程安全的语言所以存在多线程读写不同步的问题,如果使用加锁的方式操作系统开销很大,会耗费大量的系统资源(内存、时间片轮转、cpu处理速度…)，加上上面讲到的系统事件的接收处理都在主线程,如果UI异步线程的话 还会存在 同步处理事件的问题,所以多点触摸手势等一些事件要保持和UI在同一个线程相对是最优解. 另一方面是 屏幕的渲染是 60帧(60Hz/秒), 也就是1秒钟回调60次的频率,(iPad Pro 是120Hz/秒),我们的runloop 理想状态下也会按照时钟周期 回调60次(iPad Pro 120次), 这么高频率的调用是为了 屏幕图像显示能够垂直同步 不卡顿.在异步线程的话是很难保证这个处理过程的同步更新. 即便能保证的话 相对主线程而言 系统资源开销 线程调度等等将会占据大部分资源和在同一个线程只专门干一件事有点得不偿失. 4.PerformSelector和runloop的关系当调用NSObect的 performSelector:相关的时候,内部会创建一个timer定时器添加到当前线程的runloop中,如果当前线程没有启动runloop,则该方法不会被调用. 开发中遇到最多的问题就是这个performSelector: 导致对象的延迟释放,这里开发过程中注意一下,可以用单次的NSTimer替代. 详细可以参考Runloop与performSelector 5.如何使线程保活？想要线程保活的话就开启该线程的runloop即可,注意:在NSThread执行的方法中添加while(true){}，这样是模拟runloop的运行原理，结合GCD的信号量，在{}代码块中处理任务. 但是注意 开启runloop的方法要正确 如下代码 123456789101112131415161718192021222324252627282930313233343536373839//测试开启线程- (void)memoryTest { for (int i = 0; i &lt; 100000; ++i) { NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; [self performSelector:@selector(stopThread) onThread:thread withObject:nil waitUntilDone:YES]; }}//线程停止- (void)stopThread { CFRunLoopStop(CFRunLoopGetCurrent()); NSThread *thread = [NSThread currentThread]; [thread cancel];}//运行线程的runloop 注意 意添加的那个空port,否则会出现内存泄露- (void)run { @autoreleasepool { NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; if (!self.emptyPort) { self.emptyPort = [NSMachPort port]; } [runLoop addPort:self.emptyPort forMode:NSDefaultRunLoopMode]; [runLoop runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]]; }}//下列代码用于模拟线程内部做的一些耗时任务- (void)printSomething { NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); [self performSelector:@selector(printSomething) withObject:nil afterDelay:1];}//模拟手动点击按钮 让 runloop停掉- (void)stopButtonDidClicked:(id)sender { [self performSelector:@selector(stopRunloop) onThread:self.thread withObject:nil waitUntilDone:YES];}- (void)stopRunloop { CFRunLoopStop(CFRunLoopGetCurrent());} 详细请参考:iOS开发深入研究Runloop与线程保活 KVO在开发过程中我们经常使用KVO,下面解答一下KVO相关的问题. KVO的实现原理通过runtime派生子类的方式 复写相关需要KVO监听的属性,在该属性setter之前和之后调用NSObject的监听方法,这样KVO就实现了属性变换前后的回调. KVO派生的子类具体格式应该是:NSKVONotifying_+类名的类 eg: NSKVONotifying_Person 下面示例代码为Person类的name添加KVO的模拟实验 12345678910111213- (void)setName:(NSString *)name{ _NSSetObjectValueAndNotify();}void _NSSetObjectValueAndNotify { [self willChangeValueForKey:@&quot;name&quot;]; [super setName:name]; [self didChangeValueForKey:@&quot;name&quot;];}- (void)didChangeValueForKey:(NSString *)key{ [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];} 问题来了如何动态创建类呢? 12345678910111213141516171819//动态创建XXCustomClassClass customClass = objc_allocateClassPair([NSObject class], &quot;XXCustomClass&quot;, 0);// 添加实例变量class_addIvar(customClass, &quot;age&quot;, sizeof(int), 0, &quot;i&quot;);// 动态添加方法class_addMethod(customClass, @selector(hahahha), (IMP)hahahha, &quot;V@:&quot;);//需要实现的方法void hahahha(id self, SEL _cmd){ NSLog(@&quot;hahahha====&quot;);}- (void)hahahha{}//最后注册到运行时环境objc_registerClassPair(customClass); V@:表示方法的参数和返回值 具体原理以及自定义实现KVO可以参考KVO详解及底层实现 如何手动关闭KVO?被观察的对象复写如下方法 返回NO即可关闭KVO 123+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key { return NO;} 如果关闭后还想触发 KVO的话 修改需要手动调用在变量setter的前后 主动调用 willChangeValueForKey:和didChangeValueForKey: 通过KVC修改属性会触发KVO么?会的 哪些情况下使用kvo会崩溃，怎么防护崩溃？使用不当 会crash,比如: 添加和移出不是成对出现且存在多线程添加KVO的情况,经常遇到的crash是移出 - 内存dealloc的时候 或者对象销毁前没有正确移出Observer 如何防护？ 1.注意移出对象 匹配 2.内存野指针问题,一定要在对象销毁前移出观察者 3.可以使用第三方库BlockKit添加KVO,blockkit内部会自动移除Observer避免crash. KVO的优缺点优点: 方便两个对象间同步状态(keypath)更加方便,一般都是在A类要观察B类的属性的变化. 非侵入式的得到某内部对象的状态改变并作出响应.(就是在不改变原来对象类的代码情况下即可做出对该对象的状态变化进行监听) 可以嵌入更改前后的两个时机的状态. - 可以通过Keypaths对嵌套对象的监听. 缺点: 需要手动移除观察者,不移除容易造成crash. 注册和移出成对匹配出现. keypath参数的类型String, 如果对象的成员变量被重构而变化字符串不会被编译器识别而报错. 实现观察的方式是复写NSObjec的相关KVO的方法,应该更加面向protocol的方式会更好. 总结这一篇我们讲了 runloop和KVO相关的内容,这里面最负责的当属runloop如何处理触摸手势事件.建议认真研读相关链接文章.这样才有一个对runloop更深刻的理解。","link":"/posts/1e8a5be3/"},{"title":"大厂常问iOS面试题--Runtime篇","text":"1.什么是Runtime在 Objective-C 中，Runtime 是一套 C 语言的 API，用于在运行时操作对象、类和元类。通过 Objective-C Runtime，开发者可以在程序运行时动态地创建类、修改类的方法、获取类的属性信息、发送消息等。这使得 Objective-C 具有了诸多动态语言的特性，如动态绑定、消息转发、方法调用等。 2.Category 的实现原理？ Category 实际上是 Category_t的结构体，在运行时，新添加的方法，都被以倒序插入到原有方法列表的最前面，所以不同的Category，添加了同一个方法，执行的实际上是最后一个。 Category 在刚刚编译完的时候，和原来的类是分开的，只有在程序运行起来后，通过 Runtime ，Category 和原来的类才会合并到一起。 3.isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？ isa 等价于 is kind of 实例对象的 isa 指向类对象 类对象的 isa 指向元类对象 元类对象的 isa 指向元类的基类 isa 有两种类型 纯指针，指向内存地址 NON_POINTER_ISA，除了内存地址，还存有一些其他信息 4.Objective-C 如何实现多重继承？Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现 通过组合实现 A和B组合，作为C类的组件 通过协议实现 C类实现A和B类的协议方法 消息转发实现 forwardInvocation:方法 5.runtime 如何实现 weak 属性？weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。 runtime 对注册的类，会进行内存布局，从一个粗粒度的概念上来讲，这时候会有一个 hash 表，这是一个全局表，表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。当此对象的引用计数为 0 的时候会 dealloc，假如该对象内存地址是 a，那么就会以 a 为 key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。 runtime 如何实现 weak 属性具体流程大致分为 3 步： 1、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向（指针可能原来指向着其他对象，这时候需要将该 weak 指针与旧对象解除绑定，会调用到 weak_unregister_no_lock），如果指针指向的新对象非空，则创建对应的弱引用表，将 weak 指针与新对象进行绑定，会调用到 weak_register_no_lock。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。 3、释放时：调用 clearDeallocating 函数，clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 6.讲一下 OC 的消息机制Objective-C 的消息机制是其动态消息传递的核心特性，它是 Objective-C 语言中实现方法调用的机制。在 Objective-C 中，对象之间的通信是通过向对象发送消息来实现的，而不是像其他语言那样直接调用方法。 消息机制的基本原理如下： 1、方法调用：在 Objective-C 中，调用对象的方法实际上是向对象发送一个消息。消息由方法名和对应的参数组成。 2、动态绑定：在编译时，编译器并不会确定对象接收到消息时应该调用的具体方法，而是在运行时根据对象的类和方法选择器（selector）来动态确定调用的方法。这种动态确定方法的过程称为动态绑定。 3、消息传递：当一个对象接收到消息时，Objective-C 运行时会根据消息的方法选择器（selector）在对象所属的类的方法列表（method list）中查找相应的方法实现。如果找到了匹配的方法实现，则调用该方法；如果找不到匹配的方法实现，则会执行消息转发（message forwarding）过程。 4、消息转发：当运行时无法在类的方法列表中找到与消息相匹配的方法实现时，Objective-C 运行时会调用对象的 forwardingTargetForSelector: 方法，尝试将消息转发给另一个对象处理。如果该方法返回一个有效的对象，则将消息转发给该对象；如果返回 nil，则会继续执行下一步的消息转发机制。 5、动态方法解析：如果 forwardingTargetForSelector: 方法没有返回有效的对象，Objective-C 运行时会调用对象的 resolveInstanceMethod: 或 resolveClassMethod: 方法，尝试动态地添加方法实现。如果成功添加了方法实现，则会重新执行消息传递过程；如果仍然无法找到相应的方法实现，则会执行最后一步的消息转发机制。 6、完整的消息转发：如果动态方法解析仍然无法找到相应的方法实现，则 Objective-C 运行时会调用对象的 forwardInvocation: 方法，将原始的未知消息封装成一个 NSInvocation 对象，并传递给 forwardInvocation: 方法进行处理。开发者可以在该方法中自定义处理未知消息的逻辑，例如将消息转发给其他对象进行处理。 7.runtime具体应用 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题 KVC 字典转模型 8.runtime如何通过selector找到对应的IMP地址？每一个类对象中都一个对象方法列表（对象方法缓存） 类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）。 方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现。 当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找。 当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找。 9.简述下Objective-C中调用方法的过程Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下： objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类 然后在该类中的方法列表以及其父类方法列表中寻找方法运行 如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会，这三次拯救程序奔溃的说明见问题《什么时候会报unrecognized selector的异常》中的说明。 10.load和initialize的区别两者都会自动调用父类的，不需要super操作，且仅会调用一次（不包括外部显示调用). load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。 load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。 load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。 load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。 11.怎么理解Objective-C是动态运行时语言。 主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。 简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物,猪也属于生物,都继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础.","link":"/posts/56ea4065/"},{"title":"大厂常问iOS面试题--多线程篇","text":"1.进程与线程 进程： 1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元. 2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app. 3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源 线程 1.程序执行流的最小单元，线程是进程中的一个实体. 2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程 进程和线程的关系 1.线程是进程的执行单元，进程的所有任务都在线程中执行 2.线程是 CPU 分配资源和调度的最小单位 3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程 4.同一个进程内的线程共享进程资源 2.什么是多线程？ 多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。 如果是多核CPU就真的可以同时处理多个线程了。 多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。 3.多线程的优点和缺点 优点: 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 缺点: 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 4.多线程的 并行 和 并发 有什么区别？ 并行：充分利用计算机的多核，在多个线程上同步进行 并发：在一条线程上通过快速切换，让人感觉在同步进行 5.iOS中实现多线程的几种方案，各自有什么特点？ NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。 GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。 NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。 6.多个网络请求完成后执行下一步 使用GCD的dispatch_group_t 创建一个dispatch_group_t 每次网络请求前先dispatch_group_enter,请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。 当所有enter的block都leave后，会执行dispatch_group_notify的block。 12345678910111213141516171819NSString *str = @&quot;http://xxxx.com/&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_group_t downloadGroup = dispatch_group_create();for (int i=0; i&lt;10; i++) { dispatch_group_enter(downloadGroup); NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); dispatch_group_leave(downloadGroup); }]; [task resume];}dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 使用GCD的信号量dispatch_semaphore_t dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。dispatch_semaphore_signal(semaphore)为计数+1操作,dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。 创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回 1234567891011121314151617181920212223NSString *str = @&quot;http://xxxx.com/&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_semaphore_t sem = dispatch_semaphore_create(0);for (int i=0; i&lt;10; i++) { NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); count++; if (count==10) { dispatch_semaphore_signal(sem); count = 0; } }]; [task resume];}dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 7.多个网络请求顺序执行后执行下一步 使用信号量semaphore 每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后 123456789101112131415161718192021NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_semaphore_t sem = dispatch_semaphore_create(0);for (int i=0; i&lt;10; i++) { NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); dispatch_semaphore_signal(sem); }]; [task resume]; dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);}dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 8.异步操作两组数据时, 执行完第一组之后, 才能执行第二组 这里使用dispatch_barrier_async栅栏方法即可实现 123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{ NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{ NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_barrier_async(queue, ^{ NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);});dispatch_async(queue, ^{ NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{ NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);}); 9.多线程中的死锁？死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个： 互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞。 123456dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;);});NSLog(@&quot;1&quot;);// 什么也不会打印，直接报错 10.GCD执行原理？ GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？） 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。 如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。 这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5–8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3–5条最为合理。","link":"/posts/b46135b/"},{"title":"大厂常问iOS面试题--性能优化篇","text":"1.造成tableView卡顿的原因有哪些？ 1.最常用的就是cell的重用， 注册重用标识符 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。 如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 2.避免cell的重新布局 cell的布局填充等操作 比较耗时，一般创建时就布局好 如可以将cell单独放到一个自定义类，初始化时就布局好 3.提前计算并缓存cell的属性及内容 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell 4.减少cell中控件的数量 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件， 不适用的可以先隐藏 5.不要使用ClearColor，无背景色，透明度也不要设置为0 渲染耗时比较长 6.使用局部更新 如果只是更新某组的话，使用reloadSection进行局部更 7.加载网络数据，下载图片，使用异步加载，并缓存 8.少使用addView 给cell动态添加view 9.按需加载cell，cell滚动很快时，只加载范围内的cell 10.不要实现无用的代理方法，tableView只遵守两个协议 11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可 12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。 13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕； 14.使用正确的数据结构来存储数据。 2.如何提升 tableview 的流畅度？ 本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。 CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制 GPU：纹理的渲染 卡顿优化在 CPU 层面 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout 会比直接设置 frame 消耗更多的 CPU 资源 图片的 size 最好刚好跟 UIImageView 的 size 保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 卡顿优化在 GPU层面 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES 尽量避免出现离屏渲染 iOS 保持界面流畅的技巧 1.预排版，提前计算 在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。 尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式 2.预渲染，提前绘制 例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了 避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。 3.异步绘制 4.全局并发线程 5.高效的图片异步加载 3.APP启动时间应从哪些方面优化？App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手 dylib loading time 核心思想是减少dylibs的引用 合并现有的dylibs（最好是6个以内） 使用静态库 rebase/binding time 核心思想是减少DATA块内的指针 减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突） 减少c++虚函数 多使用Swift结构体（推荐使用swift） ObjC setup time 核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时 initializer time 使用initialize替代load方法 减少使用c/c++的attribute((constructor))；推荐使用dispatch_once() pthread_once() std:once()等方法 推荐使用swift 不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁 不要在初始化中创建线程 4.如何降低APP包的大小降低包大小需要从两方面着手 可执行文件 编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 资源（图片、音频、视频 等） 优化的方式可以对资源进行无损的压缩 去除没有用到的资源 5.如何检测离屏渲染与优化 检测，通过勾选Xcode的Debug-&gt;View Debugging–&gt;Rendering-&gt;Run-&gt;Color Offscreen-Rendered Yellow项。 优化，如阴影，在绘制时添加阴影的路径 6.怎么检测图层混合1、模拟器debug中color blended layers红色区域表示图层发生了混合 2、Instrument-选中Core Animation-勾选Color Blended Layers 避免图层混合： 确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明 如无特殊需要，不要设置低于1的alpha值 确保UIImage没有alpha通道 UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer.masksToBounds=YES让label只会渲染她的实际size区域，就能解决UILabel的图层混合问题 iOS8 之前只要设置背景色为非透明的就行 为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？ UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了 7.日常如何检查内存泄露？ 目前我知道的方式有以下几种 Memory Leaks Alloctions Analyse Debug Memory Graph MLeaksFinder 泄露的内存主要有以下两种： Laek Memory 这种是忘记 Release 操作所泄露的内存。 Abandon Memory 这种是循环引用，无法释放掉的内存。","link":"/posts/83f6a6a3/"},{"title":"大厂常问iOS面试题--内存管理篇","text":"1.什么情况使用weak关键字，相比assign有什么不同？ 什么情况使用 weak 关键字？ 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》 不同点： weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。 assign 可以用非 OC 对象,而 weak 必须用于 OC 对象 2.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？ 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤： 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议。该协议只有一个方法: 1- (id)copyWithZone:(NSZone *)zone; 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。 重写带 copy 关键字的 setter，例如： 1234- (void)setName:(NSString *)name { //[_name release]; _name = [name copy];} 3.深拷贝与浅拷贝浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。 当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形： 当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现； 当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。 copy方法:如果是非可扩展类对象，则是浅拷贝。如果是可扩展类对象，则是深拷贝。 mutableCopy方法:无论是可扩展类对象还是不可扩展类对象，都是深拷贝。 4.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的 @property 的本质是实例变量（ivar）+存取方法（access method ＝ getter + setter）,即 @property = ivar + getter + setter; “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。 ivar、getter、setter 是自动合成这个类中的 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字. 5.@protocol和category中如何使用@property 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性 category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：objc_setAssociatedObject和objc_getAssociatedObject 6.简要说一下@autoreleasePool的数据结构？？简单说是双向链表，每张链表头尾相接，有 parent、child指针 每创建一个池子，会在首部创建一个 哨兵 对象,作为标记 最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。 7.BAD_ACCESS在什么情况下出现？访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环 8.使用CADisplayLink、NSTimer有什么注意点？CADisplayLink、NSTimer会造成循环引用，可以使用YYWeakProxy或者为CADisplayLink、NSTimer添加block方法解决循环引用 9.iOS内存分区情况 栈区（Stack） 由编译器自动分配释放，存放函数的参数，局部变量的值等 栈是向低地址扩展的数据结构，是一块连续的内存区域 堆区（Heap） 由程序员分配释放 是向高地址扩展的数据结构，是不连续的内存区域 全局区 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域 程序结束后由系统释放 常量区 常量字符串就是放在这里的 程序结束后由系统释放 代码区 存放函数体的二进制代码 注： 在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的 系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容） 变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收 当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错） 10.iOS内存管理方式 Tagged Pointer（小对象） Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍 objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据 使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中 NONPOINTER_ISA （指针中存放与该对象内存相关的信息） 苹果将 isa 设计成了联合体，在 isa 中存储了与该对象相关的一些内存的信息，原因也如上面所说，并不需要 64 个二进制位全部都用来存储指针。 isa 的结构： 12345678910111213141516171819202122232425// x86_64 架构struct { uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 44; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 8; // 引用计数能够用 8 个二进制位存储时，直接存储在这里};// arm64 架构struct { uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 33; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 19; // 引用计数能够用 19 个二进制位存储时，直接存储在这里}; 这里的 has_sidetable_rc 和 extra_rc，has_sidetable_rc 表明该指针是否引用了 sidetable 散列表，之所以有这个选项，是因为少量的引用计数是不会直接存放在 SideTables 表中的，对象的引用计数会先存放在 extra_rc 中，当其被存满时，才会存入相应的 SideTables 散列表中，SideTables 中有很多张 SideTable，每个 SideTable 也都是一个散列表，而引用计数表就包含在 SideTable 之中。 散列表（引用计数表、弱引用表） 引用计数要么存放在 isa 的 extra_rc 中，要么存放在引用计数表中，而引用计数表包含在一个叫 SideTable 的结构中，它是一个散列表，也就是哈希表。而 SideTable 又包含在一个全局的 StripeMap 的哈希映射表中，这个表的名字叫 SideTables。 当一个对象访问 SideTables 时： 首先会取得对象的地址，将地址进行哈希运算，与 SideTables 中 SideTable 的个数取余，最后得到的结果就是该对象所要访问的 SideTable 在取得的 SideTable 中的 RefcountMap 表中再进行一次哈希查找，找到该对象在引用计数表中对应的位置 如果该位置存在对应的引用计数，则对其进行操作，如果没有对应的引用计数，则创建一个对应的 size_t 对象，其实就是一个 uint 类型的无符号整型 弱引用表也是一张哈希表的结构，其内部包含了每个对象对应的弱引用表 weak_entry_t，而 weak_entry_t 是一个结构体数组，其中包含的则是每一个对象弱引用的对象所对应的弱引用指针。 11.循环引用1. 概述iOS内存中的分区有：堆、栈、静态区。其中，栈和静态区是操作系统自己管理回收，不会造成循环引用。在堆中的相互引用无法回收，有可能造成循环引用。 循环引用的实质：多个对象相互之间有强引用，不能施放让系统回收。 解决循环引用一般是将 strong 引用改为 weak 引用。 2. 循环引用场景分析及解决方法1）父类与子类 如：在使用UITableView 的时候，将 UITableView 给 Cell 使用，cell 中的 strong 引用会造成循环引用。 1234567891011// controller- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { TestTableViewCell *cell =[tableView dequeueReusableCellWithIdentifier:@&quot;UITableViewCellId&quot; forIndexPath:indexPath]; cell.tableView = tableView; return cell;}// cell@interface TestTableViewCell : UITableViewCell@property (nonatomic, strong) UITableView *tableView; // strong 造成循环引用@end 解决：strong 改为 weak 1234// cell@interface TestTableViewCell : UITableViewCell@property (nonatomic, weak) UITableView *tableView; // strong 改为 weak@end 2）block block在copy时都会对block内部用到的对象进行强引用的。 123self.testObject.testCircleBlock = ^{ [self doSomething];}; self将block作为自己的属性变量，而在block的方法体里面又引用了 self 本身，此时就很简单的形成了一个循环引用。 应该将 self 改为弱引用 12345__weak typeof(self) weakSelf = self; self.testObject.testCircleBlock = ^{ __strong typeof (weakSelf) strongSelf = weakSelf; [strongSelf doSomething];}; 在 ARC 中，在被拷贝的 block 中无论是直接引用 self 还是通过引用 self 的成员变量间接引用 self，该 block 都会 retain self。 快速定义宏 12345// weak obj/#define WEAK_OBJ(type) __weak typeof(type) weak##type = type;// strong obj/#define STRONG_OBJ(type) __strong typeof(type) str##type = weak##type; 3）Delegatedelegate 属性的声明如下： 1@property (nonatomic, weak) id &lt;TestDelegate&gt; delegate; 如果将 weak 改为 strong，则会造成循环引用 123456789// self -&gt; AViewControllerBViewController *bVc = [BViewController new];bVc = self; [self.navigationController pushViewController: bVc animated:YES]; // 假如是 strong 的情况 // bVc.delegate ===&gt; AViewController (也就是 A 的引用计数 + 1) // AViewController 本身又是引用了 &lt;BViewControllerDelegate&gt; ===&gt; delegate 引用计数 + 1 // 导致： AViewController &lt;======&gt; Delegate ，也就循环引用啦 4）NSTimerNSTimer 的 target 对传入的参数都是强引用（即使是 weak 对象） 解决办法: 《Effective Objective-C 》中的52条方法 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;@interface NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;@end#import &quot;NSTimer+YPQBlocksSupport.h&quot;@implementation NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats{ return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(ypq_blockInvoke:) userInfo:[block copy] repeats:repeats];}- (void)ypq_blockInvoke:(NSTimer *)timer{ void (^block)() = timer.userInfo; if(block) { block(); }}@end 使用方式： 1234567__weak ViewController * weakSelf = self;[NSTimer ypq_scheduledTimeWithTimeInterval:4.0f block:^{ ViewController * strongSelf = weakSelf; [strongSelf afterThreeSecondBeginAction]; } repeats:YES]; 计时器保留其目标对象，反复执行任务导致的循环，确实要注意，另外在dealloc的时候，不要忘了调用计时器中的 invalidate方法。","link":"/posts/d873727c/"},{"title":"大厂常问iOS面试题--数据结构篇","text":"1.数据结构的存储一般常用的有几种？各有什么特点？数据结构的存储一般常用的有两种 顺序存储结构 和 链式存储结构 顺序存储结构: 比如，数组，1-2-3-4-5-6-7-8-9-10，存储是按顺序的。再比如栈和队列等 链式存储结构: 比如，数组，1-2-3-4-5-6-7-8-9-10，链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序 2.集合结构 线性结构 树形结构 图形结构 集合结构 一个集合，就是一个圆圈中有很多个元素，元素与元素之间没有任何关系 这个很简单 线性结构 一个条线上站着很多个人。 这条线不一定是直的。也可以是弯的。也可以是值的 相当于一条线被分成了好几段的样子 （发挥你的想象力）。 线性结构是一对一的关系 树形结构 做开发的肯定或多或少的知道xml 解析 树形结构跟他非常类似。也可以想象成一个金字塔。树形结构是一对多的关系 图形结构 这个就比较复杂了。他呢 无穷。无边 无向（没有方向）图形机构 你可以理解为多对多 类似于我们人的交集关系 3.单向链表 双向链表 循环链表 单向链表 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑 双向链表 循环链表 循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;A. 绕成一个圈。就像蛇吃自己的这就是循环 不需要去死记硬背哪些理论知识。 4.数组和链表区别 数组 数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况 链表 链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高 5.堆、栈和队列堆 堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质： 1）堆中某个节点的值总是不大于或不小于其父节点的值； 2）堆总是一棵完全二叉树。 堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。 堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 栈 栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。 栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。 堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。 栈的应用—递归 队列 队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。 队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。 6.输入一棵二叉树的根结点，求该树的深度？二叉树的结点定义如下： 123456struct BinaryTreeNode{ int m_nValue ； BinaryTreeNode* m_pLeft; BinarvTreeNode* m_pRight ；} 如果一棵树只有一个结点，它的深度为1。 如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。 如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。 123456789int TreeDepth(TreeNode* pRoot){ if(pRoot == nullptr) return 0; int left = TreeDepth(pRoot-&gt;left); int right = TreeDepth(pRoot-&gt;right); return (left&gt;right) ? (left+1) : (right+1);} 7.输入一课二叉树的根结点，判断该树是不是平衡二叉树？ 重复遍历结点 先求出根结点的左右子树的深度，然后判断它们的深度相差不超过1，如果否，则不是一棵二叉树；如果是，再用同样的方法分别判断左子树和右子树是否为平衡二叉树，如果都是，则这就是一棵平衡二叉树。 遍历一遍结点 遍历结点的同时记录下该结点的深度，避免重复访问。 方法1: 123456789101112131415161718192021222324struct TreeNode{ int val; TreeNode* left; TreeNode* right;};int TreeDepth(TreeNode* pRoot){ if(pRoot==NULL) return 0; int left=TreeDepth(pRoot-&gt;left); int right=TreeDepth(pRoot-&gt;right); return left&gt;right?(left+1):(right+1);}bool IsBalanced(TreeNode* pRoot){ if(pRoot==NULL) return true; int left=TreeDepth(pRoot-&gt;left); int right=TreeDepth(pRoot-&gt;right); int diff=left-right; if(diff&gt;1 || diff&lt;-1) return false; return IsBalanced(pRoot-&gt;left) &amp;&amp; IsBalanced(pRoot-&gt;right);} 方法2： 123456789101112131415161718192021bool IsBalanced_1(TreeNode* pRoot,int&amp; depth){ if(pRoot==NULL){ depth=0; return true; } int left,right; int diff; if(IsBalanced_1(pRoot-&gt;left,left) &amp;&amp; IsBalanced_1(pRoot-&gt;right,right)){ diff=left-right; if(diff&lt;=1 || diff&gt;=-1){ depth=left&gt;right?left+1:right+1; return true; } } return false;}bool IsBalancedTree(TreeNode* pRoot){ int depth=0; return IsBalanced_1(pRoot,depth);}","link":"/posts/88a6dead/"},{"title":"大厂常问iOS面试题--组件化篇","text":"1.组件化有什么好处？ 业务分层、解耦，使代码变得可维护； 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护； 便于各业务功能拆分、抽离，实现真正的功能复用； 业务隔离，跨团队开发代码控制和版本风险控制的实现； 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力； 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App） 2.你是如何组件化解耦的？ 分层 基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制； 基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计 业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供； 中间件：target-action，url-block，protocol-class 3.为什么CTMediator方案优于基于Router的方案？Router的缺点： 在组件化的实施过程中，注册URL并不是充分必要条件。组件是不需要向组件管理器注册URL的，注册了URL之后，会造成不必要的内存常驻。注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过runtime做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。 在iOS领域里，一定是组件化的中间件为openURL提供服务，而不是openURL方式为组件化提供服务。如果在给App实施组件化方案的过程中是基于openURL的方案的话，有一个致命缺陷：非常规对象(不能被字符串化到URL中的对象，例如UIImage)无法参与本地组件间调度。 在本地调用中使用URL的方式其实是不必要的，如果业务工程师在本地间调度时需要给出URL，那么就不可避免要提供params，在调用时要提供哪些params是业务工程师很容易懵逼的地方。 为了支持传递非常规参数，蘑菇街的方案采用了protocol，这个会侵入业务。由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖public Protocol。这对于将来的业务迁移是有非常大的影响的。 CTMediator的优点： 调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。 组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。 方便传递各种类型的参数。 4.基于CTMediator的组件化方案，有哪些核心组成？ CTMediator中间件：集成就可以了 模块Target_%@：模块的实现及提供对外的方法调用Action_methodName，需要传参数时，都统一以NSDictionary*的形式传入。 CTMediator+%@扩展：扩展里声明了模块业务的对外接口，参数明确，这样外部调用者可以很容易理解如何调用接口。","link":"/posts/5851d297/"},{"title":"大厂常问iOS面试题--视图和图形篇","text":"本篇我们来讲一下 【iOS面试题的视图&amp;图形】相关的问题. 视图&amp;图像相关主要问题列表如下: AutoLayout的原理，性能如何 UIView &amp; CALayer的区别 事件响应链 drawrect &amp; layoutsubviews调用时机 UI的刷新原理 隐式动画 &amp; 显示动画区别 什么是离屏渲染 imageName&amp;imageWithContentsOfFile区别 多个相同的图片，会重复加载吗 图片是什么时候解码的，如何优化 图片渲染怎么优化 如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决 1.AutoLayout的原理，性能如何?AutoLayout的原理 来历 一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（论文地址:http://constraints.cs.washington.edu/solvers/uist97.html）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的Cassowary网站上http://constraints.cs.washington.edu/cassowary/。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的https://github.com/pybee/cassowary。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。 论文下载链接比较慢,我下载了一份Cassowary原文放到了我的博客 大家可以自由下载. AutoLayout的原理就是用Cassowary算法来将布局问题抽象成线性不等式，并分解成多个位置间的约束 因为多了计算视图大小frame的过程,所以性能肯定没有指定Frame坐标要快. 详细的原理以及高阶原理请参考戴铭老师的文章 戴铭老师写的 深入剖析Auto Layout，分析iOS各版本新增特性 性能如何?下面是WWDC2018 High Performance Auto Layout中对比的iOS12和iOS11下分别使用自动布局的性能对比现场. 经过实验得出如下图标结论: iOS12之前，视图嵌套的数量对性能的影响是呈指数级增长的，而iOS12优化之后对性能的影响是线性增长，对性能消耗不大。 无论如何优化也肯定不如CGRectFrame那样的设置更加直接,性能更好. 2.UIView &amp; CALayer的区别 区别 UIView CALayer 继承父类 UIView:UIResponder:NSObject CALayer:NSObject 用途 可以处理触摸事件 不处理用户的交互,不参与响应事件传递 两者关系 有一个CALayer成员变量 eg: view.layer 是UIView的成员变量 分工 处理交互层事件并包装各种图形的简单设置 底层渲染图形,支持动画 3.事件响应链下面这篇文章我已经在前几篇将runloop的时候提了不止一次,前列建议阅读,快手的同事大部分都以这个理解为标准 iOS触摸事件全家桶 4. drawrect &amp; layoutsubviews调用时机layoutSubviews:(相当于layoutSubviews()函数)在以下情况下会被调用： init初始化不会触发layoutSubviews。 addSubview会触发layoutSubviews。 设置view的Frame会触发layoutSubviews (frame发生变化触发)。 滚动一个UIScrollView会触发layoutSubviews。 旋转Screen会触发父UIView上的layoutSubviews事件。 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。 直接调用setLayoutSubviews。 drawrect:(drawrect()函数)在以下情况下会被调用： drawrect:是在UIViewController的loadView:和ViewDidLoad:方法之后调用. 当我们调用[UIFont的 sizeToFit]后,会触发系统自动调用drawRect: 当设置UIView的contentMode或者Frame后会立即触发触发系统调用drawRect: 直接调用setNeedsDisplay设置标记 或setNeedsDisplayInRect:的时候会触发drawRect: 知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下UIView的渲染过程. 5.UI的刷新原理这个问题我不知道问的是不是iOS离屏渲染过程,我来简单的回到一下这个吧 iOS 的MainRunloop 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕在这过程中要完成以下的工作: view的缓冲区创建 view内容的绘制(如果重写了 drawRect) 接收和处理系统的触摸事件 我们看到的UI图形实际上是CPU和GPU不断配合工作的结果.经过UIView的渲染过程 后我们的UI会不间断的接收系统图给我们的事件. 由于主线程的runloop 一直在回调,我们的UI就得到了刷新的窗口,是渲染还是处理事件都是因为runloop不断工作的结果.前几篇我们学过 main线程的runloop默认是启动的.因为我们响应交互. 不知道我这样回答是否满足这个问题的答案.如果回答的不对烦请下方评论区留言 告知我将持续改进. 6.隐式动画 &amp; 显示动画区别隐式动画一直存在 如需关闭需设置 显式动画是不存在，如需显式 要开启 只需要观察动画执行完成的结果 比如: 一个简单UIView的frame移动 如果从A点移动到B点 移动完成 回到原始位置就是隐式动画 Core Animation 是显式动画.因为它既可以直接对其layer属性做动画，也可以覆盖默认的图层行为. 7.imageName&amp;imageWithContentsOfFile区别 区别 UIView imageWithContentsOfFile 不同点 会图片缓存到内存中 无缓存 8.什么是离屏渲染 iOS离屏渲染的深入研究 9.多个相同的图片，会重复加载吗不会,GPU有 像素点缓存的mask. 10.图片是什么时候解码的，如何优化是加载到内存中,从UIImge-&gt;CGImage-&gt;CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码. 如何优化自己手动操作图片的编码API CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库. 参考PINRemoteImage或者YYWebImage开源 11.图片渲染怎么优化可以从阴影,圆角入手.帧率,电量,图片的锯齿等等. iOS开发-视图渲染与性能优化 12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决现象是 图形清晰,场景逼真,但是一般arm芯片的GPU 刷新超过60Hz一定会超级费电,手机发热导致降频.FPS降低,因为低能耗电量不足,无法支持GPU高刷新率 解决办法只能用xcode自带工具检测,看渲染过程哪里可以优化. 总结简单回答了一些图形相关的问题,大部分都是iOS离屏渲染,这个地方大家要认真学习.很多资料看起来比较耗时.","link":"/posts/ef543022/"},{"title":"大厂常问iOS面试题--算法篇","text":"1.时间复杂度 时间频度 一个算法执行所耗费的时间,从理论上是不能算出来的,必须上机运行测试才能知道.但我们不可能也没有必要对每个算法都上机测试,只需知道哪个算法花费的时间多,哪个算法花费的时间少就可以了.并且一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n). 时间复杂度 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度. 在各种不同算法中,若算法中语句执行次数为一个常数,则时间复杂度为O(1),另外,在时间频度不相同时,时间复杂度有可能相同,如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同,但时间复杂度相同,都为O(n2). 按数量级递增排列,常见的时间复杂度有： O(1)称为常量级，算法的时间复杂度是一个常数。 O(n)称为线性级，时间复杂度是数据量n的线性函数。 O(n²)称为平方级，与数据量n的二次多项式函数属于同一数量级。 O(n³)称为立方级，是n的三次多项式函数。 O(logn)称为对数级，是n的对数函数。 O(nlogn)称为介于线性级和平方级之间的一种数量级 O(2ⁿ)称为指数级，与数据量n的指数函数是一个数量级。 O(n!)称为阶乘级，与数据量n的阶乘是一个数量级。 它们之间的关系是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)，随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低. 2.空间复杂度 评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。不包括算法程序代码和所处理的数据本身所占空间部分。通常用所使用额外空间的字节数表示。其算法比较简单，记为S(n)=O(f(n))，其中，n表示问题规模。 3.常用的排序算法 选择排序、冒泡排序、插入排序三种排序算法可以总结为如下： 都将数组分为已排序部分和未排序部分。 选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。 冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。 插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 【选择排序】：最值出现在起始端 * * 第1趟：在n个数中找到最小(大)数与第一个数交换位置 * 第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置 * 重复这样的操作...依次与第三个、第四个...数交换位置 * 第n-1趟，最终可实现数据的升序（降序）排列。 * */void selectSort(int *arr, int length) { for (int i = 0; i &lt; length - 1; i++) { //趟数 for (int j = i + 1; j &lt; length; j++) { //比较次数 if (arr[i] &gt; arr[j]) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } }}/** * 【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾 * 第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置 * 第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置 * …… …… * 第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置 */void bublleSort(int *arr, int length) { for(int i = 0; i &lt; length - 1; i++) { //趟数 for(int j = 0; j &lt; length - i - 1; j++) { //比较次数 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }}/** * 折半查找：优化查找时间（不用遍历全部数据） * * 折半查找的原理： * 1&gt; 数组必须是有序的 * 2&gt; 必须已知min和max（知道范围） * 3&gt; 动态计算mid的值，取出mid对应的值进行比较 * 4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1 * 5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1 * */ // 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 int findKey(int *arr, int length, int key) { int min = 0, max = length - 1, mid; while (min &lt;= max) { mid = (min + max) / 2; //计算中间值 if (key &gt; arr[mid]) { min = mid + 1; } else if (key &lt; arr[mid]) { max = mid - 1; } else { return mid; } } return -1;} 4.字符串反转1234567891011121314void char_reverse (char *cha) { // 定义头部指针 char *begin = cha; // 定义尾部指针 char *end = cha + strlen(cha) -1; while (begin &lt; end) { char temp = *begin; *(begin++) = *end; *(end--) = temp; }} 5.链表反转（头差法）.h声明文件 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;// 定义一个链表struct Node { int data; struct Node *next;};@interface ReverseList : NSObject// 链表反转struct Node* reverseList(struct Node *head);// 构造一个链表struct Node* constructList(void);// 打印链表中的数据void printList(struct Node *head);@end .m实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ReverseList.h&quot;@implementation ReverseListstruct Node* reverseList(struct Node *head){ // 定义遍历指针，初始化为头结点 struct Node *p = head; // 反转后的链表头部 struct Node *newH = NULL; // 遍历链表 while (p != NULL) { // 记录下一个结点 struct Node *temp = p-&gt;next; // 当前结点的next指向新链表头部 p-&gt;next = newH; // 更改新链表头部为当前结点 newH = p; // 移动p指针 p = temp; } // 返回反转后的链表头结点 return newH;}struct Node* constructList(void){ // 头结点定义 struct Node *head = NULL; // 记录当前尾结点 struct Node *cur = NULL; for (int i = 1; i &lt; 5; i++) { struct Node *node = malloc(sizeof(struct Node)); node-&gt;data = i; // 头结点为空，新结点即为头结点 if (head == NULL) { head = node; } // 当前结点的next为新结点 else{ cur-&gt;next = node; } // 设置当前结点为新结点 cur = node; } return head;}void printList(struct Node *head){ struct Node* temp = head; while (temp != NULL) { printf(&quot;node is %d \\n&quot;, temp-&gt;data); temp = temp-&gt;next; }}@end 6.有序数组合并.h声明文件 1234567#import &lt;Foundation/Foundation.h&gt;@interface MergeSortedList : NSObject// 将有序数组a和b的值合并到一个数组result当中，且仍然保持有序void mergeList(int a[], int aLen, int b[], int bLen, int result[]);@end .m实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;MergeSortedList.h&quot;@implementation MergeSortedListvoid mergeList(int a[], int aLen, int b[], int bLen, int result[]){ int p = 0; // 遍历数组a的指针 int q = 0; // 遍历数组b的指针 int i = 0; // 记录当前存储位置 // 任一数组没有到达边界则进行遍历 while (p &lt; aLen &amp;&amp; q &lt; bLen) { // 如果a数组对应位置的值小于b数组对应位置的值 if (a[p] &lt;= b[q]) { // 存储a数组的值 result[i] = a[p]; // 移动a数组的遍历指针 p++; } else{ // 存储b数组的值 result[i] = b[q]; // 移动b数组的遍历指针 q++; } // 指向合并结果的下一个存储位置 i++; } // 如果a数组有剩余 while (p &lt; aLen) { // 将a数组剩余部分拼接到合并结果的后面 result[i] = a[p++]; i++; } // 如果b数组有剩余 while (q &lt; bLen) { // 将b数组剩余部分拼接到合并结果的后面 result[i] = b[q++]; i++; }}@end 7.查找第一个只出现一次的字符（Hash查找）.h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;@interface HashFind : NSObject// 查找第一个只出现一次的字符char findFirstChar(char* cha);@end .m实现文件 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;HashFind.h&quot;@implementation HashFindchar findFirstChar(char* cha){ char result = '\\0'; // 定义一个数组 用来存储各个字母出现次数 int array[256]; // 对数组进行初始化操作 for (int i=0; i&lt;256; i++) { array[i] =0; } // 定义一个指针 指向当前字符串头部 char* p = cha; // 遍历每个字符 while (*p != '\\0') { // 在字母对应存储位置 进行出现次数+1操作 array[*(p++)]++; } // 将P指针重新指向字符串头部 p = cha; // 遍历每个字母的出现次数 while (*p != '\\0') { // 遇到第一个出现次数为1的字符，打印结果 if (array[*p] == 1) { result = *p; break; } // 反之继续向后遍历 p++; } return result;}@end 8.查找两个子视图的共同父视图.h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface CommonSuperFind : NSObject// 查找两个视图的共同父视图- (NSArray&lt;UIView *&gt; *)findCommonSuperView:(UIView *)view other:(UIView *)viewOther;@end .m实现文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &quot;CommonSuperFind.h&quot;@implementation CommonSuperFind- (NSArray &lt;UIView *&gt; *)findCommonSuperView:(UIView *)viewOne other:(UIView *)viewOther{ NSMutableArray *result = [NSMutableArray array]; // 查找第一个视图的所有父视图 NSArray *arrayOne = [self findSuperViews:viewOne]; // 查找第二个视图的所有父视图 NSArray *arrayOther = [self findSuperViews:viewOther]; int i = 0; // 越界限制条件 while (i &lt; MIN((int)arrayOne.count, (int)arrayOther.count)) { // 倒序方式获取各个视图的父视图 UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1]; UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1]; // 比较如果相等 则为共同父视图 if (superOne == superOther) { [result addObject:superOne]; i++; } // 如果不相等，则结束遍历 else{ break; } } return result;}- (NSArray &lt;UIView *&gt; *)findSuperViews:(UIView *)view{ // 初始化为第一父视图 UIView *temp = view.superview; // 保存结果的数组 NSMutableArray *result = [NSMutableArray array]; while (temp) { [result addObject:temp]; // 顺着superview指针一直向上查找 temp = temp.superview; } return result;}@end 9.无序数组中的中位数(快排思想).h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;@interface MedianFind : NSObject// 无序数组中位数查找int findMedian(int a[], int aLen);@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970.m实现文件#import &quot;MedianFind.h&quot;@implementation MedianFind//求一个无序数组的中位数int findMedian(int a[], int aLen){ int low = 0; int high = aLen - 1; int mid = (aLen - 1) / 2; int div = PartSort(a, low, high); while (div != mid) { if (mid &lt; div) { //左半区间找 div = PartSort(a, low, div - 1); } else { //右半区间找 div = PartSort(a, div + 1, high); } } //找到了 return a[mid];}int PartSort(int a[], int start, int end){ int low = start; int high = end; //选取关键字 int key = a[end]; while (low &lt; high) { //左边找比key大的值 while (low &lt; high &amp;&amp; a[low] &lt;= key) { ++low; } //右边找比key小的值 while (low &lt; high &amp;&amp; a[high] &gt;= key) { --high; } if (low &lt; high) { //找到之后交换左右的值 int temp = a[low]; a[low] = a[high]; a[high] = temp; } } int temp = a[high]; a[high] = a[end]; a[end] = temp; return low;}@end 10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad { [super viewDidLoad]; NSArray *oriArray = @[@(2),@(3),@(6),@(7),@(22),@(12)]; BOOL isHaveNums = [self twoNumSumWithTarget:9 Array:oriArray]; NSLog(@&quot;%d&quot;,isHaveNums);}- (BOOL)twoNumSumWithTarget:(int)target Array:(NSArray&lt;NSNumber *&gt; *)array { NSMutableArray *finalArray = [NSMutableArray array]; for (int i = 0; i &lt; array.count; i++) { for (int j = i + 1; j &lt; array.count; j++) { if ([array[i] intValue] + [array[j] intValue] == target) { [finalArray addObject:array[i]]; [finalArray addObject:array[j]]; NSLog(@&quot;%@&quot;,finalArray); return YES; } } } return NO;}","link":"/posts/c111eae7/"},{"title":"大厂常问iOS面试题--通知机制解析篇","text":"简述本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。同时也解决了阿里、字节：一套高效的iOS面试题中关于通知的问题，相信看完此文再也不怕面试官问我任何通知相关问题了 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计 问题列表先把之前的问题列出来，详细读完本文之后，你会找到答案 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等） 通知的发送时同步的，还是异步的 NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息 NSNotificationQueue是异步还是同步发送？在哪个线程响应 NSNotificationQueue和runloop的关系 如何保证通知接收的线程在主线程 页面销毁时不移除通知会崩溃吗 多次添加同一个通知会是什么结果？多次移除通知呢 下面的方式能接收到通知吗？为什么 12345// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];复制代码 关键类结构NSNotification用于描述通知的类，一个NSNotification对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性： 12345678910@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;.../* Querying a Notification Object */- (NSString*) name; // 通知的name- (id) object; // 携带的对象- (NSDictionary*) userInfo; // 配置信息@end复制代码 一般用于发送通知时使用，常用api如下： 12- (void)postNotification:(NSNotification *)notification;复制代码 NSNotificationCenter这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而NSNotificationCenter类主要负责三件事 添加通知 发送通知 移除通知 核心API如下： 12345678910// 添加通知- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;// 发送通知- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;// 删除通知- (void)removeObserver:(id)observer;复制代码 NSNotificationQueue功能介绍通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用NSNotificationCenter的发送接口进行发送通知，这么看NSNotificationQueue最终还是调用NSNotificationCenter进行消息的分发 另外NSNotificationQueue是依赖runloop的，所以如果线程的runloop未开启则无效，至于为什么依赖runloop下面会解释 NSNotificationQueue主要做了两件事： 添加通知到队列 删除通知 核心API如下： 123456// 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;// 删除通知，把满足合并条件的通知从队列中删除- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;复制代码 队列的合并策略和发送时机把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义 12345678910111213// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送};// 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) { NSNotificationNoCoalescing = 0, // 默认不合并 NSNotificationCoalescingOnName = 1, // 只要name相同，就认为是相同通知 NSNotificationCoalescingOnSender = 2 // object相同};复制代码 GSNotificationObserver这个类是GNUStep源码中定义的，它的作用是代理观察者，主要用来实现接口：addObserverForName：object: queue: usingBlock:时用到，即要实现在指定队列回调block，那么GSNotificationObserver对象保存了queue和block信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把block抛到指定queue中执行，定义如下： 123456789101112131415161718192021222324252627282930313233@implementation GSNotificationObserver{ NSOperationQueue *_queue; // 保存传入的队列 GSNotificationBlock _block; // 保存传入的block}- (id) initWithQueue: (NSOperationQueue *)queue block: (GSNotificationBlock)block{......初始化操作}- (void) dealloc{....}// 响应接收通知的方法，并在指定队列中执行block- (void) didReceiveNotification: (NSNotification *)notif{ if (_queue != nil) { GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] initWithNotification: notif block: _block]; [_queue addOperation: op]; } else { CALL_BLOCK(_block, notif); }}@end复制代码 存储容器上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的 1234567891011121314151617// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation;复制代码 注册通知正式开始“注册通知”的深入研究，注册通知有几个常用方法，但只需要研究典型的一两个就够了，原理都是一样的 目前只介绍NSNotificationCenter的注册流程，NSNotificationQueue的方式在下面章节单独拎出来解释 接口1直接看源码（精简版便于理解）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*observer：观察者，即通知的接收者selector：接收到通知时的响应方法name: 通知nameobject：携带对象*/- (void) addObserver: (id)observer selector: (SEL)selector name: (NSString*)name object: (id)object { // 前置条件判断 ...... // 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它 o = obsNew(TABLE, selector, observer);/*======= case1： 如果name存在 =======*/ if (name) { //-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name); if (n == 0) { // 不存在，则创建 m = mapNew(TABLE); // 先取缓存，如果缓存没有则新建一个map GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m); ... } else { // 存在则把值取出来 赋值给m m = (GSIMapTable)n-&gt;value.ptr; } //-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节 n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object); if (n == 0) {// 不存在，则创建 o-&gt;next = ENDOBS; GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o); } else { list = (Observation*)n-&gt;value.ptr; o-&gt;next = list-&gt;next; list-&gt;next = o; } }/*======= case2：如果name为空，但object不为空 =======*/ else if (object) { // 以object为key，从nameless字典中取出对应的value，value是个链表结构 n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object); // 不存在则新建链表，并存到map中 if (n == 0) { o-&gt;next = ENDOBS; GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o); } else { // 存在 则把值接到链表的节点上 ... } }/*======= case3：name 和 object 都为空 则存储到wildcard链表中 =======*/ else { o-&gt;next = WILDCARD; WILDCARD = o; }}复制代码 逻辑说明从上面介绍的存储容器中我们了解到NCTable结构体中核心的三个变量以及功能：wildcard、named、nameless，在源码中直接用宏定义表示了：WILDCARD、NAMELESS、NAMED，下面逻辑会用到 建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图 case1: 存在name（无论object是否存在） 注册通知，如果通知的name存在，则以name为key从named字典中取出值n(这个n其实被MapNode包装了一层，便于理解这里直接认为没有包装)，这个n还是个字典，各种判空新建逻辑不讨论 然后以object为key，从字典n中取出对应的值，这个值就是Observation类型(后面简称obs)的链表，然后把刚开始创建的obs对象o存储进去 数据结构关系图 这里就回答了上述问题列表的问题1的一部分，现在梳理下存储关系 如果注册通知时传入name，那么会是一个双层的存储结构 找到NCTable中的named表，这个表存储了还有name的通知 以name作为key，找到value，这个value依然是一个map map的结构是以object作为key，obs对象为value，这个obs对象的结构上面已经解释，主要存储了observer &amp; SEL case2: 只存在object 以object为key，从nameless字典中取出value，此value是个obs类型的链表 把创建的obs类型的对象o存储到链表中 数据结构关系图 只存在object时存储只有一层，那就是object和obs对象之间的映射 case3: 没有name和object这种情况直接把obs对象存放在了Observation *wildcard 链表结构中 接口2源码接口功能： 此接口实现的功能是在接收到通知时，在指定队列queue执行block 123456789101112131415161718// 这个api使用频率较低，怎么实现在指定队列回调block的，值得研究- (id) addObserverForName: (NSString *)name object: (id)object queue: (NSOperationQueue *)queue usingBlock: (GSNotificationBlock)block{ // 创建一个临时观察者 GSNotificationObserver *observer = [[GSNotificationObserver alloc] initWithQueue: queue block: block]; // 调用了接口1的注册方法 [self addObserver: observer selector: @selector(didReceiveNotification:) name: name object: object]; return observer;}复制代码 逻辑说明这个接口依赖于接口1，只是多了一层代理观察者GSNotificationObserver，在关键类结构中已经介绍了它，设计思路值得学习 创建一个GSNotificationObserver类型的对象observer，并把queue和block保存下来 调用接口1进行通知的注册 接收到通知时会响应observer的didReceiveNotification:方法，然后在didReceiveNotification:中把block抛给指定的queue去执行 小结 从上述介绍可以总结，存储是以name和object为维度的，即判定是不是同一个通知要从name和object区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的，问题列表中的第九题也迎刃而解了 理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑 存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次 发送通知源码发送通知的核心逻辑比较简单，基本上就是查找和调用响应方法，核心函数如下 123456789101112131415161718192021222324252627// 发送通知- (void) postNotificationName: (NSString*)name object: (id)object userInfo: (NSDictionary*)info{// 构造一个GSNotification对象， GSNotification继承了NSNotification GSNotification *notification; notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone()); notification-&gt;_name = [name copyWithZone: [self zone]]; notification-&gt;_object = [object retain]; notification-&gt;_info = [info retain]; // 进行发送操作 [self _postAndRelease: notification];}//发送通知的核心函数，主要做了三件事：查找通知、发送、释放资源- (void) _postAndRelease: (NSNotification*)notification { //step1: 从named、nameless、wildcard表中查找对应的通知 ... //step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的 [o-&gt;observer performSelector: o-&gt;selector withObject: notification]; //step3: 释放资源 RELEASE(notification);}复制代码 逻辑说明其实上述代码注释说的很清晰了，主要做了三件事 通过name &amp; object 查找到所有的obs对象(保存了observer和sel)，放到数组中 通过performSelector：逐一调用sel，这是个同步操作 释放notification对象 小结从源码逻辑可以看出发送过程的概述：从三个存储容器中：named、nameless、wildcard去查找对应的obs对象，然后通过performSelector：逐一调用响应方法，这就完成了发送流程 核心点： 同步发送 遍历所有列表，即注册多次通知就会响应多次 删除通知这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载源码看下吧 要注意的点： 查找时仍然以name和object为维度的，再加上observer做区分 因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉 1234567891011121314151617// 删除已经注册的通知- (void) removeObserver: (id)observer name: (NSString*)name object: (id)object { if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil) return; ...}- (void) removeObserver: (id)observer{ if (observer == nil) return; [self removeObserver: observer name: nil object: nil];}复制代码 异步通知上面介绍的NSNotificationCenter都是同步发送的，而这里介绍关于NSNotificationQueue的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了runloop的时机来触发的 入队下面为精简版的源码，看源码的注释，基本上能明白大致逻辑 根据coalesceMask参数判断是否合并通知 接着根据postingStyle参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：_asapQueue、_idleQueue 核心点： 队列是双向链表实现 当postingStyle值是立即发送时，调用的是NSNotificationCenter进行发送的，所以NSNotificationQueue还是依赖NSNotificationCenter进行发送 1234567891011121314151617181920212223242526272829303132333435/** 把要发送的通知添加到队列，等待发送* NSPostingStyle 和 coalesceMask在上面的类结构中有介绍* modes这个就和runloop有关了，指的是runloop的mode*/ - (void) enqueueNotification: (NSNotification*)notification postingStyle: (NSPostingStyle)postingStyle coalesceMask: (NSUInteger)coalesceMask forModes: (NSArray*)modes{ ...... // 判断是否需要合并通知 if (coalesceMask != NSNotificationNoCoalescing) { [self dequeueNotificationsMatching: notification coalesceMask: coalesceMask]; } switch (postingStyle) { case NSPostNow: { ... // 如果是立马发送，则调用NSNotificationCenter进行发送 [_center postNotification: notification]; break; } case NSPostASAP: // 添加到_asapQueue队列，等待发送 add_to_queue(_asapQueue, notification, modes, _zone); break; case NSPostWhenIdle: // 添加到_idleQueue队列，等待发送 add_to_queue(_idleQueue, notification, modes, _zone); break; }}复制代码 发送通知这里截取了发送通知的核心代码，这个发送通知逻辑如下： runloop触发某个时机，调用GSPrivateNotifyASAP()和GSPrivateNotifyIdle()方法，这两个方法最终都调用了notify()方法 notify()所做的事情就是调用NSNotificationCenter的postNotification:进行发送通知 123456789101112131415161718192021222324252627282930313233static void notify(NSNotificationCenter *center, NSNotificationQueueList *list, NSString *mode, NSZone *zone){ ...... // 循环遍历发送通知 for (pos = 0; pos &lt; len; pos++) { NSNotification *n = (NSNotification*)ptr[pos]; [center postNotification: n]; RELEASE(n); } ...... }// 发送_asapQueue中的通知void GSPrivateNotifyASAP(NSString *mode){ notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_asapQueue, mode, item-&gt;queue-&gt;_zone);}// 发送_idleQueue中的通知void GSPrivateNotifyIdle(NSString *mode){ notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_idleQueue, mode, item-&gt;queue-&gt;_zone);}复制代码 小结对于NSNotificationQueue总结如下 依赖runloop，所以如果在其他子线程使用NSNotificationQueue，需要开启runloop 最终还是通过NSNotificationCenter进行发送通知，所以这个角度讲它还是同步的 所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程 主线程响应通知异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？ 其实也是比较常见的问题了，基本上解决方式如下几种： 使用addObserverForName: object: queue: usingBlock方法注册通知，指定在mainqueue上响应block 在主线程注册一个machPort，它是用来做线程通信的，当在异步线程收到通知，然后给machPort发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有 总结本文写的内容比较多，以GNUStep源码为基础进行研究，全面阐述了通知的存储、发送、异步发送等原理，对研究学习有很大帮助","link":"/posts/a5c69c69/"},{"title":"头条-最新iOS面试真题总结","text":"本文汇总了头条iOS面试中的经典真题，涵盖基础知识、算法、架构设计及多线程等方面。内容来源于真实面试经验，适合准备iOS相关岗位面试的同学参考。 温馨提示：本文侧重题目整理，部分知识点可结合官方文档和经典书籍深入学习。欢迎留言交流，互相提升。 一面题目汇总 自我介绍及项目相关介绍 如何自定义导航跳转 Runtime的理解与应用 KVC（键值编码）的用途及原理 Method Swizzling的注意事项 引用计数机制的理解 RunLoop的理解与状态 AutoreleasePool的使用场景 TableView性能优化，如何减少卡顿 属性关键字：copy、assign、retain、weak的区别和使用场景 JSON转Model的实现思路 代码布局规范 多屏幕适配方案 HTTP请求头与响应头解析 Cookie机制 NSCache缓存机制介绍 自己设计一个缓存器的思路 LRU缓存算法的实现方式 SDWebImage的基本原理 二叉树先序遍历（递归和非递归实现） 二面题目汇总 MVC架构存在的缺点 介绍其他架构模式（如MVVM、VIPER等） 常见编码方式（UTF-8、UTF-16等） 字符串翻转算法设计 多线程实现方式及其区别（NSThread、GCD、NSOperation） 队列和线程的关系 线程安全相关题目及解决方案 各种锁的类型及区别（互斥锁、自旋锁、读写锁等） 属性关键字的详细解释 assign是否可以用于OC对象，及其风险 copy与strong的区别 weak是如何实现自动赋nil的 为什么不可变对象属性使用copy更安全 assign在对象中的使用注意点 pod update与pod install的区别 layoutIfNeeded与setNeedsLayout的区别 抓包工具如何抓取HTTPS请求的原理 isEqual与hash方法的关系 Bitmap数据结构介绍 可变数组的实现原理 如何hook一个对象的方法而不影响其他对象 代码中如何避免大量if else写法 自旋锁和互斥锁的区别及使用场景 三面题目汇总 详细介绍项目经验，重点讲自己擅长的技术点 数组copy后，里面的元素是否复制一份新对象？ 浅拷贝和深拷贝的区别与实现方式 TCP为什么是三次握手，四次挥手？原理解析 面试总结头条iOS面试通常采用视频形式，一条龙流程服务较完善。面试内容覆盖基础知识广泛，既有理论考察，也注重实际项目经验和算法能力。建议候选人重点夯实以下方面： Objective-C及Swift语言基础 iOS常用设计模式与架构 Runtime机制和相关技术（如Method Swizzling、消息转发等） 多线程与并发编程（GCD、NSOperation、锁机制等） 网络协议和请求处理（HTTP/HTTPS、TCP/IP） 算法与数据结构基础（字符串处理、树、链表、排序等） 项目经验梳理，能够清晰描述技术细节和难点 欢迎大家收藏与分享，也可以留言补充或提问，一起进步！ 相关资源推荐： 《Objective-C高级编程》 《iOS开发者面试宝典》 Ray Wenderlich iOS教程 LeetCode算法题刷题平台 祝你面试顺利，早日拿到理想offer！","link":"/posts/885f2aac/"},{"title":"字节跳动-最新iOS面试真题","text":"以下内容基于字节跳动iOS面试中真实遇到的题目，涵盖基础知识、算法、网络、多线程和系统设计等多个方面。适合面试准备者系统复习。 一面题目 自我介绍 介绍简历中的一个项目 面向对象的三个要素（封装、继承、多态） 多态的理解 Java、Python、Objective-C运行效率比较 Property详解，copy修饰符如何工作？ Property(nonatomic, copy)修饰NSMutableArray会有什么问题？ copy和mutableCopy的区别 类别（Category）的原理及实现 封装和重载的解释 Objective-C是否支持多重继承？ UITableView的复用原理 UITableView滑动卡顿的优化方法 viewDidLoad和viewDidAppear的调用时机及调用次数差异 页面间传值方式（属性传值、协议、Block、通知、extern全局变量、NSUserDefaults） 通知与代理（delegate）的区别 通知发送和接收是否在同一线程？ HTTP与HTTPS的区别 Objective-C中多线程的几种实现方案 NSURLConnection与NSURLSession的了解 NSURLSession的实现原理 HTTP常见的状态码及含义 编程题：实现二叉树的倒置 二面题目 博弈论题：老虎吃羊问题 算法题：青蛙跳格子问题（斐波那契数列） 熟悉使用的框架介绍 如何实现SDWebImage的二级缓存机制 @autoreleasepool { NSString *s; } 与 NSString *s; 的区别 对autorelease的理解 HTTP的理解 HTTP返回状态码详解 为什么说HTTP是无状态协议 为什么不用原生APNS实现推送 GCD的了解 dispatch_group_t与dispatch_barrier_sync的区别 NSOperation的使用及理解 NSOperationQueue的使用 三面题目 算法题：仅包含三种元素的数组排序，要求时间复杂度O(n) Objective-C程序的编译和链接过程理解 内存管理相关操作（ARC、MRC等） 响应链原理 hitTest方法是否尝试过重写，重写的场景和注意点 HTTP、Session和Cookie的区别和联系 线程和队列的关系 CALayer与UIView的关系和区别 总结字节跳动的iOS面试涵盖了语言基础、架构设计、网络、多线程、算法以及系统底层机制，难度较高，注重应试者对核心概念的理解和实际编码能力。建议结合项目经验，系统复习基础知识和算法，熟悉面试中常见的设计题和编程题，提升解决问题的思路和表达能力。 推荐复习资料： 《Objective-C高级编程》 《iOS开发者面试宝典》 LeetCode经典算法题库 Apple官方文档关于Runtime和内存管理章节 祝你面试顺利，成功拿到Offer！","link":"/posts/5a0f7207/"},{"title":"快手-最新iOS面试真题总结","text":"背景面的是快手X3岗位，视频面试，不支持周末，但是可以选择晚上时间。视频面试是通过牛客网进行的，以下是记下来的各轮面试题，对于一些iOS基础知识就不做解答了。 一面1、用递归写一个算法，计算从1到100的和。 1234567891011func sum(value: Int) -&gt; Int { if value &lt;= 0 { return 0 } var number = value return value + sum(value: number - 1)}// 计算过程let result = sum(value: 100)print(result)复制代码 写完算法之后又围绕着问了几个问题，都是算法基础： 算法的时间复杂度是多少 递归会有什么缺点 不用递归能否实现，复杂度能否降到O(1) 2、property的作用是什么，有哪些关键词，分别是什么含义？ 3、父类的property是如何查找的？ 4、NSArray、NSDictionary应该如何选关键词？ 5、copy和muteCopy有什么区别，深复制和浅复制是什么意思，如何实现深复制？ 6、用runtime做过什么事情？runtime中的方法交换是如何实现的？ 7、讲一下对KVC合KVO的了解，KVC是否会调用setter方法？ 8、__block有什么作用 9、说一下对GCD的了解，它有那些方法，分别是做什么用的？ 10、对二叉树是否了解？ 面试官是想接着问这方面的问题的。我当时说了不了解，然后就没有后续了。 二面1、ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？ 2、在MRC下执行[object autorelease]会发生什么，autorelease是如何实现的？ 3、OC如何实现多继承？ 这个当时没有答好。其实借助于消息转发，protocol和类别都可以间接实现多继承。 4、对设计模式有什么了解，讲一下其中一种是如何使用的。 5、有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。 6、一张100*100，RGBA的png图像解压之后占多大内存空间。 5、算法题 题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。 这个并没有要求写出来，说是提供思路就行了。我当时给的方案是在便利数组的时候，用一个字典把便利的元素存起来，如果在后面的便利过程中新元素在字典中存在过就说明，有重复数字出现。时间复杂度是O(n)。 当时也问了有没有办法进行优化，我当时想到了将数组转成Set，然后和原数组比较，两个集合的数量是否变化。 7、因为我跟他介绍自己Swift用的多一些，然后问了些Swift跟OC的区别，各自的优缺点。 8、为什么离职，有什么职业规划。 三面1、给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。 123输入: [3,30,34,5,9]输出: 9534330复制代码 这个是leetcode的179题，难度中等。面试官让先说思路，再去做题。事先说一下这个题我没有做过。当时的思路是用冒泡法进行排序，排序的前提是将较少位数的数字进行循环补齐，例如3和30的比较，变成33和30的比较，34和4的比较变成34和44的比较，然后将结果从大到小整合成字符串输出。 但是做题是却发现没那么简单，位数的补齐对于2位和3位数的比较还需要求位数的最小公倍数，将他们都转成6位数才能比较。在挣扎了5分钟做了就做罢了。 后来再去做这道题，其实这就是一个排序而已，只不过他的规则是按高位优先级更高的原则，而这一点跟字符串的比较保持一致，如果再加一些Swift的高阶函数，就可以写成： 123456789101112func largestNumber(_ nums: [Int]) -&gt; String { let sort = nums.map {&quot;\\($0)&quot;}.sorted { (lStr, rStr) -&gt; Bool in return lStr + rStr &gt; rStr + lStr } let result = sort.joined() if result.prefix(1) == &quot;0&quot; { return &quot;0&quot; } else { return result }}复制代码 2、项目中有这么一个方法func findfile(dir: String suffix: String) -&gt; [String] ，可以通过输入文件夹目录，和后缀检索出所需的文件。 例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？ 我首先想到的是这么多需求不可能一个方法就完成，需要根据不同场景拆出不同的方法，但是这些同属于文件操作，会有一个共同使用的方法就是检索文件。这个方法需要传入文件目录，然后递归的返回当前目录所有文件路径。外部不同场景的调用逻辑就用一个enum完成，不同值对应相同范围的不同种类。 面试官比较关注内部共用的文件检索怎么写，他说子文件如果过多怎么办，如何优化。我有点懵，查找文件至少是要遍历一遍的，子文件过多，这个应该是没法优化的啊。中间卡了一段时间，后来他给了提示说是不是可以用block实现，将文件路径返回出去，由外部决定当前文件是否可用，最终外部的调用类是这个样子。 12345//我的方案//func findDir(_ dir: String) -&gt; [String]//block方案func findDir(_ dir: String, block: ((String) -&gt; Bool))复制代码 我想来确实没毛病，用block返回内容至少不会将该目录的所有文件都由一个对象持有，而前面一堆的铺垫其实也都是为验证block方案的好处。 其实事后想下这个问题没啥难的，这种写法自己也有写过，但当时就是没想起来，可能前面一圈的铺垫给我带偏了吧，说亏也不亏，以后多多努力吧。 总结 整体来看，快手的面试题跟我在别处看到的iOS面试题对比要简单些。一面主要是基础知识，二面考察更全面一些，更多让自己谈一些对技术的理解，三面则是更偏实践一些。 算法虽然三轮都有，但相对比较简单，即使写不出来，有思路也是可以的。当然写出来肯定是加分项，所以大家准备面试时，应该都看一下。算法相关的，排序，数组，二叉树，这几类是重点。","link":"/posts/1fe28a79/"},{"title":"常见 iOS 面试真题汇总（基础、实战、系统、网络、架构全覆盖）","text":"（持续更新）前言近期的 iOS 面试求职可以说是经历了一波小高潮。话不多说，下面是我精心整理的一份 iOS 面试真题合集，覆盖各类公司常问问题，供大家查缺补漏。 面试题目录 iOS 基础题 iOS 实战题 网络通信题 计算机系统题 设计模式题 架构设计题 数据结构与算法题 补充题 1、iOS 基础题 分类（Category）和扩展（Extension）的区别及使用场景？ atomic 的实现机制？为什么不能保证线程安全？ __weak 修饰符的释放过程？SideTable 的结构与作用？ AutoreleasePool 的数据结构及 AutoreleasePoolPage 的底层分析 对象、类对象、元类的关系？为什么方法存在类对象中？ Objective-C 中的内省方法、class 与 objc_getClass 区别？ RunLoop 的作用及内部机制？与线程/内存管理的关系？ 离屏渲染的触发场景及性能影响？ 2、iOS 实战题 NSOperation 相比 GCD 的优势和使用场景？ App 启动优化策略（main 函数前后阶段分析） 无埋点埋点系统的实现思路？应具备哪些特性？ App 崩溃场景分析与处理手段 App 卡顿的原因与性能优化方法（如帧率监测、主线程任务分离等） 3、网络题 App 网络层优化策略有哪些？（缓存、压缩、重试机制等） TCP 三次握手、四次挥手原理？为何必须三次？ HTTPS 握手流程、非对称加密使用原因、双向认证？ HTTPS 如何校验身份与数据完整性？ 如何用 Charles 抓取 HTTPS 请求？中间人证书原理？ 4、计算机系统题 编译过程的各个阶段（预处理、编译、汇编、链接） 静态链接 vs 动态链接？.a 和 .dylib 区别？ static 与 const 的区别与使用场景？ 死锁出现的四个条件？如何预防？ 常见锁的类型、底层实现、性能对比与适用场景？ 5、设计模式题 除了单例、观察者，还了解哪些设计模式？ iOS SDK 中使用的设计模式示例（MVC、代理、组合等） 每种设计模式的参与角色与交互机制？ 6、架构 &amp; 设计题 MVC、MVVM、MVP 的本质区别与优缺点？ 面向对象的 SOLID 原则？如何在项目中落地？ 常见重构技巧？重构的时机与作用？ 框架 vs 设计模式 的本质区别？ 三方框架源码分析（如 AFNetworking、Masonry、SDWebImage）与设计思想总结 7、数据结构 &amp; 算法题 链表与数组的区别？插入/查找复杂度？ 哈希表结构、冲突解决方法（开放定址、链式散列等） 排序算法手写：冒泡、选择、插入、快速排序（二路/三路） 链表题：判断链表有无环；删除特定值节点 数组题：有序数组中找和为指定值的两个数；合并有序数组 二叉树题：反转二叉树；判断两个二叉树是否相等 8、额外补充（进阶 &amp; 冷门） UIView 与 CALayer 的关系？drawRect 是否影响性能？ UIImageView 如何显示超大图并支持缩放？ fishhook 如何工作？为何不能修改静态链接库符号？ C++ 虚函数调用 vs Objective-C 消息发送机制？ placement new 是什么？OC 中如何实现？ ARC 下 C++ 容器如何管理 Objective-C 对象？ id、self、super 的语法差异？ isa 指针结构和作用？ Block 修改变量除了 __block 还有什么方法？ NSDictionary 和 NSHashTable 区别与场景？ Swift 中 String.Index 的设计优缺点？ TCP 长连接断网后服务器是否能立即感知？ Wireshark 抓不到 SSL 原始数据的原因？ backtrace 的实现原理？用户态 or 内核态？ malloc 指针 double free 与访问 freed 指针的异常区别？ RunLoop 是死循环吗？为何不会卡死系统？ Runtime 源码中的 fastpath/slowpath 机制？ Runtime 中 SideTable 的用途？ Objective-C 如何实现系统升级下的 ABI 稳定性？ 结语刷题只是准备面试的一部分，更关键的是理解每一个问题背后的原理与设计理念。在找工作的同时，不断提升技术深度，整理项目亮点，打磨软实力，才能真正从容应对。 ✨ 祝每位正在准备 iOS 面试的开发者都能收获满意的 offer！你值得更好的舞台！","link":"/posts/22297147/"},{"title":"抖音最新 iOS 面试真题汇总（2024年一二三面完整整理）","text":"本文整理了抖音 iOS 面试过程中遇到的最新真题汇总（涵盖一面、二面、三面），内容涉及数据结构、网络协议、系统架构、iOS 多线程、性能优化、底层原理等多个模块，适合准备大厂 iOS 岗位的开发者系统复习。 🙋 面试前说明由于时间有限，未能对所有题目撰写详解答案，但整体内容覆盖全面，记录了真实的面试题与准备过程，希望能为正在面试或准备面试的同学提供参考与帮助。欢迎交流讨论。 📌 一面面试题（技术基础 + 网络 + 多线程） 求二叉树两个节点的最近公共父节点 输入两个节点，可能为 null，可能不在树中。 反转链表（经典算法题） HTTP 基础与 HTTP/2.0 新特性 多路复用、二进制帧、服务器推送等。 iOS9 - iOS13 每个版本说一个新特性 iOS 9：App Transport Security iOS 10：UserNotifications 框架 iOS 11：大文件下载、拖拽 iOS 12：性能优化，Screen Time iOS 13：深色模式、Combine 框架、SwiftUI 多个任务执行完后统一处理的方法有哪些？ 使用 dispatch_group、信号量 dispatch_semaphore、栅栏 dispatch_barrier_async 不用 SDWebImage 如何实现图片加载与缓存？ 图片下载 → Memory Cache + Disk Cache → 显示 简述 SDWebImage 核心架构：异步下载 + 缓存策略 + HashKey 管理 TableView 中多个 Cell 同时请求同一个图片 URL，如何避免重复请求？ 请求去重（缓存或 URL 任务池） 建立 url-task 映射池，任务完成后统一回调更新所有 UIImageView 滑动 TableView 时，GIF 动图为何不动？ RunLoop 切换为 UITrackingRunLoopMode，暂停了 NSDefaultRunLoopMode 下的任务 了解 WebSocket 吗？说一下作用和使用场景 长连接协议，适用于实时通讯（如 IM、弹幕、直播互动等） 📌 二面面试题（系统设计 + 网络协议 + 多线程） 如何不用递归遍历 UIView 的所有 subviews？ 使用栈结构模拟 DFS 或 BFS 设计一个图片缓存系统（Memory + Disk）并代码实现 可借鉴 NSCache + 沙盒持久化逻辑 介绍 Clang/LLVM 静态分析的基本原理 AST 抽象语法树 → 语义分析 → 规则检测（如 Xcode 的静态分析功能） 计算机网络的七层协议栈简述 HTTP 属于哪一层协议？ 应用层协议 HTTP 常见返回码及含义？ 200 OK、301/302 重定向、403 禁止访问、404 找不到资源、500 服务器错误 HTTP 除了 GET/POST，还有哪些方法？ PUT、DELETE、HEAD、OPTIONS、PATCH HTTPS 简要介绍 基于 HTTP + TLS/SSL 加密协议 包含对称加密、非对称加密、数字证书 HTTPS 能防止中间人攻击吗？为什么？ 是的。通过证书校验和加密通信防止篡改与监听 TCP 与 UDP 的区别？ 线程与进程的区别？ 线程之间如何通信？ 不用 GCD 如何保证线程安全？ 使用锁机制（如 NSLock、pthread_mutex） iOS 多线程实现方式有哪些？ NSThread、GCD、NSOperationQueue 同步与异步的区别？ 串行队列与并发队列区别？ 队列和线程的关系？ 死锁是如何产生的？有哪些必要条件？ 互斥、请求保持、不可剥夺、循环等待 📌 三面面试题（网络底层 + 性能优化 + 系统架构） 合并两个有序链表（LeetCode 经典题） HTTPS 使用对称加密还是非对称加密？ 握手阶段用非对称，通信阶段用对称加密 TCP 的慢启动、拥塞控制、快重传介绍 客户端发起网络请求到响应的全过程？ DNS解析 → TCP握手 → HTTPS握手 → 发送请求 → 接收响应 → 渲染页面 DNS 查询过程中的 ISP 服务器不可用，会怎样？ 递归或迭代请求下一级 DNS 服务器，如根域名服务器 → 顶级域名服务器 → 权威 DNS 字典转模型的架构设计 + 夜间模式的设计 字典转模型可采用 KVC、Swift Codable 夜间模式基于主题管理中心/通知机制更新 UI 为何不使用第三方库如 YYModel、MJExtension？ 可控性差、不灵活、依赖大，调试困难 自定义方案更轻量、更好维护 夜间模式的缺点与优化？ 缺点：耗电、维护成本高 优化：使用动态色值、样式隔离 iOS 中的锁有哪些？ OSSpinLock（已废弃）、NSLock、@synchronized、dispatch_semaphore、pthread_mutex 常见数据存储方式？你项目中怎么用的？ UserDefaults、Plist、Keychain、SQLite（FMDB） 线程安全错误的常见表现？ 数据竞争、崩溃、数据错乱，常发生在 UI 更新或共享资源访问时 ✅ 总结：抖音 iOS 面试知识结构梳理 模块 涉及题型 数据结构 链表反转、合并链表、树的最近公共祖先 网络 HTTP/2、HTTPS、WebSocket、TCP/UDP、七层协议 多线程 GCD、信号量、栅栏、死锁、线程通信 系统设计 图片缓存系统、夜间模式、字典转模型 工具原理 LLVM、静态分析 项目经验 SDWebImage 实现、缓存优化、DNS 故障处理 🧠 建议准备： 常见算法题练熟（链表、二叉树、排序） 网络协议 &amp; HTTPS 握手过程深入理解 多线程调度机制（GCD、NSOperation）掌握细节 项目经验表达清晰，能举出优化点 iOS 系统架构底层原理适当了解 📎 如果你正在准备 iOS 面试，欢迎点赞收藏，持续更新更多真题汇总与答案详解。","link":"/posts/320dce05/"},{"title":"教你炒股票10：2005年6月，本ID为何时隔四年后重看股票","text":"2001年6月后，本ID就从未看过股票，直到2005年6月。本ID是严重反对人民币升值的， 曾写有“货币战争和人民币战略”在网上广泛流传。但到2005年6月，本ID知道有些事情不是人力可为的， 天要下雨、娘要嫁人，LET IT BE吧。所以2005年6月，本ID时隔四年后重看股票。 在强国论坛的人都知道，2005年6月最暴跌时，本ID连续三次罕有地表扬一个政府官员， 就是股市当时的新人、如今那位著名的山东人。 其后还专门写文章为他说股改“开弓没有回头箭”而热烈鼓掌。 同时，本ID却曾写过这样的文章“群狼争肉—-国有股流通与国有资产蚕食、瓜分游戏！”。 这，难道是本ID逻辑混乱、前后矛盾吗？ 非也，这就是昨天本ID所解释的〈论语〉里“子曰：众，恶之，必察焉；众，好之，必察焉”的完美应用。 确实，从好恶角度，本ID严重反对人民币升值、反对国有股流通， 而且深刻地分析了这些玩意后面的现实逻辑关系和严重后果。但在股市里，本ID从来没有好恶。 只要有点金融常识的人都知道，本币的历史性升值所带来历史性牛市曾被太多国家所经历。 本ID只知道，一旦人民币升值、国有股流通，股市将大涨。知识分子为什么可笑，就是有好恶而无“察”， 企图以理论来理论现实，十足脑子水太多了。 书呆子是不适宜投资市场的，错了，应该是投机市场。别相信这世上有什么投资市场， 世界本身都是投机的，还有什么资可投？就像有人号称所谓爱情，而所有的爱情， 都不过是遮掩性游戏谎言的一条内裤而已。所有的性游戏都可以用这样的数学表达式表示：4N9。 N代表从0到无穷的自然数，0等于没搞上，无穷等于天长地久也就是废话，1等于一夜情419， 所有的性游戏包括爱情，都被这样一个数学表达式表示了。那么，任何一个投资者和股票的性关系， 也完全可以以此表示。任何股票和你，都不过是一个4N9的关系，可以投机的就是这个N， 如果你能在这个N里把一只股票当面首一样采尽他的精气，那你就是高手了。其后再换一个继续N2的游戏， 如果该游戏可以新戏不断，而你又能采之而不被采，那你就是高手中的高手了。 世界就那么简单，别把自己搞糊涂了。 股票，恶之，必察焉；股票，好之，必察焉。由孔子的话，不难明白以上的道理，而明白这道理， 就明白投机市场第一原则“只搞能搞的”所依。智慧都是相通的，“只搞能搞的”，而不是“只搞喜欢的”。 能搞是需要“察”而得之，不是靠喜好厌恶而来的。随便在市场里抓一个人，问他为什么买手里的股票， 一万个人有9999个告诉你因为他的股票如何如何好，这种人能在市场上长久活下来就世界最大奇迹了。 本ID从来不觉得自己手里的股票有什么好，只知道他们能搞。 但几乎所有的人，包括庄家、散户，都喜欢为自己股票的好找理由。别以为庄家就不这样， 庄家里的傻人从来不比散户少，本ID见多了。这些人，拿了股票就到处找理由为其持有、上涨编故事， 就算股票已经从10跌到1了，还乐此不疲。市场里所有亏损，都是因为持有了不能搞的股票而造成的。 但无论任何股票，能搞总是相对的，不能搞却是绝对的，就像4N9里，如果你为了某面首把N设成无穷， 那么劝你自杀吧，因为你活也白活了，你已经不是人，而是某面首的附属物。 N只能有限地给予一个固定的能搞对象，有N1，就要有N2，这样才能生生不息，才能风生水起。 但在4N9任意一段N中，这面首、这股票就是你的全部，你要全身心地投入去“察”去“采”，投机市场， 机会总是一闪而过，别到白天才问夜的黑，那什么菜都凉了。能搞是相对的， 意味着随时能搞就会变成不能搞。一旦这“机”失去了，就会在不能搞的泥潭难以自拔。 无论对面首或股票，都要全身心地往死里干然后抛弃，这是不能偏废的两方面， 任何的失败者都一定是至少在其中一面失败了。 在4N9的任何一段N中，可以有世界上最浪漫的故事、最火热的缠绵，有无数的细节， 从前戏到缠绵到进入到高潮到不应到抛弃，所有的故事只是唯一的故事， 就像所有的AV都只有同一的情节。从下一期开始，我们将仔细分析同一AV情节的每一个细节， 让每一细节深入你心，成为本能的反应，然后才能成为AV主角，在每一段4N9中高潮迭起，采阳不休。","link":"/posts/51527/"},{"title":"拼多多最新iOS面试真题总结（JSON解析、多线程、安全性、架构设计）","text":"本文整理了拼多多 iOS 岗位面试中常见的真题，涵盖 JSON 转模型、夜间模式、架构设计、多线程安全、Block 机制等重点知识，适合拼多多及其他互联网公司 iOS 面试准备参考。 一面题目 JSON 转模型实现方式 讨论如何将服务器返回的 JSON 数据转换为本地模型对象，涉及手写、第三方库（如 YYModel、MJExtension）等实现方式。 夜间模式设计 如何设计和实现夜间模式，切换颜色、样式及避免 UI 重绘卡顿。 播放器架构设计 简述播放器的模块划分、数据流及解码流程。 请求流程 网络请求从发起到接收响应的整个过程，包括 DNS 解析、TCP 连接、HTTP 协议。 服务端返回数据格式 除 JSON 外，还有哪些格式（XML、Protobuf、Thrift 等）。 哪些 Objective-C 对象是线程安全的 例如 NSString、NSArray 的不可变版本是线程安全的。 为什么要在主线程更新 UI UIKit 线程模型及主线程限制。 如何保证 OC 容器在多线程下的数据安全性 使用锁机制、线程安全的集合类或 GCD。 SDWebImage 内存设计及更新原则 缓存策略、内存缓存与磁盘缓存的区别及更新时机。 算法题 判断括号匹配性（如 ()[]{} 是否匹配） 只有一种括号的情况下，计算最少需要加多少括号才能满足匹配 二面题目 +load 和 +initialize 的理解与调用时机 讨论两者区别、调用顺序，父类与子类重写情况。 Objective-C 的动态性理解 运行时机制、消息发送、动态绑定。 消息转发机制及系统 API 消息重定向过程、forwardInvocation:、methodSignatureForSelector: 等。 Block 的理解 定义、使用场景。 Block 的变量捕获机制 变量如何捕获，捕获的变量类型（全局、栈、堆）。 __block 关键字实现原理 允许变量被修改，底层实现细节。 内存管理机制 ARC、MRC 的基本原理，引用计数机制。 用户点击屏幕后系统事件响应流程 如何找到触摸点对应的 View，事件传递链（Hit Testing 机制）。 总结拼多多 iOS 面试注重基础扎实，涵盖数据解析、多线程安全、内存管理和运行时机制等方面，建议重点复习： JSON 与模型映射技巧 夜间模式和架构设计思路 Objective-C 运行时和消息机制 Block 和变量捕获原理 多线程下数据安全设计 iOS 事件响应机制 欢迎大家留言交流，探讨更多面试技巧和知识点。祝你面试顺利，成功拿下拼多多 iOS 岗位！","link":"/posts/d7c5f517/"},{"title":"教你炒股票11：不会吻，无以高潮！","text":"甄别“早泄”男，必须要选择三个独立的系统。其中一个最常用的，就是所谓的技术派玩意。 单纯的技术派是不行的，单纯的非技术派也是不行的。技术派的玩意，必须也只能在三个独立系统里，才会有大的功效。 技术分析，最核心的思想就是分类，这是几乎所有玩技术的人都搞不清楚的一点。 技术指标发出买入信号，对于技术派来说，就以为是上帝给了暗示一般，抱着如此识见，几乎所有技术派都很难有大的成功。 技术指标不过是把市场所有可能的走势进行一个完全的分类，为什么技术派事后都是高手，真正干起来就个个阳痿，就是这个原因。 技术分析可说的东西太多了，这指标那指标，如何应用，关键就是上面所说的分类问题。 任何技术指标，只是把市场进行完全分类后指出在这个技术指标的视角下，什么是能搞的，什么是不能搞的，如此而已。 至于这个指标对应的情况是否百分百反映在实际的走势上，这个问题的答案肯定是否定的， 否则所有的人都可以按照这指标操作，哪里还有亏钱的人？ 然而，只要站在纯粹分类的角度考察技术指标，那么，技术指标就会发挥他最大的威力。 最简单又最实用的技术指标系统就是所谓的均线系统。均线系统显然不是一个太精确的系统，太多的骗线。 如果你按照突破某条均线就买入操作，反之卖出，那你的成功率绝对不会高，特别当这条均线是短期的。 真正有用的是均线系统，也就是由若干条代表短、中、长期走势的均线构成的技术评价系统。 注意，任何技术指标、系统，本质上都是一个评价系统，也就是告诉你在这个系统的标准下，评价对象的强弱。 例如，一条5日均线，站在上面，代表着用5日均线对市场所有情况进行分类， 目前站在5日均线上这种情况意味着是强势。 然而，站在5日均线上的同时，可能对于10日均线是在其下， 那对于10日均线的系统评价，这种情况就是弱势了， 那究竟相应的走势是强还是弱？ 其实，强弱都是相对的，关键是你操作所介入的标准。 对于超超短线来说，在1分钟线上显示强势就可以介入了，特别在有T+0的情况下，这种操作是很正常的。 但对于大资金来说，就算日线上的5日强势也不足以让他们感兴趣。 任何技术指标系统的应用，首要的选择标准都和应用的资金量和操作时间有关， 脱离了这个，任何继续的讨论都没有意义。 因此，每个人都应该按照自己的实际情况来考虑如何去选择相应的参数， 只要明白了其中的道理，其应用完全在于一心了。 均线系统，必然有着各条均线间的关系问题，任何两条均线的关系，其实就是一个“吻”的问题。 按“吻”的标准，可以把相应的关系进行一个完全分类：飞吻、唇吻、湿吻。 把短期均线当成是女王，长期均线当成面首，那么“男上位”意味着空头市场，而“女上位”意味着多头市场， 要赚钱，就要多来点“女上位”。 飞吻：短期均线略略走平后继续按原来趋势进行下去。 唇吻：短期均线靠近长期均线但不跌破或升破，然后按原来趋势继续下去。 湿吻：短期均线跌破或升破长期均线甚至出现反复缠绕，如胶似漆。 飞吻出现的几率比较少，一般都是在趋势特别强烈的时候， 而太火暴的趋势是不可能太长久的，所以其后的震荡经常出现； 唇吻，任何一段基本的趋势过程中最常见到的方式，特别在“男上位”的情况下，基本都是这种方式， 一旦出现唇吻反弹基本就该结束了，在“女上位”的情况下，调整结束的概率也是很大的， 但也要预防唇吻演变成湿吻； 湿吻，一段趋势后出现的较大调整中，还有就是在趋势出现转折时，这种情况也很常见， 特别是在“男上位”的情况下，如果出现短、中、长各类均线来一个NP的湿吻， 这么情色的AV场景往往意味着行情要出现重大转折，要变天了，“男上位”要变成“女上位”了。 注意，任何的行情转折，在很大几率上都是由湿吻引发的，这里分两种情况： 一种是先湿吻，然后按原趋势来一个大的高潮，制造一个陷阱，再转折； 另一种，反复湿吻，构造一个转折性箱型，其后的高潮，就是体位的转化了。 在“男上位”的情况下，一旦出现湿吻，就要密切注意了，特别是这个湿吻是在一个长期“男上位”后出现的， 就要更加注意了，其后的下跌往往是介入的良机，因为空头陷阱的概率简直太大了。 必须提醒，这一点对趋势形成的第一次湿吻不成立。 但湿吻之后必有高潮，唯一的区别只是体位的区别，关键判断的是体位而不是高潮的有无。 会吻，才有高潮，连吻都不会，怎么高潮呢？","link":"/posts/52114/"},{"title":"教你炒股票12：一吻何能消魂？","text":"就算是看AV，最终也是为了实战。上章说了那么多关于“吻”的知识，目的是为了干而不看，光看不干，那不成了阴九幽？ AV看多了而不实践，绝对有损健康。但干，马上要遇到的就是风险问题。 任何一个位置介入，都存在风险，而且除非行情走出来了， 否则即使最简单的均线系统，也没人能事先百分百地确认究竟采取怎样的方式去“吻”。 熟悉本ID所解《论语》的都知道，风险是“不患”的，是无位次的， 任何妄求在投资中的绝对无风险，都是痴心妄想。唯一的办法， 就是设置一个系统，使得无位次、“不患”的风险在该系统中成为有位次，“患”的系统， 这是长期战胜市场的唯一方法。 必须根据自己的实际情况，例如资金、操作水平等等，设置一套分类评价系统， 然后根据该系统，对所有可能的情况都设置一套相应的应对程序， 这样，一切的风险都以一种可操作的方式被操作了。 而操作者唯一要干的事情，就是一旦出现相应的情况，采取相应的操作。 对于股票来说，实际的操作无非三种：买、卖、持有。 当然，在实际中，还有一个量的问题，这和资金管理有关，暂且不考虑。 那么，任何投资操作，都演化成这样一个简单的数学问题： N种完全分类的风险情况，对应三种（买、卖、持有）操作的选择。 例如，对于一个简单的，由5日均线与10日均线构成的买卖系统， 首先，两者的体位构成一个完全分类，女上位是牛，男上位是熊， 还有一种是互相缠绕的情况，这种情况最终都要演化成女上位或男上位， 只有两种性质：中继或转折。 相应，一个最简单的操作系统就此产生， 就是在体位互相缠绕完成后介入， 对于多头来说，这样一个系统无非面临两个结果，变为女上位成功，变为男上位失败。 由于缠绕若是中继就延续原体位，若转折就改变体位， 因此对多头来说，值得介入的只有两种情况：男上位转折，女上位中继，空头反之。 对于任种走势，首要判断的是体位：男上位还是女上位。 这问题只要有眼睛的都能判断出来，对于5日、10日的均线系统来说，5日在上就是女上位，反之就是男上位， 这在任何情况下都是明确的。 如果是女上位的情况，一旦出现缠绕，唯一需要应付的就是这缠绕究竟是中继还是转折。 可以肯定地说，没有任何方法可以百分百确定该问题， 但还是有很多方法使得判断的准确率足够高。 例如，女上位趋势出现的第一次缠绕是中继的可能性极大， 如果是第三、四次出现，这个缠绕是转折的可能性就会加大； 还有，出现第一次缠绕前，5日线的走势必须是十分有力的，不能是疲软的玩意， 这样缠绕极大可能是中继，其后至少会有一次上升的过程出现； 第三，缠绕出现前的成交量不能放得过大， 一旦过大，骗线出现的几率就会大大增加， 如果量突然放太大而又萎缩过快， 一般即使没有骗线，缠绕的时间也会增加，而且成交量也会现在两次收缩的情况。 女上位选择第一次出现缠绕的中继情况，而男上位的就相反， 要寻找最后一次缠绕的转折情况，其后如果出现急跌却背弛，那是最佳的买入时机。 抄底不是不可以，但只能选择这种情况。 然而，没有人百分百确认那是最后一次缠绕， 一般，男上位后的第一次缠绕肯定不是， 从第二次开始都有可能，如何判断， 最有力的就是利用好背弛制造的空头陷阱。 关于如何利用背弛，是一个专门的话题，以后会详细论述。 综合上述，利用均线构成的买卖系统， 首先要利用男上位最后一次缠绕后背弛构成的空头陷阱抄底进入， 这是第一个值得买入的位置， 而第二个值得买入或加码的位置，就是女上位后第一次缠绕形成的低位。 站在该系统下，这两个买点的风险是最小的，准确地说， 收益和风险之比是最大的，也是唯一值得买入的两个点。 但必须指出的，并不是说这两个买点一定没有风险， 其风险在于：对于第一个买点，把中继判断为转折，把背弛判断错了； 对于第二个买点，把转折判断成中继。 这些都构成其风险，但这里的风险很大程度和操作的熟练度有关， 对于高手来说，判断的准确率要高多了， 而如何成为高手，关键一点还是要多干、看、参与，形成一种直觉。 但无论高手还是低手，买点的原则是不变的， 唯一能高低的地方只是这个中继和转折以及背弛的判断。 明白了这一点，任何不在这两个买点买入的行为都是不可以原谅的， 因为这是原则的错误，而不是高低的区别， 如果你选择了这个买卖系统，就一定要按照这个原则了。 买的方式明白了，卖就反过来就可以了，这是十分简单的。 一吻而消魂，学会这消魂之吻，就能在动荡的市场中找到一个坚实的基础。 当然，相应的均线的参数可以根据资金量等情况给予调节， 资金量越大，参数也相应越大，这要自己去好好摸索了。 这点，对于短线依然有效，只是把日线改为分钟线就可以了。 一旦买入，就一直持有等待第一个卖点， 也就是女上位缠绕后出现背弛； 第二个卖点也就是变成男上位的第一个缠绕高点把东西卖了， 这样就完成一个完整的操作。 注意，买的时候一般最好在第二个买点，而卖尽量在第一个卖点， 这是买和卖不同的地方。 补充一个例子让不习惯抽象的人能理解： 对于喜欢用日线的，用茅台为例子给一个分析，5日和10日。 8月7日，男上位的第二次缠绕后下跌， 但成交量等都明显出现背弛，构成小的空头陷阱，成为第一个买点在41元附近。 9月14日，女上位的第一次缠绕下跌形成第二个买点在44元附近。 然后基本就沿着10日线一直上涨，即使是短线，10日线不有效跌破就继续持有等待第一个卖点， 也就是缠绕后出现背弛的出现。 第二个卖点就是变成男上位的第一个缠绕的高点， 目前这一切都没出现，所以就持有等待出现。 再补充一句： 希望来这里的人，以后慢慢少点诸如要涨多少要跌多少之类的问题， 因为这类问题都是错误的思维下产生的。 本ID不是股评，不是算命先生，才没兴趣猜测上升、下跌的空间， 本ID只是一个观察者，只在买点出现时介入，然后持有等待卖点的出现，其他本ID一律没兴趣。 来这里，如果最终不能脱胎换骨，在投资上换一副眼睛，那你就白来了。","link":"/posts/26667/"},{"title":"教你炒股票14：喝茅台的高潮程序！","text":"前面说了很多理论上的东西，现在用一个实际的股票来说明一下具体的用法。就用茅台吧，边喝茅台边上课。 这里先假设所有看的人都能找到茅台上市以来的周线和日线图。 前面说过两条均线间“吻”的三种方式，其中的湿吻是最明显的缠绕例子， 而飞吻和唇吻是缠绕的特殊例子，在均线操作系统中所指的缠绕，包括这三种吻。 而从实际的比例看，湿吻出现的几率是最大的，但在长期均线系统中，例如周线、月线等，唇吻的例子比例也很大。 先复习一下相关定义： 飞吻：短期均线略略走平后继续按原来趋势进行下去。 唇吻：短期均线靠近长期均线但不跌破或升破，然后按原来趋势继续下去。 湿吻：短期均线跌破或升破长期均线甚至出现反复缠绕，如胶似漆。 女上位：短期均线在长期均线之上。 男上位：短期均线在长期均线之下。 第一类买点：用比较形象的语言描述就是由男上位最后一吻后出现的背驰式下跌构成。 第二类买点：女上位第一吻后出现的下跌构成。 现在，先打开茅台的周线图，在茅台快6年的周线图上，用5周与10周均线构成的买卖系统， 只有第一类和第二类买点各一个，可见，在周线图上，按均线系统构成的买点并不常见， 一旦出现必须珍惜。 仔细分析：2002年4月19日那周，茅台进入男上位， 其后在2002年7月9日那周进入男上位的第一吻，前面已经说过，这第一吻后的下跌一般不会构成买点，必须是至少第二吻以后。 其第二吻出现在2003年2月14日那周，是典型的湿吻， 其后在下跌并没构成背驰，不符合第一类买入点的原则。 然后在2003年6月27日那周构成第三吻，是一个不太强烈的湿吻， 其后的下跌就出现了明显的背驰走势，在 MACD 图上，绿柱子比上一次的明显缩短， 而低位却低于上次绿柱子出现时的低位。 如何判断背驰走势结束，最简单的就是当绿柱子缩短，而股价继续创新低， 这次，明显地发生在2003年9月26日这一周，意味着底部出现，第一类买点构造完成，可以大举介入了。 第一类买点出现后，茅台也正常地改变体位，进入女上位， 一直到2004年6月4日那周出现女上位后的第一吻，其后的下跌构成周线上的第二类买点。 这里有一个很重要的技巧，就是第二类买点如何精确地把握， 由于在周线女上位后第一吻的调整不构成明显的下跌走势， 因此对于第一类买点的背驰走法就无法出现， 这时候就要降低 K 线级别，从日线图上寻找最佳买点。 这里给出一个缠中说禅买点定律： &gt; 大级别的第二类买点由次一级别相应走势的第一类买点构成。 （该定律是有专利的，发明权一定要明确，否则本ID不会再说任何定律了。） 例如，周线上的第二类买点由日线上相应走势的第一类买点构成。 有了这个买点定律，所有的买点都可以归结到第一类买点。 对于茅台，2004年6月4日那周出现女上位后第一吻， 对应在日线图上是明显的男上位走势，该走势其中出现三次吻， 分别在2004年4月29日、5月18日、6月1日，都是典型的湿吻， 但前两次其后的下跌都没有出现背驰，只有第三次，出现明显的背驰性走势。 6月18日创下低点后，MACD 的绿柱子明显比前面的要缩短， 这就构成了日线上的第一类买点，而这个买点，在周线上就是第二类买点。 注意，后面由于除权，价位上似乎比这个要低了，其实并没有。 站在周线角度，茅台的买点就这两个了，而其后的卖点至今没出现， 如果当时根据这两个买点介入的，目前应该继续持有，直到卖点出现。 但是，这是一种针对特别大资金的玩法，例如50亿以上， 对于资金量一般的，例如10亿以下的，有一种增加资金流动性的玩法， 就是充分利用日线的卖点回避大的调整，虽然这种调整站在周线的角度不一定要参与。 缠中说禅短差程序： 大级别买点介入的，在次级别第一类卖点出现时，可以先减仓，其后在次级别第一类买点出现时回补。 对于周线买点介入的，就应该利用日线的第一类卖点减仓， 其后在第一类买点回补。对于茅台，分析如下： 2003年9月26日那周介入的，其后的女上位出现九次吻，前八次都没构成背驰走势， 第九次出现在2004年3月26日，其后的上涨出现明显背驰， 4月8日高位对应的 MACD 红柱子并没有相应创出新高， 这就构成日线上的第一类卖点。 其后的第一类买点出现在6月18日，然后的第一类卖点出现在10月27日， 然后第一类买点出现在12月22日，下一个第一类卖点出现在2005年4月26日， 接着的第一类买点出现在2005年12月13日，下面的第一类卖点至今没出现。 也就是说，即使是站在日线的角度，2005年12月13日介入的茅台，根本就没有出现卖点， 唯一正确的就是坚决持有。 当然，如果资金量小，不是按周线的，第一类、第二类买点都是最多按日线的， 就可以相应在30分钟等更小的级别内找到第一类卖点而弄出短差来， 那就太细了，各位自己研究去。 要把握好这个均线构成的买卖系统，必须深刻理解缠中说禅买点定律： &gt; 大级别的第二类买点由次一级别相应走势的第一类买点构成。 如果资金量不特别巨大，就要熟练掌握缠中说禅短差程序， 这样才能提高资金的利用率。 注意，该定律和程序都要注意版权，任何人都可以用，也不收任何版权费， 但这个版权必须要明确，否则本ID心情不好，就没兴趣再说任何定律、程序了。 严惩所有企图盗版去招摇撞骗的人。 各位要多看图，根据相应的资金量以及性格去定自己的操作级别， 然后具体去熟练，否则就是纸上谈兵，毫无意义了。","link":"/posts/12054/"},{"title":"教你炒股票15：没有趋势，没有背驰。","text":"有人很关心诸如庄家、主力之类的事情， 但散户、庄家的位次分野这类事情不过是市场之“不患”下的“患”， 对本ID所解《论语》熟悉的，对此都很容易理解。 有些东西是超越散户、庄家的位次分野的， 这是市场之根，把握了，所谓散户、庄家的位次分野就成了笑话。 如果真喜欢听有关庄家的逸事、秘闻， 以后有空本ID可以说点，而且还可以告诉你如何阻击、搞死庄家， 这一点，环视国内，没有比本ID更有经验的了。 对于市场走势，有一个是“不患”的， 就是走势的三种分类：上涨、下跌、盘整。 所有走势都可以分解成这三种情况。 这是一个最简单的道理， 而这才是市场分析唯一值得依靠的基础。 很多人往往忽视最简单的东西，去搞那些虚头八脑的玩意。 而无论你是主力、散户、庄家， 都逃不过这三种分类所交织成的走势。 一、三种走势定义 那么，何谓上涨、下跌、盘整？下面给出一个定义。 首先必须明确的是，所有上涨、下跌、盘整都建立在一定的周期图表上， 例如在日线上的盘整，在30分钟线上可能就是上涨或下跌， 因此，一定的图表是判断的基础， 而图表的选择，与上面所说交易系统的选择是一致的， 相关于你的资金、性格、操作风格等。 上涨：最近一个高点比前一高点高，且最近一个低点比前一低点高。 下跌：最近一个高点比前一高点低，且最近一个低点比前一低点低。 盘整： 最近一个高点比前一高点高，低点却更低； 或最近一个高点比前一高点低，低点却更高。 操作的关键不是定义， 而是如何充分理解定义，使得操作有一个坚固的基础。 其中的困难在于如何去把握高点和低点， 因为高点、低点是有其级别的， 在30分钟图上看到的高点，可能在周线图上什么都没看到。 为此，必须要均线系统来过滤， 也就是前面常说的“吻”的概念， 只有在“吻”前后出现的高、低点才有意义。 二、“吻”的分类与趋势反抗 首先要搞清楚“吻”是怎样产生的： 飞吻：走势突破短线均线，却不能突破长期均线； 唇吻：走势突破长期均线后马上形成陷阱； 湿吻：走势突破长期均线后出现一定的反复缠绕。 “吻”的分类基于对原趋势的反抗程度： “飞吻”：基本无反抗； “唇吻”：力度一般； “湿吻”：反抗充分，转折多由此而生。 转折一般只有两种情形： “湿吻”后继续原趋势形成陷阱，再反转； 出现盘整，以时间换空间完成转折。 第二种情况暂且不说， 第一种情况的最大标志就是——背驰。 📌 必须注意：没有趋势，就没有背驰！在盘整中不存在背驰，这点必须特别明确。 还需强调一点：本判断系统仅涉及两条均线与走势的关系， 与任何技术指标无关，MACD之类只是参考工具。 三、如何判断“背驰” 定义一：缠中说禅趋势力度 缠中说禅趋势力度：前一“吻”结束与后一“吻”开始之间，由短期均线与长期均线相交所形成的面积。 当后一段趋势的面积小于前一段时， 即判断为背驰成立，说明转折临近。 优点：稳妥； 缺点：需等再次接吻后才可验证， 与真实转折点已有一定距离。 解决方法一：看低一级别图 例如在30分钟图上观察趋势力度的变化， 这样更接近真实转折点，更提前发现背驰迹象。 定义二：缠中说禅趋势平均力度（高级技巧） 趋势平均力度 = 均线面积 / 时间 一旦当前平均力度弱于前次， 再结合短期均线与长期均线的延伸距离缩短， 就可判断底部已临近，转折即将发生。 优点：即时反应，转折点捕捉更精准； 缺点：风险高、对技巧与经验要求较高。 四、结语 纯粹的两条均线的K线图， 就足以应付最复杂的市场走势了。 当然，如果看图能力不够强， 可以借助MACD等技术指标辅助， 相关用法将在后续章节陆续展开。","link":"/posts/1460/"},{"title":"教你炒股票16：中小资金的高效买卖法","text":"上章说过，市场任何品种任何周期下的走势图，都可以分解成上涨、下跌、盘整三种基本情况的组合。上涨、下跌构成趋势，如何判断趋势与盘整，是判断走势的核心问题。一个最基本的问题就是，走势是分级别的，在30分钟上的上涨，可能在日线图上只是盘整的一段甚至是下跌中的反弹，所以抛开级别前提而谈论趋势与盘整是毫无意义的，这必须切实把握。 注意，下面以及前面的讨论，如没有特别声明，都是在同级别的层面上展开的，只有把同级别的事情弄明白了，才可以把不同级别走势组合在一切研究，这是后面的事情了。 上涨、下跌、盘整三种基本走势，有六种组合可能代表着三类不同的走势： 陷阱式：上涨+下跌；下跌+上涨。 反转式：上涨+盘整+下跌；下跌+盘整+上涨。 中继式：上涨+盘整+上涨；下跌+盘整+下跌。 市场的走势，都可能通过这三类走势得以分解和研究。站在多头的角度，首先要考虑的是买入，因此，上面六种最基本走势中，有买入价值的是：下跌+上涨、下跌+盘整+上涨、上涨+盘整+上涨三种。没有买入价值的是：上涨+下跌；上涨+盘整+下跌；下跌+盘整+下跌。 由此不难发现，如果在一个下跌走势中买入，其后只会遇到一种没买入价值的走势，就是下跌+盘整+下跌，这比在上涨时买入要少一种情况。而在下跌时买入，唯一需要躲避的风险有两个：一、该段跌势未尽；二、该段跌势虽尽，但盘整后出现下一轮跌势。 在上一章“没有趋势没有背驰”中，对下跌走势用背驰来找第一类买点，就是要避开上面的第一个风险。而当买入后，将面对的是第二个风险，如何避开？就是其后一旦出现盘整走势，必须先减仓退出。为什么不全部退出，因为盘整后出现的结果有两种：上涨、下跌，一旦出现下跌就意味着亏损，而且盘整也会耗费时间，对于中小资金来说，完全没必要。 这里有一个很重要的问题留待后面分析，就是如何判断盘整后是上涨还是下跌，如果把握了这个技巧，就可以根据该判断来决定是减仓退出还是利用盘整动态建仓了。这是一个大问题，特别对于不想坐庄的大资金来说，这是一个最重要的问题，因为不想坐庄的大资金的安全建仓在六种走势中只可能在下跌+盘整+上涨这一种，其他都不适用。至于坐庄的建仓方法，和这些都不同，如有兴趣，本ID以后也可以说的。 根据上面的分析，可以马上设计一种行之有效的买卖入方法：在第一类买点买入后，一旦出现盘整走势，无论后面如何，都马上退出。这种买卖方法的实质，就是在六种最基本的走势中，只参与唯一的一种：下跌+上涨。对于资金量不大的，这是最有效的一种买卖方法。 下面重点分析：对于下跌+上涨来说，连接下跌前面的可能走势只会有两种：上涨和盘整。如果是上涨+下跌+上涨，那意味着这种走势在上一级别的图形中是一个盘整，因此这种走势可以归纳在盘整的操作中，这在以后对盘整的专门分析里研究。换言之，对于只操作“下跌+上涨”买卖的，“上涨+下跌+上涨”走势不考虑，也就是说，当你希望用“下跌+上涨”买卖方法介入一只出现第一类买点的股票，如果其前面的走势是“上涨+下跌”，则不考虑。注意，不考虑不意味着这种情况没有赢利可能，而只是这种情况可以归到盘整类型的操作中，但“下跌+上涨”买卖方法是拒绝参与盘整的。如此一来，按该种方法，可选择的股票又少了，只剩下这样一种情况，就是“盘整+下跌+上涨”。 从上面的分析可以很清楚地看到，对于“下跌+上涨”买卖方法来说，必须是这样一种情况：就是一个前面是“盘整+下跌”型的走势后出现第一类买点。显然，这个下跌是跌破前面盘整的，否则就不会构成“盘整+下跌”型，只会仍是盘整。那么在该盘整前的走势，也只有两种：上涨、下跌。对于“上涨+盘整+下跌”的，也实质上构成高一级别的盘整，因此对于“下跌+上涨”买卖方法来说也不能参与这种情况，因此也就是只剩下这样一种情况：“下跌+盘整+下跌”。 综上所述，对于“下跌+上涨”买卖方法来说，对股票的选择就只有一种情况，就是：出现第一类买点且之前走势是“下跌+盘整+下跌”类型。因此这里就得到了用“下跌+上涨”买卖方法选择买入品种的标准程序： 一、首先只选择出现“下跌+盘整+下跌”走势的。 二、在该走势的第二段下跌出现第一类买点时介入。 三、介入后，一旦出现盘整走势，坚决退出。 注意，这个退出肯定不会亏钱的，因为可以利用低一级别的第一类卖点退出，是肯定要赢利的。但为什么要退出，因为它不符合“下跌+上涨”买卖不参与盘整的标准，盘整的坏处是浪费时间，而且盘整后存在一半的可能是下跌，对于中小资金来说，根本没必要参与。 一定位要记住，操作一定要按标准来，这样才是最有效率的。如果买入后不出现盘整，那就要彻底恭喜你了，因为这股票将至少回升到“下跌+盘整+下跌”的盘整区域，如果在日线或周线上出现这种走势，进而发展成为大黑马的可能是相当大的。 举一个例子： 驰宏锌锗：日线上，2004年6月2日到2004年9月10日，构成下跌走势； 2004年9月10日到2005年3月14日，构成盘整走势； 2005年3月14日到2005年7月27日，构成下跌走势。 也就是说，从2004年6月2日到2005年7月27日，构成标准的“下跌+盘整+下跌”的走势，而在相应的2005年3月14日到2005年7月27日的第二次下跌走势中，7月27日出现明显的第一类买点，这就完美地构成了“下跌+上涨”买卖方法的标准买入信号。其后走势，很快就回到2004年9月10日到2005年3月14日的盘整区间，然后回调在2005年12月8日出现标准的第二类买点，其后走势就不用多说了。 该种方法反过来就是选择卖点的好方法了，也就是说前面出现“上涨+盘整+上涨”走势的，一旦第二段升势出现第一类卖点，一定要走，因为后面很可能就是“上涨+下跌”的典型走势。 对此，也举一个例子： 北辰实业，在30分钟图上，11月7日10点30分到11月22日10点，构成上涨； 11月22日10点到11月30日11点构成盘整； 11月30日11点到12月7日10点构成上涨。 而在第二段上涨中，30分钟图上的3次红柱子放大，一次比一次矮所显示的严重背离，就完美地构成了“上涨+盘整+上涨”后出现第一类卖点的“上涨+下跌”型卖出。 如果以后学了时间之窗的概念，对该股的卖点就更有把握了，各位注意到11月7日10点30分和12月7日10点之间的关系没有。 这种方法，无论买卖，都极为适用于中小资金，如果把握得好，是十分高效的，不过要多多看图，认真体会，变成自己的直觉才行。 另外请多看文章后面的跟贴，ID的一些回复都是针对一些主帖没所到的细节东西，而且都是针对各位提出的不同问题的。 还有多看前面的章节，把所有问题都搞懂，参与市场是不能有半点糊涂的。","link":"/posts/36133/"},{"title":"教你炒股票13：不带套的操作不是好操作！","text":"不带套的男人是否好男人，这个问题暂且不说，不带套的操作一定不是好操作票，特别对于资金量大的！带套有两种，一种是主动、一种是被动。 何谓被动带套？就是介入时根本不知道为何介入，在一种盲目的状态下被套了，然后还有一种很错误的理论，认为亏损多少就要止蚀， 按这种方法来操作，最终都不可能大成功的。几乎所有的投资者，都是这种被动带套的，这种人，都是被套所套。 其实，从来不存在真正的止蚀问题，只存在股票是否依然在能搞的范围内的问题，只有这种意义下才存在止蚀：一只股票的走势从能搞变成不能搞。 请注意，站在盈亏的，这时并不意味着操作是失败了，可能已经大大赢利了，唯一退出的原因只是股票的走势已经不能搞了。 投资市场中一个最坏的毛病就是根据盈亏进出，而盈亏不是先验的，是根据当下的走势当下决定的，是被动的，根据盈亏进出， 就是根据被动的因数进出，这不是被动带套是什么？ 何谓主动带套？这里有两层意思。其一，介入不可能一下子完成，特别对于大资金来说，如果不采取主动带套的方法，怎么可能买到足够的货？ 那种号称从来不带套的，肯定从来没操作过大资金。但更重要的是，任何的介入，都有一个主动的防护加入其中，这个防护就是从一旦变为不能搞， 就立刻从买入程序中此退出，这个防护的启动是和任何盈亏无关的，只和当下的走势有关。 例如，在上一章所说的买入程序里，对于第一个买点，一旦上涨时依然出现男上位的缠绕，那么一定要退出，为什么？ 因为第一个买点买入的基础在于男上位最后一个缠绕后出现背驰，而现在又出现男上位的缠绕，意味着前面引导买入程序启动的缠绕并不是最后一个缠绕， 也就是程序判断上出现问题，因此必须退出。一般情况下，这种退出一定是赢利的，但这并不能成为不退出的理由。 甚至不排除这种情况，就是退出后，缠绕经过以时间换空间的折腾慢慢变成女上位，最后还大幅上涨了（这种情况即使出现， 也可以根据第二个买点的原则重新介入，所以真正的机会并不会丢失），但即使这样，也绝对不能因为这种可能的情况有侥幸心理。 因为还有更大的可能是缠绕后出现加速下跌。对于走势，可能是无位次的，而实现是有位次的，而任何的操作，只能建立在有位次的基础上， 这对于熟悉本ID所解《论语》的人应该能理解。半部《论语》治天下，就别说股市了，要股市上脱胎换骨，多看本ID说的《论语》，那是源泉。 而对于上一章所说的第二个买点，一旦该缠绕中出现跌破前面男上位的最低位，就意味着买入程序出现问题，必须在任何一个反弹中把股票出清， 在这种情况下，不排除后面出现上涨，但理由如上，任何操作，没有百分百准确的，一旦出现特殊情况，一定要先退出来， 这是在投资生涯中能长期存活的最重要一点。当然，有经验的人，即使退出，也会按部就班，很有秩序，这和打仗是一个道理，一发现战机不对， 就要撤，不能硬抗，否则不给灭了才怪了。 投资是一个长期的事业，别抱着赌博的心态企图一次成功，只要有这种心态，最终的结局一定悲惨，这已经被无数事例所验证。 为什么要研究符合自己的买卖程序？就是因为这是市场风浪中唯一安全的港湾，港湾有时候也会有台风，但不能因为有时候有台风就不要港湾了。 还有一点，就是买入程序的成功率和市场的强度有关，在强的市场里，买入程序的成功率基本都在90%以上，但在弱的市场里，这成功率就要低多了。 任何根据均线等技术系统构成的买卖程序，都只是一个综合判断的一个子判断，并不是说这一招就可以了。 至少有一点是任何技术的买卖程序不能解决的，就是相同程序选出来的股票，为什么有些涨得多、有些涨的少，能不能就此而选出最有力度的， 这在实际的操作中是很有意义的问题。用一个庸俗的比喻，技术系统是“海选”，而其后需要的是“复赛”、“PK”，这才能选出真正可以介入的股票。 关于这个问题，在后面会逐步展开。","link":"/posts/41208/"},{"title":"教你炒股票17：走势终完美","text":"任何级别的所有走势，都能分解成趋势与盘整两类，而趋势又分为上涨与下跌两类。以上结论，不是从天而降的，而是从无数图形的分析实践中总结出来的，正如《论语》所说“由诲女，知之乎！知之为，知之；不知为，不知；是知也。”（请看本ID相应系列的解释）这个从实际图形中总结出来的简单经验，却是一切有关技术分析理论的唯一坚实基础。这个基础，所有接触技术分析的人都知道，但可惜没有人能深究下去，然后就沉入技术指标、交易系统等苦海不能自拔。试想，基础都没搞清楚，又有什么可立起来？而基础稳固了，技术指标、交易系统等都是小儿科了。 由上可得到“缠中说禅技术分析基本原理一”：任何级别的任何走势类型终要完成。后面一句用更简练的话，就是“走势终完美”。这个原理的重要性在于把实践中总结出来的、很难实用的、静态的“所有级别的走势都能分解成趋势与盘整”，转化成动态的、可以实用的“走势类型终要完成”，这就是论语所说的智慧：“所有级别的走势都能分解成趋势与盘整”是“不患”的，是无位次的，而“走势类型终要完成”的“走势终完美”以“所有级别的走势都能分解成趋势与盘整”的无位次而位次之，而“患”之。 因为在实际操作中，面对的是都是鲜活的、当下的，而正如《论语》所说的，“由知、德者，鲜矣！”，必须直面这种当下、鲜活，才能创造。而在任何一个走势的当下，无论前面是盘整还是趋势，都有一个两难的问题：究竟是继续延续还是改变。例如，原来是在一个趋势中，该趋势是否延续还是改变成相反的趋势或盘整，这样的问题在当下的层次上永远是“不患”的，无位次的。任何宣称自己能解决这个两难问题的，就如同在地球上宣称自己不受地球引力影响一样无效，这是任何面对技术图形的人都必须时刻牢记的。 但这个两难的“不患“，在“所有级别的走势都能分解成趋势与盘整”的“不患”下，又成了其“患”，就因此可以位次（该问题的理解，可以参考本ID关于《论语》相关章节的解释）。正因为当下的走势是两难的，也就是在不完美到完美的动态过程中，这就构成了其“不患”而位次的基础。“走势终完美”，而走势“不患”地可以分解成趋势与盘整，换言之，“趋势终完美，盘整也终完美”。 “走势终完美”这句话有两个不可分割的方面：任何走势，无论是趋势还是盘整，在图形上最终都要完成。另一方面，一旦某种类型的走势完成以后，就会转化为其他类型的走势，这就是“不患”而有其位次。在技术分析里，不同的位次构成不同的走势类型，各种位次以无位次而位次。而如何在不同位次之间的灵活运动，是实际操作中最困难的部分，也是技术分析最核心的问题之一。 为了深入研究这复杂问题，必须先引入缠中说禅走势中枢的概念：某级别走势类型中，被至少三个连续次级别走势类型所重叠的部分，称为缠中说禅走势中枢。换言之，缠中说禅走势中枢就是至少三个连续次级别走势类型重叠部分所构成。这里有一个递归的问题，就是这次级别不能无限下去，就像有些半吊子哲学胡诌什么“一分为二”，而“分”不是无限的，按照量子力学，物质之分是有极限的，同样，级别之次也不可能无限，在实际之中，对最后不能分解的级别，其缠中说禅走势中枢就不能用“至少三个连续次级别走势类型所重叠”定义，而定义为至少三个该级别单位K线重叠部分。一般来说，对实际操作，都把这最低的不可分解级别设定为1分钟或5分钟线，当然，也可以设定为1秒种线，但这都没有太大区别。 有了上面的定义，就可以在任何一个级别的走势中找到“缠中说禅走势中枢”。有了该中枢，就可以给“盘整”、“趋势”给出一个最精确的定义： 缠中说禅盘整：在任何级别的任何走势中，某完成的走势类型只包含一个缠中说禅走势中枢，就称为该级别的缠中说禅盘整。 缠中说禅趋势：在任何级别的任何走势中，某完成的走势类型至少包含两个以上依次同向的缠中说禅走势中枢，就称为该级别的缠中说禅趋势。该方向向上就称为上涨，向下就称为下跌。 那么，是否可能在某级别存在这样的走势，不包含任何缠中说禅走势中枢？这是不可能的。因为任何图形上的“向上+向下+向上”或“向下+向上+向下”都必然产生某一级别的缠中说禅走势中枢，没有缠中说禅走势中枢的走势图只意味着在整张走势图形上只存在两个可能，就是一次向下后永远向上，或者一次向上后永远向下。要出现这两种情况，该交易品种必然在一定时期交易后永远被取消交易，而这里探讨走势的一般情况，其前提就是该走势可以不断延续下去，不存在永远取消交易的情况，所以，相应有： “缠中说禅技术分析基本原理二”：任何级别任何完成的走势类型，必然包含一个以上的缠中说禅走势中枢。 由原理一、二以及缠中说禅走势中枢的定义，就可以严格证明： 缠中说禅走势分解定理一：任何级别的任何走势，都可以分解成同级别“盘整”、“下跌”与“上涨”三种走势类型的连接。 缠中说禅走势分解定理二：任何级别的任何走势类型，都至少由三段以上次级别走势类型构成。 这些证明都很简单，就和初中几何的证明一样，有兴趣自己来一下。由上面的原理和定理，就可以严格地给出具体操作唯一可以依赖的两个坚实的基础。因为某种类型的走势完成以后就会转化为其他类型的走势，对于下跌的走势来说，一旦完成，只能转化为上涨与盘整，因此，一旦能把握下跌走势转化的关节点买入，就在市场中占据了一个最有利的位置，而这个买点，就是前面反复强调的“第一类买点”；而因为无论是趋势还是盘整在图形上最终都要完成，所以在第一类买点出现后第一次次级别回调制造的低点，是市场中第二有利的位置，为什么？因为上涨和盘整必然要在图形上完成，而上涨和盘整在图形上的要求，是必须包含三个以上的次级别运动，因此后面必须还至少有一个向上的次级别运动，这样的买点是绝对安全的，其安全性由走势的“不患”而保证，这，就是在前面反复强调的第二类买点。买点的情况说了，卖点的情况反之亦然。 综上所述，就不难明白为什么本ID在前面反复强调这两类买卖点了。因为该两类买卖点是被最基础的分析所严格保证的，就如同几何中严格定理一样，只要找准了这两类买卖点，在市场的实际走势中是战无不胜的，是波涛汹涌的市场中最坚实的港湾。关于该两类买卖点与走势及上述原理、定理间密不可破的逻辑关系，必须切实理解体会，这是所有操作中最坚实、最不能混淆的基础。 由上面的原理、定理，就可以继续证明前面已经说过的“缠中说禅买卖点定律一”：任何级别的第二类买卖点都由次级别相应走势的第一类买点构成。 这样，就像前面曾说过的，任何由第一、二类买卖点构成的缠中说禅买卖点，都可以归结到不同级别的第一类买卖点。由此得到“缠中说禅趋势转折定律”：任何级别的上涨转折都是由某级别的第一类卖点构成的；任何的下跌转折都是由某级别的第一类买点构成的。注意，这某级别不一定是次级别，因为次级别里可以是第二类买卖点，而且还有这种情况，就是不同级别同时出现第一类买卖点，也就是出现不同级别的同步共振，所以这里只说是某级别。 本ID以上对技术分析的理论构建，绝对前无古人，就像欧几里德之于几何一样。这是为纷繁的技术分析找到了一个坚实的理论基础，由这些原理、定理，可以继续引申出不同的定理，就像几何里面一样。这些定理，都是抛开一切偶然因数的，而实际的操作，必须建立在此之上，才会长期立于不败之地。 这些问题以后还要逐步展开，这里先把两个前面已经让各位思考例子来分析一下，让各位对趋势、级别、走势中枢等概念有一个感性的认识，毕竟上面抽象的方法并不是每个人都能理解的： 驰宏锌锗：为什么从2004年6月2日到2005年7月27日，构成标准的“下跌+盘整+下跌”的走势，而类似的图形在580991上不算，这唯一的原因就是因为后者在日线的下跌中并不构成日线级别的缠中说禅走势中枢，而在30分钟线上，这个中枢是明确的。所以580991只构成30分钟级别上的“下跌+盘整+下跌”。 其后的上涨，对600497驰宏锌锗，2005年7月27日到10月25日，明确地出现在日线上的上涨走势（为什么？因为在日线上明确地看到两个缠中说禅走势中枢）。而580991从2006年10月23日到12月13日，只构成日线上的盘整走势（为什么？因为在日线上明确地看到一个缠中说禅走势中枢）。 两者力度上有如此区别的技术上的原因就是上面两个：一、“下跌+盘整+下跌”走势的出现级别不同，一个是日线，一个是30分钟的。二、其后的第一段走势，一个是日线上涨，一个是日线盘整。 以上内容，足够各位消化几天了。后面还有很多内容，逐一写来。但请注意版权，发现抄袭的本ID要抓来狗头铡给铡了。最后布置几条思考题： 1、连接两相邻同级别缠中说禅走势中枢的一定是趋势吗？一定是次级别的趋势吗？ 2、背驰是两相邻同向趋势间，后者比前者的走势力度减弱所造成的，如果用均线或MACD等判断其力度，一定要在同级别的图上吗？同级别的MACD红绿柱子背驰一定反映某级别趋势间出现背驰吗？是相应级别的趋势出现背驰吗？ 3、盘整的高低点是如何造成的。（这个问题有点难度，提示，用缠中说禅走势中枢以及级别等进行分析。）","link":"/posts/27232/"},{"title":"教你炒股票18：不被面首的雏男是不完美的","text":"首先把前面一些最基本的概念、原理、定理列举如下： 走势：打开走势图看到的就是走势。走势分不同级别。 走势类型：上涨、下跌、盘整。 趋势：上涨、下跌。 缠中说禅走势中枢：某级别走势类型中，被至少三个连续次级别走势类型所重叠的部分。具体的计算以前三个连续次级别的重叠为准，严格的公式可以这样表示： 次级别的连续三个走势类型A、B、C，分别的高、低点是 a1\\a2，b1\\b2，c1\\c2。则中枢的区间就是（max（a2，b2，c2），min（a1，b1，c1）），而实际上用目测就可以，不用这么复杂。注意，次级别的前三个走势类型都是完成的才构成该级别的缠中说禅走势中枢，完成的走势类型，在次级别图上是很明显的，根本就不用着再看次级别下面级别的图了。 缠中说禅盘整：在任何级别的任何走势中，某完成的走势类型只包含一个缠中说禅走势中枢，就称为该级别的缠中说禅盘整。 缠中说禅趋势：在任何级别的任何走势中，某完成的走势类型至少包含两个以上依次同向的缠中说禅走势中枢，就称为该级别的缠中说禅趋势。该方向向上就称为上涨，向下就称为下跌。注意，趋势中的缠中说禅走势中枢之间必须绝对不存在重叠。 “缠中说禅技术分析基本原理一”：任何级别的任何走势类型终要完成。 “缠中说禅技术分析基本原理二”：任何级别任何完成的走势类型，必然包含一个以上的缠中说禅走势中枢。 “缠中说禅走势分解定理一”：任何级别的任何走势，都可以分解成同级别“盘整”、“下跌”与“上涨”三种走势类型的连接。 “缠中说禅走势分解定理二”：任何级别的任何走势类型，都至少由三段以上次级别走势类型构成。 原理一“任何级别的任何走势类型终要完成”，这最简单的话，却包含着技术分析最基本的东西，其哲学和灵魂都在此，否则就不可能被列为原理一了，这是最重要的。一个最简单的问题，如何判断一个走势类型完成了？这是技术分析里最核心的问题之一，例如，一旦判断知道了“下跌”的结束，就知道随后必须要面对的是“盘整”与“上涨”，而后两种走势，对于多头来说，都必然产生利润，唯一区别，就是大小与快慢的问题。如果在市场中能找到一种百分百确定的赢利模式，那就是最伟大的成就了，至于大小、快慢，可以继续研究出新的标准来进行判断，而在逻辑上，这是后话了。 这里最大的也是唯一的难点在于“走势类型的延伸”。例如一个盘整，三个重叠的连续次级别走势类型后，盘整就可以随时完成，也就是说，只要三个重叠的连续次级别走势类型走出来后，盘整随时结束都是完美的，但这可以不结束，可以不断延伸下去，不断围绕这缠中说禅中枢上上下下地延伸下去直到无穷都是可以的。这有点像一个雏男在某种标准达到后就具有立刻成为面首的条件，随时可以被面首，但却也可以一直坚持下去，一直自我封闭，一直不让消费，最后把自己给浪费掉了，直到最后变成一个烂苹果。 同样，面对趋势，形成两个依次同向的缠中说禅走势中枢后，任何趋势都可以随时结束而完美，但也可以不断地延伸下去，形成更多的中枢。这种情况在实际操作中太常见了，如果这趋势是向上的，会不断上涨，看看600519之类的图，如果把复权算上，就可以看到一个标准的不断延伸的上涨。大盘2005年见底后的30分钟图上，同样可以看到这种情况。很多人抓不住牛股，经常在第一个中枢时就被震下马，最主要就是对此没有明确的认识。反之，对于下跌的延伸，是所有抄底者的噩梦。逃顶、抄底为何难？归根结底就是这“走势类型的延伸”闹的。 如何判别“走势类型延伸”是否结束？这里，必须首先搞清楚，“走势类型延伸”的实质是什么？对于趋势来说，其“延伸”就在于同级别的同向“缠中说禅走势中枢”不断产生；而对于盘整来说，其“延伸”就在于不能产生新的“缠中说禅走势中枢”。由于“走势类型延伸”意味着当下的“走势类型”随时可以完成，因此相应的“类型”必然是确定的，因此“走势类型延伸”是否结束的判断关键就在于是否产生新的“缠中说禅走势中枢”。此外，由于趋势至少包含两个“缠中说禅走势中枢”，而盘整只有一个，因此趋势与盘整的判别关键也就在于是否产生新的“缠中说禅走势中枢”。由此可见，“缠中说禅走势中枢”的问题是技术分析中的核心问题，该问题一旦解决，很多判断上的大难题也将引刃而解。 “缠中说禅走势中枢定理一”：在趋势中，连接两个同级别“缠中说禅走势中枢”的必然是次级别以下级别的走势类型。 用反证法，该定理的证明是很简单的，而这也回答了上一章中的作业一“连接两相邻同级别缠中说禅走势中枢的一定是趋势吗？一定是次级别的趋势吗？”首先，这不必然是趋势，任何走势类型都可能，最极端的就是跳空缺口后形成新的“缠中说禅走势中枢”；其次，也不一定是次级别的，只要是次级别以下，例如跳空缺口，就属于最低级别，如果图上是日线、周线，就不会是次级别了；最后，往往相连走势类型的级别越低，表示其力度越大，这也就是为什么缺口在分析中有比较强技术含义的理论依据所在。 由定义知道，“缠中说禅走势中枢”的产生原因以及判断标准，也就是其“生”问题已经解决，那余下的就是其“住、坏、灭”的问题。也就是说，一个“缠中说禅走势中枢”是如何“维持”以及最终被“破坏”进而废弃的。先考虑其“维持”的问题。维持“缠中说禅走势中枢”的一个充分必要条件就是任何一个离开该中枢的走势类型都必须是次级别以下的并以次级别以下的走势类型返回，该问题很容易证明，因为无论是离开还是返回，只要是同级别的走势类型，就意味着形成新的“缠中说禅走势中枢”，这与原中枢的维持前提矛盾。该命题表述成如下定理： “缠中说禅走势中枢定理二”：在盘整中，无论是离开还是返回“缠中说禅走势中枢”的走势类型必然是次级别以下的。 由此，上一章作业三“盘整的高低点是如何造成的”就有了相应的答案：无论离开与返回的走势类型是何种级别的，站在最低级别上看，例如把1分钟图当成最低级别，那么最后连接离开与返回走势类型连接处的最低级别图，只能有两种可能： 1. 三根以上1分钟K线的来回重叠震荡后回头； 2. 1分钟K线无三根以上K线重叠的V型走势。 对于第一种情况，这几根重叠K线最极端那根的极端位置，就构成盘整中的高低点，一般来说，这种情况比较少见；对于第二种情况，这个V型尖顶那根K线的极端位置就构成盘整中的高低点，这种情况十分常见。这也是为何真正的低点和高点总是盘中一闪而过的理论依据。本ID的理论能解释技术图表上任何细致的问题，这才是一种真正理论所应该具有的品质。这种的理论，不需要什么诺贝尔的奖励，那一百万美圆在市场上算得了什么？精通这样的理论，市场会给予你多得多的回报。 有了上面两个“缠中说禅走势中枢”定理，不难证明定理三：某级别“缠中说禅走势中枢”的破坏，当且仅当一个次级别走势离开该“缠中说禅走势中枢”后，其后的次级别回抽走势不重新回到该“缠中说禅走势中枢”内。 这定理三中的两个次级别走势的组合只有三种：趋势+盘整，趋势+反趋势，盘整+反趋势。其中的趋势分为上涨与下跌，分别代表从上方突破与下方跌破两种情况。而站在实用的角度，最用力的破坏，就是：趋势+盘整。例如在上涨中，如果一个次级别走势向上突破后以一个盘整走势进行整理回抽，那其后的上涨往往比较有力，特别这种突破是在底部区间。这种情况太常见了，其理论依据就在这里。","link":"/posts/53614/"},{"title":"教你炒股票19：学习缠中说禅技术分析理论的关键","text":"本ID看了看各位的问题，发现前面说了那么多，似乎真能看明白的没几个。为什么？很简单，估计来这里的人都没受过太严格的数学训练，如果受过严格的数学训练，本ID现在所说的，简直就是最简单不过的东西。这里的整个推导过程，和几何里的毫无区别，初中学过几何的，都应该能明白。所以要看明白，最好先把自己的数学神经先活动起来。有一句不大中听的话，像孔男人之类的文科生，是很难炒什么股票的。别说一般的散户了，就算当庄家，本ID所见过的庄家肯定是全国最多的，有一个很明显的规律，就是文科生当庄家，基本死翘翘。这可不是玩笑话，是直接经验的总结。孔男人之类的文科生最大特点就是脑子缺根筋——数学思维的筋。 其次，请把以前学过的一切技术分析方法先放下，因为本ID这里所说的，和所有曾有的技术分析方法的根本思路都不同。一般的技术分析方法，或者用各种指标，或者用什么胡诌的波段、波浪，甚至江恩、神经网络等等，其前提都是从一些神秘的先验前提出发。例如波浪理论里的推动浪5波，调整浪三波之类的废话，似是而非，实战中毫无用处，特别对于个股来说，更是没用。至于什么江恩理论，还有什么周期理论、神经网络之类的，都是把一些或然的东西当成必然，理论上头头是道，一用起来就错漏百出。那些支持位、阻力位，通道线、第三浪之类的玩意，只能当庄家制造骗线的好工具。 如果真明白了本ID的理论，就会发现，其他技术分析里所说的现象，都能在本ID的理论中得到解释，而且还可以给出其成立的相应界限。例如，一个股票新上市后直接向下5波后反手就向上5波形成V字型，按波浪理论，就无法得到解释，而用缠中说禅走势中枢的定理，这是很容易解决的问题。那些理论都是把复杂的走势给标准化成某种固定的模式，就如同面首宣称不带套的爱不是爱一样可笑。对于庄家来说，对一般人所认识的所谓技术分析理论，早就研究得比谁都精通，任何坐过庄的人都知道，技术图形是用来骗人的，越经典的图形越能骗人。但任何庄家，唯一逃不掉的就是本ID在分析中所说的那些最基本的东西，因为这些东西本质上对于市场是“不患”的，只要是市场中的，必然在其中，庄家也不例外。就像任何的大救星，都逃不掉生老病死。 这里必要强调，技术分析系统在本ID的理论中只是三个独立的系统之一，最基础的是三个独立系统所依据的概率原则所保证的数学上的系统有效性。但技术分析系统之所以重要，就是因为对于一个完全没有消息的散户来说，这是最公平、最容易得到的信息，技术走势是完全公开的，对于任何人来说，都是第一手，最直接的，这里没有任何的秘密、先后可言。技术分析的伟大之处就在于，利用这些最直接、最公开的资料，就可以得到一种可靠的操作依据。单凭对技术分析的精通与资金管理的合理应用，就完全可以长期有效地战胜市场，对于一般的投资者来说，如果你希望切实参与市场之中，这是一个最稳靠的基础。 本ID觉得，如果你光只是想挣点钱，那么没必要学什么技术分析，在牛市里，买基金就可以了，特别是和指数相关的基金，你就至少能跟上指数的涨幅。但市场不单单是为挣钱而存在的，市场是一个最好的修炼自己的地方，人类的贪婪、恐惧、愚蠢，哪里最多？资本市场里，每时每刻都在演绎着。在这个大染缸里修炼自己，这才是市场最大的益处。战胜市场，其实就是战胜自己的贪婪、恐惧、愚蠢，本ID的理论只是把市场拔光给各位看，而拔光一个人并不意味着就等于征服一个人，对于市场，其道理是一样的。不干，不可能征服市场。对于市场来说，干就是一切。技术分析的最终意义不是去预测市场要干什么，而是市场正在干什么，是一种当下的直观。在市场上所有的错误都是离开了这当下的直观，用想象、用情绪来代替。例如现在，还有多少人为工行的上涨而忿忿不平，却不能接受这样一个当下最直观的事实。多次反复强调，牛市第一波涨的就是成分股，工行这最大的成分股不涨，还有谁涨？96年的牛市，最大的成分股就是发展，那时候比这不更厉害多了，工行这又算得了什么？ 市场是有规律的，但市场的规律并不是显而易见的，是需要严格的分析才能得到。更重要的是，市场的规律是一种动态的，在不同级别合力作用下显示出来的规律，企图用些单纯的指标、波段、波浪、分型、周期等等预测、把握，只可能错陋百出。但只要把这动态的规律在当下的直观中把握好、应用纯熟，踏准市场的节奏，并不是不可能的。 最后布置一个作业：在所谓的波浪理论里，有一个所谓的结论，大概意思是说第四浪的调整一般在第三浪的第四子浪范围内，用缠中说禅走势中枢的相关定理分析该结论成立的范围以及局限性，相应给出类似走势的一个更合理的理论分析与实际操作准则。","link":"/posts/31862/"},{"title":"教你炒股票20：缠中说禅走势中枢级别扩张及第三类买卖点","text":"前面已经很明确地指出，缠中说禅走势中枢由前三个连续次级别走势类型的重叠部分确定，其后的走势有两种情况： 一、该走势中枢的延伸。二、产生新的同级别走势中枢。而在趋势里，同级别的前后缠中说禅走势中枢是不能有任何重叠的， 这包括任何围绕走势中枢产生的任何瞬间波动之间的重叠。因此，如果三个连续次级别走势类型的重叠区间虽然不和前面的走势中枢有任何重叠， 但围绕该中枢产生的波动触及前面走势中枢延续时的某个瞬间波动区间，这时候，就不能认为该走势类型是趋势， 而只是产生一个更大级别的缠中说禅走势中枢。 这里，必须把两种情况严格区分。一、走势中枢以及其延伸。这种情况下， 所有围绕走势中枢产生的前后两个次级波动都必须至少有一个触及走势中枢的区间。 否则，就必然产生一个新的三次连续次级走势类型的重叠部分离开原来的走势中枢，这与走势中枢的延续矛盾。 二、一个走势中枢完成前，其波动触及上一个走势中枢或延伸时的某个瞬间波动区间，由此产生更大级别的走势中枢。 一个简单的例子就能区别以上的情况，例如，一个股票开盘立刻封涨停，那么，只能算是一分钟级别上出现了走势中枢的延伸， 无论这个延伸有多长时间，都不可能产生更大级别的走势中枢。如果该股票第二天开始继续开盘涨停， 那么就形成一个一分钟级别上的趋势，这个趋势可以无限延伸下去，但只要依然只是只形成一分钟的走势中枢，无论能连续涨停多少天， 都不足以形成即使是五分钟的走势中枢，除非中途有打开涨停的时候。还有一种特殊的情况，就是所谓的庄股，如果有一个庄家特别有毛病， 每天就成交一次，每天的价位都一样，这样也只形成一个一分钟的走势中枢，大级别的中枢都不能形成。 换言之，走势中枢的延伸与不断产生新的走势中枢并相应围绕波动互不重叠而形成趋势，在这两种情况下，一定不可能形成更大级别的走势中枢。 而要形成一个更大级别的走势中枢，必然要采取第三种的方式，就是围绕新的同级别走势中枢产生后的波动与围绕前中枢的某个波动区间产生重叠。 由此可马上得到一个重要的定理： 缠中说禅走势级别延续定理一：在更大级别缠中说禅走势中枢产生前，该级别走势类型将延续。 也就是说，只能是只具有该级别缠中说禅走势中枢的盘整或趋势的延续。 看看去年指数的走势，就知道该定理的重要。很多人总是说，怎么都涨那么多了还涨，明白这个定理，就知道，要这个市场跌， 现在这种最多只出现过日线走势中枢的走势，在周线走势中枢出现前，不可能结束。而且，从去年8月份开始的走势， 甚至连日线的走势中枢都没形成过，最多就是30分钟的，要结束这种走势，首先要形成日线的中枢。 明白这个定理，就不会整天自己吓自己。这里由定理一很简单就能证明一个更重要的定理对走势改变给一个更精确、预先的界定： 缠中说禅走势级别延续定理二：更大级别缠中说禅走势中枢产生，当且仅当围绕连续两个同级别缠中说禅走势中枢产生的波动区间产生重叠。 这里来一个比喻就好理解了，缠中说禅走势中枢就如同恒星，和围绕该恒星转动的行星构成一个恒星系统。 而两个同级别恒星系统要构成一个更大级别的系统，首先必然要至少是其中的外围行星之间发生关系，这就是定理二说的东西。 有了上面的定理，就可以很精确地讨论走势中枢的问题了：根据走势中枢的数学表达式：A、B、C，分别的高、低点是a1\\a2，b1\\b2，c1\\c2， 则中枢的区间就是[max（a2，b2，c2），min（a1，b1，c1）]。而中枢的形成无非两种，一种是回升形成的，一种是回调形成的。 对于第一种有a1=b1，b2=c2；对第二种有a2=b2，b1=c1。但无论是哪种情况，中枢的公式都可以简化为[max（a2，c2），min（a1，c1）]。 显然，A、C段，其方向与中枢形成的方向是一致的，由此可见，在中枢的形成与延伸中，由与中枢形成方向一致的次级别走势类型的区间重叠确定。 例如，回升形成的中枢，由向上的次级别走势类型的区间重叠确定，反之依然。 为方便起见，以后都把这些与中枢方向一致的次级别走势类型称为Z走势段，按中枢中的时间顺序，分别记为Zn等， 而相应的高、低点分别记为gn、dn，定义四个指标，GG=max(gn)，G=min(gn)，D=max(dn)，DD=min(dn)，n遍历中枢中所有Zn。 特别地，再定义ZG=min(g1、g2)，ZD=max(d1、d2)，显然，[ZD，ZG]就是缠中说禅走势中枢的区间，由此有了如下定理： 缠中说禅走势中枢中心定理一：走势中枢的延伸等价于任意区间[dn，gn]与[ZD，ZG]有重叠。 换言之，若有Zn，使得dn &gt; ZG或gn &lt; ZD，则必然产生高级别的走势中枢或趋势及延续。 缠中说禅走势中枢中心定理二：前后同级别的两个缠中说禅走势中枢，后GG &lt; 前DD等价于下跌及其延续；后DD &gt; 前GG等价于上涨及其延续。 后ZG &lt; 前ZD且后GG &gt;= 前DD，或后ZD &gt; 前ZG且后DD =&lt; 前GG，则等价于形成高级别的走势中枢。 由定理一，可以得到第三类买卖点定理：一个次级别走势类型向上离开缠中说禅走势中枢，然后以一个次级别走势类型回试， 其低点不跌破ZG，则构成第三类买点；一个次级别走势类型向下离开缠中说禅走势中枢，然后以一个次级别走势类型回抽，其高点不升破ZD， 则构成第三类卖点。 例如，工商银行在12月14日构成典型的日线级别第三类买点；北辰实业在11月14日构成典型的日线级别第三类买点； 000803在1月20日构成典型的日线级别第三类卖点。注意，第三类买卖点比第一、二类要后知后觉，但如果抓得好， 往往不用浪费盘整的时间，比较适合短线技术较好的资金，但一定要注意，并不是任何回调回抽都是第三类买卖点，必须是第一次。 而且，第三类买卖点后，并不必然是趋势，也有进入更大级别盘整的可能，但这种买卖之所以必然赢利，就是因为即使是盘整， 也会有高点出现。操作策略很简单，一旦不能出现趋势，一定要在盘整的高点出掉，这和第一、二类买点的策略是一样的。 思考题一：第三类买卖点有可能和同级别的第二类买卖点重合吗？会 思考题二：工商银行在12月22日构成日线级别第三类买点吗？","link":"/posts/46500/"},{"title":"教你炒股票2：没有庄家，有的只是赢家和输家！","text":"庄家这种动物对大多数人来说很神秘，对本ID来说就太稀松平常了。庄家和散户这种二元对立，大概比较适合现代中国人的思维模式， 因此就变得如此的常识，但常识往往就是共同谬误的同义词，不仅是所谓的散户，而且很多的所谓庄家，也就牺牲其中。 一般定义中的所谓庄家，就是那些拿着大量资金，能控制股票走势的人。在有关庄家的神话中，庄家被描述成无所不能的， 既能超越技术指标、更能超越基本面，大势大盘就更不在话下了。这里说的还只是个股的庄家，至于国家级的庄家，更成了所谓散户的上帝。 关于这些庄家上帝的传闻在市场中一秒钟都不曾消停，构成了常识的谬误流播。 但所谓的庄家，前赴后继，尸骨早堆成了山。前几天在一个私人聚会里，还碰到一个50年代的老大叔，说已经准备了二十亿， 要坐庄，让本ID去联系一下某某公司的头。那人也是有头有脸的人了，不想当众奚落他，暗地里把他嘲笑了一番，简直是脑子锈着了。 当然，即使庄家的神话已经如此常识，这种傻人还是一直、也会继续前赴后继的。而正因为这种傻人如此的多，猎人打起猎来才能收获丰富。 看到越摆庄家谱的，猎人就越高兴，反正这类型的，基本在市场上混个几年就基本尸骨无存了。 市场没有什么庄家，有的只是赢家和输家！有的只是各种类型的动物，还有极少数的高明猎手。市场就是一个围猎的游戏， 当你只有一把小弓箭，你可以去打野兔；当你有了屠龙刀，抓几条蛇来玩当然就没劲了，关键你是否有屠龙刀！","link":"/posts/19521/"},{"title":"教你炒股票3：你的喜好，你的死亡陷阱！","text":"要世界杯了，在世界杯时谈论股票是一件很无趣的事情，而且，全世界的人都知道， 世界杯前后，股票市场几乎都要大跌，这个常识，虽然并不比所有有关所谓庄家的常识更值得常识， 但至少有趣，并不像所谓庄家一般无聊。还可以增加一句的是，足球至少有帅男， 而见过的如此之多的所谓庄家里，连长得不那么歪瓜裂枣的都少，这的确是实际情况，并不是开玩笑。 但你的喜好，就是你的死亡陷阱！在市场中要生存，第一条就是在市场中要杜绝一切喜好。 市场的诱惑，永远就是通过你的喜好而陷你于死亡。市场中需要的是露水之缘而不是比翼之情， 天长地久之类的东西和市场无关。市场中唯一值得天长地久的就是赢钱，任何一个来市场的人， 其目的就是赢钱，任何与赢钱无关的都是废话。必须明白，任何让你买入一只股票的理由， 并不是因为这股票如何好或被忽悠得如何好，只是你企图通过买入而赢钱，能赢钱的股票就是好的， 否则都是废话。因此，市场中的任何喜好，都是把你引入迷途的陷阱，必须逐一看破， 进而洗心革面，才能在市场上生存。 当然，能看清楚自己周围的市场陷阱，还只是第一步，更进一步，要学会利用市场陷阱来赢钱。 当你要买的时候，空头的陷阱就是你的最佳机会，当你要卖的时候，多头的陷阱当然就是你的天堂。 这市场，永远不缺卖在最低点，买在最高点的人，这世界上没有什么是可以让所有人赢钱的， 连大牛市中都有很多人要亏损累累。而市场中的行为，就如同一个修炼上乘武功的过程， 最终能否成功，还是要落实到每个人的智慧、秉性、天赋、勤奋上来！","link":"/posts/27951/"},{"title":"教你炒股票5：市场无须分析，只要看和干！","text":"喜欢吹牛皮的，在市场里最常见，例如一种以分析市场、吹牛皮为生的职业，叫什么股评、专家的。 此类人不过是市场上的寄生虫，真正的猎手只会观察、操作，用嘴是打不了豺狼的。 市场就是一个狩猎场，首先你要成为一个好猎手，而一个猎手，首先要习惯于无言。 如果真有什么真理，那真理也是无言的。可言说的，都不过是人类思想的分泌物，臭气熏天。 真不可言说了，就无不可言，言而无言，是乃真言。 一个好的猎手，可以没有嘴巴，但一定会有一双不为外物所动的眼睛，在这眼睛下， 一切如幻化般透明。要不被外物所动，则首先要不被自我所迷惑，其实无所谓外物、自我， 都不过幻化空花，如此，方可从容其中。 猎手只关心猎物，猎物不是分析而得的。猎物不是你所想到的，而是你看到的。相信你的眼睛， 不要相信你的脑筋，更不要让你的脑筋动了你的眼睛。被脑筋所动的眼睛充满了成见， 而所有的成见都不过对应着把你引向那最终陷阱的诱饵。猎手并不畏惧陷阱， 猎手只是看着猎物不断地、以不同方式却共同结果地掉入各类陷阱，这里无所谓分析， 只是看和干！ 猎手的好坏不是基于其能说出多少道道来，而是其置于其地的直觉。好的猎手不看而看， 心物相通。如果不明白这一点，最简单就是把你一个人扔到深山里，只要你能活着出来， 就大概能知道一点了。如果觉得这有点残忍，那就到市场中来，这里有无数的虎豹豺狼， 用你的眼睛去看，用你的心去感受，而不是用你的耳朵去听流言蜚语，用你的脑筋去抽筋！","link":"/posts/11535/"},{"title":"教你炒股票4：什么是理性？今早买N中工就是理性！","text":"很奇怪，在资本市场中经常有人在教导别人要理性。而所有理性模式后面， 都毫无例外地对应着一套价值系统为依据，企图通过这所谓的依据而战胜市场， 就是所有这些依据最大的心理依据，而这，就是所有资本谎言和神话的基础。 真正的理性就是要去看破各色各样的理性谎言，理性从来都是人YY出来的皇帝新衣， 这在哲学层面已不是什么新鲜的事情。 更可笑的是，被所谓理性毒害的人们，更经常地把理性当成一种文字游戏，当文字货币化以后， 这种文字游戏就以一种更无耻的方式展开了。但真正的理性从来都是当下的，从来都是实践的， 而实践，从来都是当下的理性。就像性是干出来的而不是说出来的，理性也一样。 站在资本市场的角度，就是所有的介入都是可介入从而被介入地介入着。 也就是所有的介入，当你介入时，市场与你就一体了，你创造着市场，从而市场也创造着你， 而这种创造都是当下的，从而也是模式化的。真正的理性关心的不是介入的具体模式如何， 而是这种模式如何被当下着，最重要的是，这种模式如何死去。 生的，总要死去，如果自然真有什么法则，这就是唯一的法则，市场上的法则也一样。 所谓法则，就是宿命。在市场中，死亡是常态，也是必然，而生存，必须以生为依据， 所谓生生不息，其实就是死死不息，当你被依据所依据时，其实已在死亡之中。 而生死，从来都是被当下所模式，资本市场也一样，以为离了生死也就无生死可了， 这不过是所谓理性的妄想。任何市场中人，都是被生死了的，生死无处可离， 生死就在呼吸之间，不离生死而从容于生死，没有这种大勇猛， 一切的理性都不过垂死的哀鸣。对于市场来说，介入就是介入生死， 无所依据地从容于各种模式之间，无所往而生其心，而心实无所生，方可于生死而从容。 对于市场的参与者来说，首要且时刻必须清楚自己目前介入模式的当下， 而市场中的绝大多数人，是不知道自己在干什么的，狠一点说， 就是死都不知道怎么死就死了，市场基本由这种人构成。这种构成与资金实力无关， 大资金死起来更快，一夜之间土崩瓦解的事情，本ID见得多了。此外， 如果你一定要很习惯地、理性地追问什么是理性，那么，相对那些光说不干的所谓理性， 今早15元多买N中工就是理性！理性是干出来的，今天，你干了吗？","link":"/posts/13784/"},{"title":"教你炒股票6：本ID如何在五粮液、包钢权证上提款的！","text":"最近忙着和孔二爷闹，满博客都是孔二爷，前两天耍了一下鲁超女活跃一下气氛， 今天想继续说说这“教你炒股票”系列。总不能整天都是孔二爷，也要照顾一下孔方兄， 都是姓孔的，一碗水要端平。 股票上永远不缺英雄，更永远不缺死去的英雄，最近的英雄们都又在吹投资， 但投资这内裤永远掩盖不了股票扒光后赤裸裸的投机。阴符云：“天性，人也；人心， 机也；立天之道以定人也。天发杀机，斗转星移；地发杀机，龙蛇起陆；人发杀机， 天地反覆；天人合发，万化定基。”不投这个机，又如何夺天地之造化？ 股票市场也是一样的。 对于本ID来说，这股票市场就如同提款机，时机到了，就去提款，时机不到， 就让他搁在那。市场就如同男人，整天管他就会犯贱，就会咬你。 所以男人不能经常搞，这市场也一样，必须耐心等待他的骚动，他不骚动，是不能搞的。 本ID曾写帖子“G股是G点，大牛不用套！”，连G点都不明白，是没资格谈论股票的。 如同要找到男人的G点，就要对这男人充分了解，要找到这市场的G点，其道理是一样的。 但就像光知道男人有G点还是不能乱搞，首先要了解他是干净的，是安全的， 否则高潮还没有就翘了，那不麻烦大了？这市场也是一样的，不是什么机会、 G点都要搞的，首先的前提要安全，要像去银行提款一样安全。 就像又有G点又干净的男人才值得搞，市场上也只有这样又安全又能G点的机会， 才值得投机。 就像四月份时本ID在五粮液、包钢认购权证上的布局。为什么选择他们而不是其他， 道理很简单，因为他们既有认购又有认沽，而对于企业来说，除非行情特别不好， 否则是不会让认沽兑现的，因为不兑现，这就是一个空头支票， 而兑现是要掏真金白银的。因此，对既有认购又有认沽的认购权证来说， 认沽和认购的行权价之间的差价，就是认购权证最安全的底线。对于五粮液、 包钢认购权证，这个底线就分别是1.02和0.43元。 而本ID当时分别在1元多和4毛多吃他们，是不是和去银行提款一样安全？ 唯一遗憾的是，他们的盘子都太小，属于小男人的类型，容纳不了太大的资金。 小男人，没什么劲；小盘的股票，也一样。 投机不是瞎搞，是要清清楚楚地搞。要清清楚楚，就要对市场充分地理解， 要明白其道道。本ID曾发明了一个口号在私下流传，就是“像搞男人一样搞股票， 像做爱一样做股票。”不明白这，没资格谈论股票。关于这个话题， 今天就到这，有时间、有心情，继续。","link":"/posts/15005/"},{"title":"教你炒股票7：给赚了指数亏了钱的一些忠告","text":"今天不宠幸孔二爷了，宠幸一下股票。早就说过，中国没有人有资格和本ID谈论股票。 国庆前，香港有几个大的基金经理过来，吃饭时让本ID给修理了一通，屁颠屁颠回去了。 本ID和他们说了大的国际经济趋势以及大中国区的金融前景还有内地的政治经济形势，坚定他们的信心， 他们主要是对内地的情况不了解，所以有所狐疑。最近这伙人干得不错，在市场里，干就往死里干， 不干白不干。把锅炒热了才有好菜吃，这道理不很简单？ 但这几个月还是有点烦，就是整天给一大叔骚扰。他钱不多，也就千万级别的资金规模， 这种人本ID从不搭理，但这大叔有点特殊，有些渊源，人家年纪又这么大，40好几了， 怎么都给点面子。但有时候，真想踹他两脚。4月份，本ID布局权证时，他就不敢买， 后来权证疯了，他就后悔。然后告诉他，年纪大了就不要玩太高风险的，买银行股吧， 民生，4块钱附近买了就搁着，结果赚了几毛钱就跑，真没出息。最可气的是， 国航跌破发行价时告诉他去买，他自己也当过兵，特别提醒他国航的李总当兵出身的， 怎么可能让自己的股票跌破发行价这么没面子？这大叔犹犹豫豫，N天时间也就买了点， 长起来几毛钱又走了。最近，让他在3元多吸纳北辰实业，4块不到就跑了，本ID简直对他彻底绝望。 不过他还算好，有部分钱在年初3、4块买了一只自己十分熟悉的北京股票，现在已经10块了， 但这大叔最麻烦的是，上下一波动就紧张，就打电话来骚扰本ID，本ID教他怎么在箱型盘整时弄短差， 这大叔，涨的时候不敢卖，跌的时候不敢买，本ID真服了他。 之所以说这，因为这种情况在散户中太常见。散户就如浮萍，没根，没主意，这样不给屠杀才怪了。 大概最近比这大叔更惨的，赚了指数亏了钱的也不在少数，本ID也废话一下，让有缘者得之。 去年破1000点前，本ID曾写“G股是G点”，今天5月刚突破后，本ID又写“大牛不用套！”， 但为什么有人竟然可以不挣钱？最主要是对牛市没信心，对牛市的节奏没把握。5月份前有色等的上涨， 不过是牛市的预热阶段，而目前以金融股等为代表的指数股上涨，是牛市的第一阶段。96年的时候， 深发展长了N倍了，很多股票还没怎么动。牛市的第一阶段都是这样的，一线股先长，它们不到位， 其他股票怎么长？全世界的牛市都基本这样子，没什么新鲜的。 错过了这个节奏怎么办？如果你跟盘技术还行的，就要在回档的时候跟进强势股票。散户就怕跌， 但牛市里，跌就是爹，一跌就等于爹来了，又要发钱了。如果跟盘技术不行，有一种方式是最简单的， 就是盯着所有放量突破上市首日最高价的新股以及放量突破年线然后缩量回调年线的老股， 这都是以后的黑马。特别那些年线走平后向上出现拐点的股票，一定要看好了。 至于还在年线下面的股票，先别看了，等他们上年线再说。其实， 这就是在牛市中最简单可靠的找所谓牛股的方法。举一个例子，去看看宝钢，突破年线后缩量回调， 10月23日回调4.20元，当时年线就在4.17元，然后再放量启动，今天，11月16日，已经6元多了， 50%就这么完成了。从年线上启动，先长个50%，不像玩一样？本ID一般只看大盘股票，小盘股没法进去， 但散户可以看小盘股，原则是一样的，不过小盘股可要留意，一般大盘股启动的骗线比较少， 小盘股可不一定，这都要自己好好去揣摩。散户就当好散户，别整天想着抄底、逃顶，底都让你抄了， 顶都让你逃了，不是散户的人吃什么去呀？散户，一定要等趋势明确才介入或退出，这样会少走很多弯路。 一只股票长起来千万别随意抛了，中线如果连三十天线都没跌破，证明走势很强，就要拿着。 当然，如果你水平高一点，在上涨的时候，根据短线指标可以打短差，这样可以增加资金的利用率， 但高位抛掉的，只要中线图形没走坏，回挡时一定要买回来，特别那些没出现加速的股票。 有一个抛股票的原则，分两种情况，一种是缓慢推升的，一旦出现加速上涨，就要时刻注意出货的机会； 另一种是第一波就火暴上涨，调整后第二波的上涨一旦出现背弛或放巨量的，一定要小心，找机会走人。 具体的操作是一个火候的问题，必须自己用心去体会，就像煲汤，火候的问题是没法教的， 只能自己在实践中体会。还有，对抛弃的股票一定不能有感情，股票就像男人， 玩过就扔，千万别有感情。 还有一点必须提醒，在牛市中，一定要严重关注成分股，特别有一定资金规模的，成分股都是大部队在战斗， 别整天跟那些散兵游勇玩，那些人自己都自身难保，本ID看这种所谓游资被消灭的都看到麻木了， 大资金就爱吃他们，几个亿几个亿吃他们，这才有点意思，否则吃小散户的几万几千，累不累呀？ 牛市中，最终所有股票都会有表现的机会，只是掌握了节奏，资金的利用率就高，一个牛市下来， 挣的钱如果不超出指数最终涨幅的几倍，指数长一倍，不挣个4、5倍，那就算废物点心了。 要达到这种水平，其实很简单，就一个原则：避开大的回挡，借回挡踏准轮动节奏。 千万别相信什么基本面的忽悠，特别对于散户来说，最多也就一亿几千万的钱，有必要研究什么基本面吗？ 所谓基本面，只是一个由头，给自己壮胆和忽悠别人用的。对基本面， 只要知道别人心目中的基本面以及相应的影响就可以了，自己千万别信。 本ID还是那句话，玩资本主义的游戏就要用资本主义的原则，既然玩股票了，就要心狠手辣， 市场从来不同情失败者，市场不需要焚尸炉，失败者的尸体在市场中连影子、味道都不会留下。 别给自己的失败找任何理由，失败只能是你自己的失败，失败就找机会扳回来， 但前提是必须找到失败的真正原因，否则不过是延续不同的情节、相同的悲剧。 希望来本博客的人，除了学《论语》、听音乐、看文章，还都能学会挣钱。 这个世界上最无耻下流的就是不会挣钱的人，你说钱是孙子，而你连孙子都搞不掂，那你最多就是龟孙子， 有什么资格说话？有钱不是大爷，没钱更不是大爷。在市场挣钱就如同打仗，九死一生，而最终能活着的， 就是牛人，牛人就要牛，这又有什么可说的？","link":"/posts/42615/"},{"title":"教你炒股票8：投资如选面首，G点为中心，拒绝ED男！","text":"中国人喜欢说反话，面首，“面”，绝不是首位的。选面首，先看面，终要看“里子”。何谓“里子”？就是“G点为中心，拒绝ED男！” 这也是本ID关于投资的警世之言。拿投资来忽悠的人，总爱编一些关于“面”的神话。诸如基本面、技术面、心理面、资金面， 这面那面，都如同面首之“面”，不过是进而“里子”的借口。没有“G点为中心，拒绝ED男！”的“里子”，这面那面又有何意义？ 投资的结果很简单，就“输、赢”两种。所有关于投资的理论把戏，都企图通过控制某种“输入”而把“输”这结果给去了。 因此一切相关的理论前提就必然建立在这样一个逻辑假设之上：输入与输出间被某种必然的逻辑关系和因果链条所连接。 而该逻辑假设，相当于说“面首的面和其里子有着必然的逻辑关系。”如果这都能成立，那么帅男就一定G点澎湃、 满面胡子的糙爷就一定非ED男，出去扒几个面首看看这类假设是何等荒谬。然而，现实中，企图跳过“面”而直捣“里子”， 同样是一种荒谬的幻想。即使“面”和“里子”没有任何必然的联系，但现实依然只能从“面”到“里子”。那种企图否定一切“面”的， 企图直接就“里子”就G点的，不过是把某种“面”当“里子”了。这种人，终生被骗而不知，就像把“叫床分贝”当高潮指标一样可笑。 投资领域，没有任何理论可以描述这种从“面”的输入到“里子”输出的必然关系，因为这种关系根本不存在。 但人只要介入这种投资游戏，其介入就必然要以某种方式进行，相应地，其后必然有着某种理论、信念的基础。 而正因为绝对正确的不存在，因此反而使得各种理论、信念基础之间有了比较的可能。任何好的投资理论，最终都只面向“里子”， 就如同一个好面首，必须最终以其G点的澎湃度来证明其优秀。相应的，投资市场最重要的指标就是高潮度， 一个长期没有高潮的市场，就如同没有G点的石男，是不值得任何关注的。期待一个石男变成一个优秀的面首，那是牧师的工作， 而投资市场不需要牧师。一个市场能进入可投资的视界，首先要显示其G点的萌动，否则还是一边凉快去吧。 世界，永远不缺G点萌动的男人去面首，同样，在世界总的市场体系中，永远不缺高潮萌动的市场。但大多数的散户， 就喜欢泡石男，以为石男没有攻击性就安全了，以为长期没有高潮的市场就一定安全。有多少人因此而独守空房、耗费青春， 整天听着看着别人高潮不断，最终寂寞难耐，走向另一个极端，见高潮就扑上去，如飞蛾一样死掉。 本ID曾言“像搞男人一样搞股票，像做爱一样做股票”。搞男人、做爱，最终都是要获得其高潮，最终采阳而补。投资也一样， 通过市场的高潮是要赚取其利润，是采利而补。可惜，市场上的人，大多数都让人当阳给采了，可笑可怜。要采阳而不要被采， 这就是和面首游戏的第一准则，而投资市场的道理也是一样的。 采阳，过熟不行，过生也不行，必须把握其火候。阳生，必有其萌动，必须待其萌动之后才可介入。具体对于股票来说， 按其是否萌动的标准把所有股票动态地进行分类，一种是可以搞的，一种是不能搞的，将你参与的股票限制在能搞的范围内， 不管任何情况，这是必须遵守的原则。当然，搞的分类原则，各人可以有所不同。 例如，250天线以及周线上的成交量压力线的突破；资金量不大且短线技术还可以的，可以把250天线改成70天线、35天线， 甚至改为30分钟图里的相应均线；对新股，可以用上市第一日的最高价作为标准；还有，就是接近安全线的股票， 例如在第六期里，本ID给出的一个带认沽权怔的认购权怔介入的安全线标准；而对于有一定水平的人，识别各种空头陷阱， 利用空头陷阱介入是一个很好的方法，这种方法比较专业点，以后专门说。 男人只有两种，能搞的和不能搞的；市场也只有两种，能搞的和不能搞的。必须坚持的是， 不能搞的就无论发生什么情况都不能搞，除非能达到某种能搞的标准而自动成为能搞的对象，就像用ED把男人进行分类一样， ED男只有非ED后才有进入被搞侯选集合的可能。一旦被搞的分类原则确定，就一定要严格遵守“只搞能搞的”原则。 可惜，这样一个简单的原则，绝大多数的人即使知道也不能遵守。人的贪婪使得人有一种企图占有所有机会的冲动， 就如同看到街上的所有男人都企图上去扒光他们一样，这种人叫“花痴”，“花痴”在投资市场的命运一定是悲惨的。 在投资市场，定好“能搞”的“G点萌动”标准，相应选出来的，至少不是ED男了。而接下来，就要防止其“早泄”。 这里找到有关“早泄”的医学定义：男子性功能障碍中仅次于阳痿的最常见的症状，是射精障碍中最常见的疾病， 发病率占成人男性的35%一50%。投资市场里，这“早泄”的比例和市场总体强度有关，在熊市中这比例至少是80%以上， 而牛市中这个比例就小多了，大概就30%。无论是选一个好面首还是一个好股票， 把“早泄”的一类给筛出去可是最重要也是最困难的一步，很多所谓的高手，就死在这一步上。 关于这问题，将在下一讲中详细论述。","link":"/posts/63419/"},{"title":"百度 iOS 面试真题总结（含一二三面深度解析）","text":"本文记录了百度 iOS 岗位的三轮面试经历，涵盖 iOS 基础、UI 响应链、内存管理、多线程、源码阅读、OpenGL 渲染、跨语言知识（如 Python &amp; JVM）等内容，适合希望进入百度等大厂的 iOS 工程师参考。 百度一面：基础知识 + 跨平台能力1. iOS 基础知识点涉及 UIViewController 生命周期、视图加载时机、UI 响应链、图片加载、图标内存大小估算等。 2. Python 基础知识考察线程安全、多线程与集合类、类继承、JVM 基础等跨平台知识点，体现广度能力。 3. iOS 源码阅读经验面试官关注是否阅读过 AFNetworking、YYModel、Masonry 等三方库源码，建议提前准备一两处代码逻辑作为回答素材。 4. OpenGL &amp; GLSurfaceView 基础图形绘制流程，包括 Shader 编程、FrameBuffer 配置、OpenGL 渲染管线的调用流程。 5. 项目优化实践主要围绕你负责的模块、性能优化方法（如卡顿检测、图片内存优化）、Crash 分析与修复方案等展开。 6. 多进程通信机制提到 Android 的 Binder/AIDL 机制，如果你有了解，也是体现技术深度和广度的加分项。 百度二面：深入理解 iOS 原理1. Delegate、Notification 和 KVO 对比 KVO：适合属性观察，自动触发，容易产生内存泄漏； Notification：解耦强，适合广播型通信； Delegate：一对一，强类型，结构清晰。 2. UI 中心视图实现方式考察 AutoLayout（约束）、frame 手动设置、居中布局等方法的灵活掌握。 3. 触摸事件响应机制 事件传递路径：UIApplication → UIWindow → ViewController → View； FirstResponder 的确定； UIResponder 链关系。 4. UIViewController 生命周期问题重点考察 loadView、viewDidLoad 的调用时机，以及仅 alloc 未使用的 VC 是否触发视图加载。 5. UILabel vs drawRect 性能比较系统控件（UILabel）通常自带优化；自绘方式性能高但复杂，适用于高度定制需求。 6. AFNetworking 是否支持 IPv6？考察是否了解苹果对 App 上架网络兼容性的要求，AF 在 iOS9+ 使用 NSURLSession 支持 IPv6。 7. 64 位架构与 i386 区别 i386 是 32 位模拟器架构； x86_64 是 64 位； arm64 是真机架构； 64 位系统提供更大的寻址空间、更高性能。 8. iOS 应用状态及后台执行iOS 应用状态包括：Not running、Inactive、Active、Background、Suspended。退到后台时可使用任务保持短时间执行。 9. 图片内存计算例如 200×300 RGBA 图片：200 × 300 × 4 = 240000 bytes ≈ 234KB。 10. Block 内存泄漏问题Block 默认强引用外部变量（如 self），容易造成 retain cycle，需使用 __weak 或 __block。 11. [object copy] 是浅拷贝还是深拷贝？多数情况下是浅拷贝，除非手动实现 copyWithZone: 方法。需遵循 NSCopying 协议。 12. Images.xcassets 的优势支持 @2x/@3x 自动加载、内存优化、打包统一管理等，推荐使用。 百度三面：底层机制 + 架构理解这一面偏重对核心知识点的深度理解，问题极其细致。 1. 内存管理原理涉及 ARC 自动引用计数、弱引用释放机制、AutoreleasePool 生命周期等。 2. 多线程基础了解 GCD、NSOperationQueue 的实现与使用场景。 3. 队列与线程模型主队列、串行/并发队列、栅栏函数、线程同步策略的优劣。 4. 线程锁机制 @synchronized：简单但性能差； NSLock、NSRecursiveLock、dispatch_semaphore、pthread_mutex 的应用场景； 死锁成因及避免方式。 5. MVVM 架构设计数据与视图的解耦思维、数据绑定技术（如 KVO、RAC）、MVVM 和 MVC 的取舍。 面试总结 &amp; 准备建议百度的 iOS 面试难度不低，知识广度 + 深度要求都较高。涵盖了语言底层、UI 响应机制、网络、多线程、内存优化、架构设计等多个维度。 🎯 推荐重点准备方向： Objective-C Runtime、KVO 实现、消息转发机制 ARC 内存管理 + Retain Cycle 处理策略 多线程并发处理（GCD、锁机制） 网络栈基本流程、IPv6 支持 自定义 UI 控件、性能优化 架构能力（MVC/MVVM、组件化） 💡 希望这篇《百度 iOS 面试真题总结》对你有所帮助！如果你正在准备大厂面试，不妨将这些问题整理成知识图谱，逐个击破，祝你早日拿到满意 offer 🚀","link":"/posts/9fcf0002/"},{"title":"美团最新 iOS 面试真题总结（多线程、架构、网络、内存管理等）","text":"本文整理了美团 iOS 岗位面试中常见的真题及面试官关注的知识点，涵盖多线程、网络协议、架构设计、内存管理等核心内容。适合准备美团及大厂 iOS 面试的同学参考。 一面题目（项目经验 + 多线程 + 网络协议 + 适配） 简历项目详述，面试官针对项目细节提问 Android Volley 源码及图片缓存机制深入探讨，讨论 HTTP 缓存机制 iOS 视图控制器（ViewController）生命周期理解 数据库相关知识 多线程相关知识点：NSThread、NSOperation、GCD+Block HTTP 协议 GET 和 POST 区别 手机屏幕适配方案 真机调试技巧及项目上线注意事项 静态方法是否可以被重写及相关讨论 面试官语速较快，需要注意答题节奏，保持从容 二面题目（Objective-C基础 + 设计模式 + 单元测试） id 和 nil 的含义及区别（nil 与 NULL 区别） 向 nil 对象发送消息的行为 HTTP 同步与异步的区别 MVC 与 MVVM 架构区别及实现 业务示例： VC 入口，VC1 显示“省”列表，VC2 显示“市”列表，VC3 显示“县”列表 设计 ViewModel 和 Model 的结构 VC3 跳转回 VC 的设计 单元测试设计：网络库测试用例设计及覆盖点 从 Git 拉代码到生成 .ipa 文件的全过程及涉及文件 近期阅读的书籍和开源框架及收获分享 JSPatch 如何处理 Block 擅长领域和职业挫折经历分享 新增问题：无 Instruments 工具时如何检测内存泄漏（Memory Leak）和僵尸对象（Zombie） 三面题目（资源管理 + 网络协议 + 设计模式 + 算法） iOS 资源管理机制详解 Python 语言的重要特性介绍 网络五层结构及各层协议 补充问答：MAC 地址与 IP 地址区别 单例模式与全局变量区别 Block 与 Protocol 区别及 Block 的设计目的 iOS 中常用设计模式介绍 为什么 iOS 没有类似 Java 或 C++ 的 Builder 构造模式 冒泡排序、插入排序、快速排序的平均与最坏时间复杂度 堆排序简介 是否存在时间复杂度为 O(n) 的排序算法 近期解决的 Stack Overflow 问题分享 读过的开源框架和书籍推荐 业余兴趣和成就感经历 总结美团 iOS 面试侧重基础扎实、项目实战经验丰富，尤其强调多线程理解、架构设计能力及网络协议掌握。建议重点准备： iOS 生命周期和内存管理（ARC/MRC） 多线程及GCD使用 MVC与MVVM设计模式理解 网络协议及异步处理 算法复杂度及常见排序算法 单元测试及代码质量保障 Runtime及消息机制 祝你面试成功，顺利拿下美团 iOS 岗位！如需详细讲解或代码示例，欢迎随时联系。","link":"/posts/dac8b918/"},{"title":"阿里巴巴 iOS 面试真题总结（含一二三面详解）","text":"本文总结了阿里巴巴 2024 年 iOS 面试中的经典真题，涵盖三轮面试，内容包括底层原理（KVO、Block、Runtime）、性能优化、线程安全等问题。适合正在准备 iOS 面试的同学参考。 阿里一面真题回顾这轮面试以基础原理为主，涉及 Objective-C Runtime、KVO、Block、字典原理和方法替换技术等。 1. KVO 是如何知道对象发生变化的？考察 Objective-C 的动态特性，涉及 isa-swizzling、NSKeyValueObserving 的底层实现。 2. NSDictionary 是如何实现快速查找的？哈希表结构，查找操作的时间复杂度趋近 O(1)，考察哈希函数设计与冲突处理策略。 3. 不破坏原方法，如何修复潜在 bug？推荐使用 Method Swizzling 技术或 AOP 思维，保持原接口不变的前提下增强逻辑。 4. Block 和函数指针的区别？Block 是带上下文的对象，支持捕获外部变量；函数指针是纯函数地址，效率高但灵活性差。 5. 性能优化的手段有哪些？内存管理、懒加载、线程调度优化、避免主线程卡顿、图片缓存处理等。 6. YYModel 和 AFNetworking 源码分析要求你对第三方库内部结构有基本认知，至少理解 AF 的请求封装流程和 YYModel 的动态绑定过程。 7. 如何自己设计 JSON -&gt; Model 转换？如可用 KVC、Runtime + 属性枚举等方式封装通用转换逻辑。 阿里二面真题详解侧重于内存管理、线程机制与设计思想，问题较为深入。 1. 浅拷贝和深拷贝的区别？浅拷贝仅复制指针引用；深拷贝会开辟新空间并复制内容，通常实现 copyWithZone: 方法。 2. Block 循环引用与解决方案？Block 捕获强引用对象如 self，造成循环引用，常用 __weak 或 __block 打破循环。 3. Block 与 delegate 比较？Block 更轻便、适合短期回调；delegate 适合长期、结构化通信。 4. KVO 的实现原理？本质是 isa 指向中间类，实现 set 方法的重写并通知观察者。 5. AutoreleasePool 的实现原理？调用栈会创建多个 autorelease pool，底层基于双向链表结构管理对象释放。 6. 消息转发机制？三重转发机制：resolveInstanceMethod: → forwardingTargetForSelector: → forwardInvocation:，是 iOS 动态特性的核心。 7. 死锁的四个必要条件？互斥、占有且等待、不可抢占、循环等待，任意破坏一个即可避免死锁。 8. 进程与线程的区别？进程是资源分配的基本单位，线程是执行调度的基本单位，线程共享进程内存。 9. 数据持久化方案？NSUserDefaults、归档、SQLite、CoreData、Keychain 等。 10. Masonry 的约束应该写在哪里？面试中讨论应放在 updateConstraints 或 layoutSubviews，需权衡复用次数与性能。 阿里三面：场景题 &amp; 架构思维三面偏向项目实战经验和系统设计思维。 1. 项目难点与解决方案介绍自我介绍和项目挑战重点是沟通能力和技术深度的双重考察。 2. 主线程是相对于什么而言？相对于操作系统调度中的主执行队列（main dispatch queue），即 UI 操作需在主线程执行。 3. 图片内存占用由什么决定？内存大小 = 宽度 × 高度 × 每像素字节数（RGBA 为 4），与图片压缩格式无关。 4. 索引的作用及优缺点？加快数据检索速度；但增加写入负担、占用存储、需要维护。 5. 如何在数组中找最小的 K 个数？常用方法包括快排变种、最小堆、Partition 算法等。 6. 淘宝下拉加载更多如何优化？预加载、懒加载、分页请求、防抖节流、接口合并、骨架屏设计等。 7. 淘宝页面发起 HTTP 请求流程？从点击触发 → Controller → ViewModel/Service → 网络库（如 AF）→ 请求封装 → 数据返回 → 数据绑定。 8. 介绍 MVVM 架构及应用？Model-View-ViewModel 解耦视图和逻辑，ViewModel 负责业务逻辑转换和绑定数据源。 9. 你了解哪些设计模式？单例、观察者、工厂、策略、责任链、适配器、代理等；可结合项目阐述其使用场景。 面试总结 &amp; 建议通过这次阿里 iOS 面试可以看出重点包括： 语言底层机制：KVO、Runtime、AutoreleasePool、Block 原理等； 性能与架构能力：如网络优化、内存管理、线程调度； 实战与沟通能力：项目介绍、逻辑思维、代码能力； 系统设计思维：索引、并发、缓存、架构模式等。 📝 准备建议： 回顾 iOS 面试八股文知识点； 多刷高频题，多做 Mock Interview； 建立知识图谱，串联底层原理与应用场景； 敢于表达自己的观点，结合项目经历讲解思路。 希望本文能帮助到正在准备 iOS 面试的你，祝你顺利拿到心仪的 Offer！🚀","link":"/posts/eabb475c/"},{"title":"腾讯最新iOS面试真题总结（网络、架构、算法与多线程）","text":"本文整理了腾讯 iOS 岗位面试中常见真题，涵盖网络请求、线程与进程、内存管理、设计模式、常见算法等多方面内容。适合腾讯及其它大厂iOS面试准备。 一面题目 介绍实习项目及分工 项目内容、个人负责的功能模块、所用技术栈等。 网络相关 用过哪些网络库？ASIHTTP了解吗？ 断点续传实现及相关设置。 访问速度差异分析：杭州请求快，深圳请求慢，如何排查？ HTTP请求常用方法（GET、POST、PUT），各自使用场景。 TCP建立连接过程、断开连接过程，为什么是“四次握手”。 数据存储 项目中用过哪些存储方式？iOS中常见数据存储方式及适用场景。 MVVM实现绑定机制 Block和通知的区别及适用场景 算法题 多个数组相关的递进算法题，重点是找出数组中重复数字。 进程和线程的区别 程序运行时，操作系统除了分配内存外还做什么？ 进程间通信方式 如何检测应用卡顿 Crash日志收集机制 如何在无第三方平台情况下收集崩溃日志？第三方平台的工作原理。 Block中使用@property是否会造成循环引用？如何避免？ 是否可以用self-&gt;_property或valueForKey访问？ Block中是否可以修改属性值？如何正确操作。 二面题目 Objective-C对象结构 多态机制 Ping协议是什么？ MTU（最大传输单元）了解多少？ ARC和MRC的本质区别 NSThread、GCD、NSOperation的使用 如何开启线程？线程能取消吗？ 子线程调用Connection为何不回调？ 因为未加入RunLoop，执行完即销毁。 MVC与MVVM的区别 了解哪些设计模式？ 设计通讯录的数据结构支持增删改查 autorelease对象何时释放？ 手动添加释放时机（大括号结束），系统自动释放时机（RunLoop循环结束）。 子线程中的autorelease变量何时释放？需要加autoreleasepool吗？ GCD与NSOperation区别 死锁的理解及解决经验 ViewController生命周期 init方法里设置背景颜色会生效吗？为什么？ WWDC 2016新特性了解 源码阅读经验分享 链表相关算法题 找两个链表的第一个相同节点 字符串旋转判断 找链表倒数第k个节点 将链表中比某值大的节点放左边，比它小的放右边 二叉树中序遍历（非递归实现） 总结腾讯iOS面试考察广泛，注重理论基础与实践结合。建议重点准备： 网络请求与协议原理 进程线程与内存管理机制 iOS架构设计模式 Block及运行时机制 多线程与死锁防范 常见数据结构与算法 欢迎留言交流，分享面试经验与题解，祝你面试顺利通过腾讯大厂！","link":"/posts/ff34586f/"},{"title":"教你炒股票9：甄别“早泄”男的数学原则！","text":"设计一个程序，将所有投资对象进行分类，只搞那些能搞的，这是投资的第一原则。在分类中， 所应用的程序可以各色各样，但有一点是肯定的， 即没有任何一个程序可以使得所选能搞的最终都百分百能被搞得高潮迭起， 就像没有任何一个挑选面首的程序使得所选能搞的最终都能百分百被搞得高潮迭起。 因为任何操作程序都必然面对“早泄”问题，就像任何关于面首的选择都必然面临“早泄”男的甄别问题。 而甄别“早泄”之所以困难重重，使得无数所谓高手死无葬身之地， 是因为“早泄”这事还真得真刀真枪地实干才能发现，这比ED的甄别可复杂多了、风险大多了。 ED，不需要深入介入就可趁早发现，但“早泄”不可以，怎么都要试上一试，而这玩意是一锤子的买卖， 这次行还不能保证下次就一定行，因此要有效甄别、及早发现而减少损失就成了一个头号难题。 许多所谓高手会宣称，出现什么情况，这股票就会长。但实际上，任何一种情况， 都有着极高百分比的可能会出现“早泄”，确定能搞的突然就变成不能搞了，使得介入变成了套牢。 这种情况，在投资里简直太常见了。 那么，如何甄别“早泄”男？首要的就是严格的资金管理，一旦出现“早泄”现象，必须马上退出， 即使下面突然又不“早泄”了，又强力高潮了，也必须这样干。而且“早泄”特敏感， 一个偶尔的因素就可能导致，而要重新再来，还要等待一个长的不应期，一个长的调整过后， 即使会高潮不断，也浪费了时间，有这时间，可搞的东西多了去了，这世界又不只有一个面首、 一只股票。当然，这里说的只是基本原则，如果有一套严格的分批介入和退出程序，这一切都变得简单。 资金管理问题，涉及面很广，以后会专门分析介绍，这里说的是另一个方面， 就是如何能在投资领域尽量避免碰到“早泄”男。 “早泄”出现的根本原因在于介入程序出现破缺，出现程序所不能概括的异常情况， 这对于所有程序都是必然存在的。而一个程序出现异常，也就是出现“早泄”的概率有多大， 这是可以通过长期的数据测试来确定的。最简单的就是抛硬币，正面买、背面不买， 这样也算一个介入程序，但这样一个程序的“早泄”率，至少是50%。 以上。现在的问题其实很简单，就是如何发现一个“早泄”率特别低的介入程序。但答案很不幸， 任何一个孤立的程序都不会有太低的“早泄”率，如果一个程序的“早泄”率低于10%， 那就是超一流的程序了，按照这个程序，你投资10次，最多失误1次，这样的程序是很厉害的， 基本没有。 但问题不像表面所见那么糟，在数学中，有一个乘法原则可以完全解决这个问题。 假设三个互相独立的程序的“早泄”率分别为30%、40%、30%，这都是很普通的并不出色的程序。 那么由这三个程序组成的程序组，其“早泄”率就是30%*40%*30%=3.6%，也就是说，按这个程序组， 干100次，只会出现不到4次的“早泄”，这绝对是一个惊人的结果。即使对于选面首来说， 有这样的高效率，大概连武则天大姐都要满意了。 现在，问题的关键变成，如何去寻找这三个互相独立的程序。首先，技术指标， 都单纯涉及价量的输入而来，都不是独立的，只需要选择任意一个技术指标构成一个买卖程序就可以。 对于水平高点的人来说，一个带均线和成交量的K线图，比任何技术指标都有意义。 其次，任何一个股票都不是独立的，在整个股票市场中，处在一定的比价关系中， 这个比价关系的变动，也可以构成一个买卖系统，这个买卖系统是和市场资金的流向相关的， 一切与市场资金相关的系统，都不能与之独立；最后，可以选择基本面构成一个甄别“早泄”男程序， 但这个基本面不是单纯指公司赢利之类的，像本ID在前几期所说， 国航李总当兵出身不会让自己的股票长期跌破发行价这么没面子，还有认沽权证基本不会让兑现等等， 这才是更重要的基本面，这需要对市场的参与者、对人性有更多的了解才可能精通。 当然，上面这三个独立的程序只是本ID随手而写，任何人都可以设计自己的独立交易程序组， 但原则是一致的，就是三个程序组之间必须是互相独立的，像人气指标和资金面其实是一回事情， 各种技术指标都是互相相关的等等，如果把三个非独立的程序弄在一起，一点意义都没有。 就像有人告诉你，面首的鼻子大就不会“早泄”，另一个告诉你耳朵大不会“早泄”， 第三个告诉你胡子多不会“早泄”，如果真按这三样来选人， 估计连武则天大姐的奶妈的邻居都会不满意的。 借地说说如何看本ID的文章，本ID不是股评，不会推荐什么股票， 所以希望来本ID这里知道什么具体股票的，就不要浪费时间了。试想，真有本事的人， 挣钱都忙不过来，怎么会当股评。本ID这里，股票只是其中一个小项目， 只是希望来这里的人也学会怎么挣钱。所谓六艺，不会挣钱，在经济社会里还算人吗？ 看本ID的文章，要学会方法，当然，本ID有时候可能有意无意就会透露点东西，但你必须有分析能力， 要吃透方法。就像10月24日告诉你认购权证介入的一个原则，26日武钢认购权证就大幅启动， 2周从3毛多长到1块多，翻了快4倍，如果你真能吃透本ID所说的方法，这种机会是可以把握的。 至于现实的股市，本ID在前面已经反复说了，只要是牛市，股票都要表现的， 前几天大家可能都很烦银行股，因为大家都没有，但昨天开始大家就高兴了，因为银行股不动， 其他股票开始动。别恨银行股，哪天它们真见顶了，市场也好不了，它们是红旗， 各位只要看着红旗还在打，各根据地就可以继续轮动大干了。股票的运动是有规律的，好好学习， 这一切都能在你的把握中。至于说本ID想炫耀自己，这种废话根本不值得反驳。 本ID在投资市场曾干过事情牛的程度超过你们所有人的想象，本ID还用向你们炫耀？ 本ID现在只是把东西抖点出来，活跃一下博客的气氛，没有其他任何想法。","link":"/posts/38803/"},{"title":"教你炒股票1：不会赢钱的经济人，只是废人！","text":"“教你炒股票”这样的题目，全中国不会有第二人比本ID更适合写的。当然，股票是炒出来的，不是写出来的，因此也从未想过写这样的题目。 但任何事情都是有缘起的，缘分到了，也不妨写上一写。 人，总是很奇怪的，就算是很聪明的人，或者在其他行业很成功的人，一旦进入资本市场，就像换了人。虚拟和现实的鸿沟使得干实业的， 且不说期货了，就算到风险小的多的股市，也很少能干好的。而习惯在虚拟市场玩游戏的，基本很难回头去弄实业，这些例子都太多了。 周围朋友和经济有关的，干金融的比较多，也有几个干实业的。去年人民币放开后，有次和他们一起玩，偶然聊起股票。 当时给他们的意见是，由于资源的全球化升势及人民币的升值，国内实业将有很大的困难，而虚拟市场由于对资本的吸纳作用将大有改观， 会出现一个至少是大X浪级别的行情，劝他们应该分流部分资金到资本市场来。由于前几年资本市场上出事的人一拨接一拨，这帮家伙很犹豫，一晃就把时间过了。 今年，过完春节，这帮家伙突然开始不断骚扰本ID，说要入市。本ID当时已经忙得无暇分身，对他们一番数落，然后告诉他们， 现在是个人都能挣钱，自己玩去，没空理你们。进入三、四月份，当时有色等行情已经很火暴，这帮家伙想大进又怕风险，一直在小打小闹。 有一天，又在一起玩，他们一定要本ID选择一些具体的股票。因为这两年一直有很多外资大基金进来接触要收中国快速消费品的企业， 还有就是一些大的周期行业将面临重组，就让他们去关注这两类股票和权证。 五月份后，股市大涨，大家都很忙，中旬时又有机会碰头，一问之下，基本都没怎么大买，买了的也没几个站就下车了。他们都显得很烦躁， 不断问有什么可买的。既有点可怜又有点烦他们，怎么在市场外弄得好好的，一到市场里都成这样了？就有点敷衍地告诉他们， 去买深沪两地3元上下的本地股，而且告诉他们，这样下去肯定要出问题的，最好自己好好学学，别人怎么厉害也不可能整天像照顾小孩一样看着。 上周日，又碰在一起。这几位，大概都一肚子股票了，这次个个神采飞扬；大概又都刨了几本书，听了几股评，看了几杂志，更是口水喷喷地这面那面、 一线二线地专家了，1800、2000、2500点地牛人了。这市场，还真能改造人！只是这市场的绞肉机，又有新货了。 有人说，市场是老人挣新人的钱，而市场中的老人，套个10年8年的一抓一大把。其实，市场从来都是明白人挣糊涂人的钱。 在市场经济中，只要你参与到经济中来，就是经济人了，经济人当然就以挣钱为目的，特别在资本市场中，没有慈善家，只有赢家和输家。 而不会赢钱的经济人，只是废人！无论你在其他方面如何成功，到了市场里，赢输就是唯一标准，除此之外，都是废话。","link":"/posts/23231/"},{"title":"虎牙最新 iOS 面试真题总结（含 ARC、RunLoop、多线程、网络等）","text":"本文汇总了虎牙 iOS 面试中遇到的最新真题，涵盖项目架构、内存管理、锁机制、网络协议、多线程、视频技术等多个核心模块，适合准备大厂 iOS 岗位的同学参考学习。 面试说明由于时间有限，本文主要记录真题与核心知识点，未提供全部详细答案。欢迎交流和补充。 一面题目（项目架构+底层原理+锁） 项目架构是自己设计的吗？请介绍一下 FPS（帧率）是怎么计算的？ 除了 CADisplayLink，还有哪些计算 FPS 的方法？ KVO（键值观察）是如何实现的？ Leaks 是怎么实现的？ 如何通过代码监听僵尸对象？ imageWithName 方法什么时候发生图片解码？在哪个线程？ isa 指针里面包含哪些信息？ Objective-C 消息发送和消息转发的流程？ 函数的参数是如何存储的？ OC 空函数里面有参数吗？ 参数存储在栈还是寄存器？ 红黑树查找的时间复杂度？ NSDictionary 是如何实现的？ iOS 中常见的锁有哪些？ 如何实现 dispatch_once？需要考虑哪些问题？ 同一线程里连续使用两个 @synchronized，是递归锁还是非递归锁？ 如何增加按钮的点击范围？ 二面题目（内存管理+消息机制+网络协议） ARC（自动引用计数）原理介绍 autoreleasepool 的作用及使用场景 autoreleasepool 中的对象什么时候释放？ 消息转发可以用来做什么？ RunLoop 是什么？你用 RunLoop 做过什么？ C++ 多态和虚函数表机制 TCP 如何保证数据传输的完整性？ TCP 为什么需要三次握手？ HTTP 和 HTTPS 全程都是非对称加密吗？ 面对乱序数据，你如何设计排序方案？ 对 RxSwift 的看法，实际项目中用过吗？ 三面题目（对象内存+网络+多线程+视频） iOS 对象指针大小是多少？ 对象分配是在堆还是栈？ HTTP 请求如何区分 Header 和 Body？ 多线程能否同时访问同一个对象？多进程呢？ 视频中的 PTS 和 DTS 是什么？ 视频丢帧时，是丢 PTS 好还是丢 DTS 好？ iOS 各种锁的性能如何？锁的粒度是毫秒还是微秒级别？ HTTP 请求是异步还是同步？ 你怎么看待 React Native 和 Flutter？ 核心知识点总结 主题 关键内容 项目架构 MVC/MVVM、模块化设计、性能优化 FPS计算 CADisplayLink、Core Animation KVO实现 isa-swizzling、消息转发 内存管理 ARC、自动释放池、引用计数 锁机制 OSSpinLock、NSLock、pthread_mutex RunLoop 事件监听、模式切换、定时器管理 网络协议 HTTP/HTTPS、TCP三次握手、数据完整性 多线程 GCD、NSOperation、线程安全 视频技术 PTS/DTS、丢帧策略 跨平台框架 React Native 与 Flutter 对比 参考建议 重点掌握底层原理，尤其是内存管理与锁机制 熟悉网络通信协议及传输安全机制 理解多线程同步与死锁问题 视频相关基础理论及实践经验 对跨平台方案有基本认知和评价能力 欢迎大家点赞收藏，有任何问题或经验分享，欢迎留言交流！祝你面试顺利，早日拿下心仪的 iOS 岗位！","link":"/posts/7c0066a7/"}],"tags":[{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"IP策略","slug":"IP策略","link":"/tags/IP%E7%AD%96%E7%95%A5/"},{"name":"负载均衡","slug":"负载均衡","link":"/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"sing-box","slug":"sing-box","link":"/tags/sing-box/"},{"name":"网络优化","slug":"网络优化","link":"/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"},{"name":"IPv6","slug":"IPv6","link":"/tags/IPv6/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"分流","slug":"分流","link":"/tags/%E5%88%86%E6%B5%81/"},{"name":"广告拦截","slug":"广告拦截","link":"/tags/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/"},{"name":"DoH","slug":"DoH","link":"/tags/DoH/"},{"name":"DoT","slug":"DoT","link":"/tags/DoT/"},{"name":"DoQ","slug":"DoQ","link":"/tags/DoQ/"},{"name":"DNSCrypt","slug":"DNSCrypt","link":"/tags/DNSCrypt/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"反向解析","slug":"反向解析","link":"/tags/%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90/"},{"name":"网络加速","slug":"网络加速","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"name":"配置优化","slug":"配置优化","link":"/tags/%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"name":"域名分类","slug":"域名分类","link":"/tags/%E5%9F%9F%E5%90%8D%E5%88%86%E7%B1%BB/"},{"name":"Clash","slug":"Clash","link":"/tags/Clash/"},{"name":"网络策略","slug":"网络策略","link":"/tags/%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/"},{"name":"iOS面试题","slug":"iOS面试题","link":"/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Block","slug":"Block","link":"/tags/Block/"},{"name":"NSNotification","slug":"NSNotification","link":"/tags/NSNotification/"},{"name":"Runloop","slug":"Runloop","link":"/tags/Runloop/"},{"name":"Runloop&amp;KVO","slug":"Runloop-KVO","link":"/tags/Runloop-KVO/"},{"name":"Runtime","slug":"Runtime","link":"/tags/Runtime/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"},{"name":"视图&amp;图形","slug":"视图-图形","link":"/tags/%E8%A7%86%E5%9B%BE-%E5%9B%BE%E5%BD%A2/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"通知机制解析","slug":"通知机制解析","link":"/tags/%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"},{"name":"iOS面试真题","slug":"iOS面试真题","link":"/tags/iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"},{"name":"头条","slug":"头条","link":"/tags/%E5%A4%B4%E6%9D%A1/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"快手","slug":"快手","link":"/tags/%E5%BF%AB%E6%89%8B/"},{"name":"iOS基础","slug":"iOS基础","link":"/tags/iOS%E5%9F%BA%E7%A1%80/"},{"name":"架构设计","slug":"架构设计","link":"/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"name":"网络通信","slug":"网络通信","link":"/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"系统底层","slug":"系统底层","link":"/tags/%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82/"},{"name":"抖音","slug":"抖音","link":"/tags/%E6%8A%96%E9%9F%B3/"},{"name":"iOS开发","slug":"iOS开发","link":"/tags/iOS%E5%BC%80%E5%8F%91/"},{"name":"股票投资","slug":"股票投资","link":"/tags/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84/"},{"name":"投机市场","slug":"投机市场","link":"/tags/%E6%8A%95%E6%9C%BA%E5%B8%82%E5%9C%BA/"},{"name":"人民币升值","slug":"人民币升值","link":"/tags/%E4%BA%BA%E6%B0%91%E5%B8%81%E5%8D%87%E5%80%BC/"},{"name":"投资心态","slug":"投资心态","link":"/tags/%E6%8A%95%E8%B5%84%E5%BF%83%E6%80%81/"},{"name":"拼多多","slug":"拼多多","link":"/tags/%E6%8B%BC%E5%A4%9A%E5%A4%9A/"},{"name":"JSON解析","slug":"JSON解析","link":"/tags/JSON%E8%A7%A3%E6%9E%90/"},{"name":"多线程安全","slug":"多线程安全","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"事件响应","slug":"事件响应","link":"/tags/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"},{"name":"缠中说禅","slug":"缠中说禅","link":"/tags/%E7%BC%A0%E4%B8%AD%E8%AF%B4%E7%A6%85/"},{"name":"股票","slug":"股票","link":"/tags/%E8%82%A1%E7%A5%A8/"},{"name":"投资","slug":"投资","link":"/tags/%E6%8A%95%E8%B5%84/"},{"name":"教你炒股票","slug":"教你炒股票","link":"/tags/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A8/"},{"name":"技术分析","slug":"技术分析","link":"/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"},{"name":"茅台","slug":"茅台","link":"/tags/%E8%8C%85%E5%8F%B0/"},{"name":"买点定律","slug":"买点定律","link":"/tags/%E4%B9%B0%E7%82%B9%E5%AE%9A%E5%BE%8B/"},{"name":"趋势判断","slug":"趋势判断","link":"/tags/%E8%B6%8B%E5%8A%BF%E5%88%A4%E6%96%AD/"},{"name":"均线系统","slug":"均线系统","link":"/tags/%E5%9D%87%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"name":"背驰理论","slug":"背驰理论","link":"/tags/%E8%83%8C%E9%A9%B0%E7%90%86%E8%AE%BA/"},{"name":"买卖策略","slug":"买卖策略","link":"/tags/%E4%B9%B0%E5%8D%96%E7%AD%96%E7%95%A5/"},{"name":"趋势分析","slug":"趋势分析","link":"/tags/%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%90/"},{"name":"资金管理","slug":"资金管理","link":"/tags/%E8%B5%84%E9%87%91%E7%AE%A1%E7%90%86/"},{"name":"股票操作","slug":"股票操作","link":"/tags/%E8%82%A1%E7%A5%A8%E6%93%8D%E4%BD%9C/"},{"name":"投资策略","slug":"投资策略","link":"/tags/%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5/"},{"name":"带套操作","slug":"带套操作","link":"/tags/%E5%B8%A6%E5%A5%97%E6%93%8D%E4%BD%9C/"},{"name":"买卖程序","slug":"买卖程序","link":"/tags/%E4%B9%B0%E5%8D%96%E7%A8%8B%E5%BA%8F/"},{"name":"股票走势","slug":"股票走势","link":"/tags/%E8%82%A1%E7%A5%A8%E8%B5%B0%E5%8A%BF/"},{"name":"缠论走势中枢","slug":"缠论走势中枢","link":"/tags/%E7%BC%A0%E8%AE%BA%E8%B5%B0%E5%8A%BF%E4%B8%AD%E6%9E%A2/"},{"name":"趋势与盘整","slug":"趋势与盘整","link":"/tags/%E8%B6%8B%E5%8A%BF%E4%B8%8E%E7%9B%98%E6%95%B4/"},{"name":"买卖点理论","slug":"买卖点理论","link":"/tags/%E4%B9%B0%E5%8D%96%E7%82%B9%E7%90%86%E8%AE%BA/"},{"name":"缠论","slug":"缠论","link":"/tags/%E7%BC%A0%E8%AE%BA/"},{"name":"走势中枢","slug":"走势中枢","link":"/tags/%E8%B5%B0%E5%8A%BF%E4%B8%AD%E6%9E%A2/"},{"name":"走势延伸","slug":"走势延伸","link":"/tags/%E8%B5%B0%E5%8A%BF%E5%BB%B6%E4%BC%B8/"},{"name":"市场规律","slug":"市场规律","link":"/tags/%E5%B8%82%E5%9C%BA%E8%A7%84%E5%BE%8B/"},{"name":"投资理念","slug":"投资理念","link":"/tags/%E6%8A%95%E8%B5%84%E7%90%86%E5%BF%B5/"},{"name":"买卖点","slug":"买卖点","link":"/tags/%E4%B9%B0%E5%8D%96%E7%82%B9/"},{"name":"庄家","slug":"庄家","link":"/tags/%E5%BA%84%E5%AE%B6/"},{"name":"赢家与输家","slug":"赢家与输家","link":"/tags/%E8%B5%A2%E5%AE%B6%E4%B8%8E%E8%BE%93%E5%AE%B6/"},{"name":"股票市场","slug":"股票市场","link":"/tags/%E8%82%A1%E7%A5%A8%E5%B8%82%E5%9C%BA/"},{"name":"市场心理","slug":"市场心理","link":"/tags/%E5%B8%82%E5%9C%BA%E5%BF%83%E7%90%86/"},{"name":"投资陷阱","slug":"投资陷阱","link":"/tags/%E6%8A%95%E8%B5%84%E9%99%B7%E9%98%B1/"},{"name":"投资哲学","slug":"投资哲学","link":"/tags/%E6%8A%95%E8%B5%84%E5%93%B2%E5%AD%A6/"},{"name":"投资实战","slug":"投资实战","link":"/tags/%E6%8A%95%E8%B5%84%E5%AE%9E%E6%88%98/"},{"name":"直觉交易","slug":"直觉交易","link":"/tags/%E7%9B%B4%E8%A7%89%E4%BA%A4%E6%98%93/"},{"name":"猎手心法","slug":"猎手心法","link":"/tags/%E7%8C%8E%E6%89%8B%E5%BF%83%E6%B3%95/"},{"name":"理性投资","slug":"理性投资","link":"/tags/%E7%90%86%E6%80%A7%E6%8A%95%E8%B5%84/"},{"name":"市场哲学","slug":"市场哲学","link":"/tags/%E5%B8%82%E5%9C%BA%E5%93%B2%E5%AD%A6/"},{"name":"投资思维","slug":"投资思维","link":"/tags/%E6%8A%95%E8%B5%84%E6%80%9D%E7%BB%B4/"},{"name":"股票投机","slug":"股票投机","link":"/tags/%E8%82%A1%E7%A5%A8%E6%8A%95%E6%9C%BA/"},{"name":"权证操作","slug":"权证操作","link":"/tags/%E6%9D%83%E8%AF%81%E6%93%8D%E4%BD%9C/"},{"name":"五粮液","slug":"五粮液","link":"/tags/%E4%BA%94%E7%B2%AE%E6%B6%B2/"},{"name":"包钢","slug":"包钢","link":"/tags/%E5%8C%85%E9%92%A2/"},{"name":"缠论投资","slug":"缠论投资","link":"/tags/%E7%BC%A0%E8%AE%BA%E6%8A%95%E8%B5%84/"},{"name":"牛市策略","slug":"牛市策略","link":"/tags/%E7%89%9B%E5%B8%82%E7%AD%96%E7%95%A5/"},{"name":"散户指导","slug":"散户指导","link":"/tags/%E6%95%A3%E6%88%B7%E6%8C%87%E5%AF%BC/"},{"name":"投资心理","slug":"投资心理","link":"/tags/%E6%8A%95%E8%B5%84%E5%BF%83%E7%90%86/"},{"name":"市场逻辑","slug":"市场逻辑","link":"/tags/%E5%B8%82%E5%9C%BA%E9%80%BB%E8%BE%91/"},{"name":"iOS面试","slug":"iOS面试","link":"/tags/iOS%E9%9D%A2%E8%AF%95/"},{"name":"百度","slug":"百度","link":"/tags/%E7%99%BE%E5%BA%A6/"},{"name":"美团","slug":"美团","link":"/tags/%E7%BE%8E%E5%9B%A2/"},{"name":"阿里","slug":"阿里","link":"/tags/%E9%98%BF%E9%87%8C/"},{"name":"iOS进阶","slug":"iOS进阶","link":"/tags/iOS%E8%BF%9B%E9%98%B6/"},{"name":"腾讯","slug":"腾讯","link":"/tags/%E8%85%BE%E8%AE%AF/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"算法题","slug":"算法题","link":"/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"风险管理","slug":"风险管理","link":"/tags/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/"},{"name":"数学原理","slug":"数学原理","link":"/tags/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"name":"炒股入门","slug":"炒股入门","link":"/tags/%E7%82%92%E8%82%A1%E5%85%A5%E9%97%A8/"},{"name":"股票实战","slug":"股票实战","link":"/tags/%E8%82%A1%E7%A5%A8%E5%AE%9E%E6%88%98/"},{"name":"经济人","slug":"经济人","link":"/tags/%E7%BB%8F%E6%B5%8E%E4%BA%BA/"},{"name":"虎牙","slug":"虎牙","link":"/tags/%E8%99%8E%E7%89%99/"},{"name":"ARC","slug":"ARC","link":"/tags/ARC/"},{"name":"RunLoop","slug":"RunLoop","link":"/tags/RunLoop/"}],"categories":[{"name":"sing-box","slug":"sing-box","link":"/categories/sing-box/"},{"name":"配置详解","slug":"sing-box/配置详解","link":"/categories/sing-box/%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"name":"iOS开发","slug":"iOS开发","link":"/categories/iOS%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"iOS开发/面试题","link":"/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"好文收录","slug":"好文收录","link":"/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/"},{"name":"缠论原文","slug":"好文收录/缠论原文","link":"/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/"}],"pages":[]}