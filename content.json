{"posts":[{"title":"大厂常问iOS面试题--Block篇","text":"这一篇我们来研究一下objc的block并回答一下面试中的下列问题: 1.block的内部实现，结构体是什么样的 2.block是类吗，有哪些类型 3.一个int变量被 __block 修饰与否的区别？block的变量截获 4.block在修改NSMutableArray，需不需要添加__block 5.怎么进行内存管理的 6.block可以用strong修饰吗 7.解决循环引用时为什么要用__strong、__weak修饰 8.block发生copy时机 9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别 在回答所有问题之前我们需要了解一些block背景相关的知识. 如下: 如何查看Block的内部实现,也就是说转换成背后真正的c/c++代码的block是什么样的？以及转换格式或者原理等. -关于变量的作用域 Objective-C 转 C++的方法下面我写了个示例TestClass.m类其中block代码如下 OC代码: 12345678910111213@interface TestClass ()@end@implementation TestClass- (void)testMethods { void (^blockA)(int a) = ^(int a) { NSLog(@&quot;%d&quot;,a); }; if (blockA) { blockA(1990); }}@end 经过上述转换操作我们在TestClass.cpp中最下面发现如下代码 C++代码 12345678910111213141516171819202122232425262728293031323334// @interface TestClass ()/* @end */// @implementation TestClassstruct __TestClass__testMethods_block_impl_0 { struct __block_impl impl; struct __TestClass__testMethods_block_desc_0* Desc; __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_ee18d3_mi_0,a); }static struct __TestClass__testMethods_block_desc_0 { size_t reserved; size_t Block_size;} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)};static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) { void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA)); if (blockA) { ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990); }} 上面的代码生成是通过如下操作: 打开终端，cd到TestClass.m所在文件夹,使用如下命令 1clang -rewrite-objc TestClass.m 就会在当前文件夹内自动生成对应的TestClass.cpp文件 注意: 如果提示clang没有的话 需要安装, 输入如下 12345brew install clang-format或者brew link clang-forma然后输入 下面命令测试是否好使clang-format --help 通过上述代码我们发现Block的其实是一个结构体类型 底层实现 会根据 __类名__方法名_block_impl_下标 (0代表这个方法或者这个类中第0个block 下面如果还有将会 第1个block 第2个…) 1struct __类名__方法名_block_impl_下标 关于变量的作用域c语言的函数中可能使用的参数变量种类 参数类型 自动变量(局部变量) 静态变量(静态局部变量) 静态全局变量 全局变量 由于存储区域特殊,这其中有三种变量是可以在任何时候以任何状态调用的. 静态变量 静态全局变量 全局变量 而其他两种,则是有各自相应的作用域,超过作用域后,会被销毁. 1.block的内部实现，结构体是什么样的看了上面的背景知识我们来回到一下这个问题 block的内部实现如下: 12345678910111213141516171819202122232425262728293031323334struct __TestClass__testMethods_block_impl_0 { struct __block_impl impl; //成员变量 struct __TestClass__testMethods_block_desc_0* Desc; //desc 结构体声明 // 构造函数 // fp 函数指针 // desc 静态全局变量初始化的 __main_block_desc_ 结构体实例指针 // flags block 的负载信息(引用计数和类型信息),按位存储. __TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};//将来被调用的block内部的代码：block值被转换为C的函数代码//这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己(相当于C++里的this，OC里的self)//__cself 是指向__TestClass__testMethods_block_impl_0结构体实现的指针//Block结构体就是__TestClass__testMethods_block_impl_0结构体.Block的值就是通过__TestClass__testMethods_block_impl_0构造出来的static void __TestClass__testMethods_block_func_0(struct __TestClass__testMethods_block_impl_0 *__cself, int a) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_9f58f7_mi_0,a);}static struct __TestClass__testMethods_block_desc_0 { size_t reserved; size_t Block_size;} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)};static void _I_TestClass_testMethods(TestClass * self, SEL _cmd) { void (*blockA)(int a) = ((void (*)(int))&amp;__TestClass__testMethods_block_impl_0((void *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA)); if (blockA) { ((void (*)(__block_impl *, int))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, 1990); }} 可以看得出来__TestClass__testMethods_block_impl_0有3个部分组成 impl 函数指针指向__TestClass__testMethods_block_impl_0 123456struct __block_impl { void *isa; int Flags; int Reserved; //今后版本升级所需的区域 void *FuncPtr; //函数指针}; Desc 指向__TestClass__testMethods_block_impl_0的Desc指针,用于描述当前这个block的附加信息的，包括结构体的大小等等信息. 1234static struct __TestClass__testMethods_block_desc_0 { size_t reserved; //今后升级版本所需区域 size_t Block_size; //block的大小} __TestClass__testMethods_block_desc_0_DATA = { 0, sizeof(struct __TestClass__testMethods_block_impl_0)}; __TestClass__testMethods_block_impl_0()构造函数,也就是该block的具体实现 123456__TestClass__testMethods_block_impl_0(void *fp, struct __TestClass__testMethods_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc;} 此结构体中 isa指针保持这所属类的结构体的实例的指针. struct __TestClass__testMethods_block_impl_0相当于Objective-C类对象的结构体 _NSConcreteStackBlock相当于Block的结构体实例,也就是说block其实就是Objective-C对于闭包的对象实现 讲到这里block的内部实现你看懂了吗?结构体是什么样的你记住了吗? 其实看着繁琐 细心观察代码会发现还是比较简单的. 2.block是类吗，有哪些类型?block也算是个类,因为它有isa指针,block.isa的类型包括 _NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域(.data)中 _NSConcreteStackBlock栈上(前面讲的都是栈上的 block) _NSConcreteMallocBlock 堆上 这个isa可以按位运算 3.一个int变量被 __block 修饰与否的区别？block的变量截获被__block 修饰与否的区别用一段示例代码来解答这个问题吧: 12345678910111213141516__block int a = 10;int b = 20;PrintTwoIntBlock block = ^(){ a -= 10; printf(&quot;%d, %d\\n&quot;,a,b);};block();//0 20a += 20;b += 30;printf(&quot;%d, %d\\n&quot;,a,b);//20 50block();/10 20 通过__block修饰int a,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用. int b没有被__block修饰,block内部对b是值copy.所以在block内部修改b不影响外部b的变化. block的变量截获通过如下代码我们来观察要一下变量的捕获 1234567891011blk_t blk;{ id array = [NSMutableArray new]; blk = [^(id object){ [array addObject:object]; NSLog(@&quot;array count = %ld&quot;,[array count]); } copy];}blk([NSObject new]);blk([NSObject new]);blk([NSObject new]); 输出打印 123block_demo[28963:1629127] array count = 1block_demo[28963:1629127] array count = 2block_demo[28963:1629127] array count = 3 我们把上面的代码翻译成C++看下 1234567891011struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; id array;//截获的对象 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 在Objc中，C结构体里不能含有被__strong修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是Objc的运行时库能够准确把握Block从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过__TestClass__testMethods_block_copy_0函数和__TestClass__testMethods_block_dispose_0函数进行的 123456static void __TestClass__testMethods_block_copy_0(struct __TestClass__testMethods_block_impl_0*dst, struct __TestClass__testMethods_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);} static void __TestClass__testMethods_block_dispose_0(struct __TestClass__testMethods_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);} _Block_object_assign相当于retain操作,将对象赋值在对象类型的结构体成员变量中. _Block_object_dispose相当于release操作. 这两个函数调用的时机是在什么时候呢？ 函数 被调用时机 __TestClass__testMethods_block_copy_0 从栈复制到堆时 __TestClass__testMethods_block_dispose_0 堆上的Block被废弃时 什么时候栈上的Block会被复制到堆呢？ 调用block的copy函数时。 Block作为函数返回值返回时。 将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时。 方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。 什么时候Block被废弃呢？ 堆上的Block被释放后,谁都不再持有Block时调用dispose函数。 以上就是变量被block捕获的内容 4.block在修改NSMutableArray，需不需要添加__block 如修改NSMutableArray的存储内容的话,是不需要添加__block修饰的。 如修改NSMutableArray对象的本身,那必须添加__block修饰。 5.怎么进行内存管理的?在上面Block的构造函数__TestClass__testMethods_block_impl_0中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中. block内存操作 存储域/存储位置 copy操作的影响 _NSConcreteGlobalBlock 程序的数据区域 什么也不做 _NSConcreteStackBlock 栈 从栈拷贝到堆 _NSConcreteMallocBlock 堆 引用计数增加 全局Block:_NSConcreteGlobalBlock的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件: 记述全局变量的地方有block语法时. block不截获的自动变量. 以上两个条件只要满足一个就可以产生全局Block. 参考 栈Block:_NSConcreteStackBlock在生成Block以后，如果这个Block不是全局Block,那它就是栈Block,生命周期在其所属的变量作用域内.(也就是说如果销毁取决于所属的变量作用域).如果Block变量和__block变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block. 堆Block:_NSConcreteMallocBlock将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。 6.block可以用strong修饰吗?在ARC中可以，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作. 在MRC中不行,因为要有拷贝过程.如果执行copy用strong的话会crash, strong是ARC中引入的关键字.如果使用retain相当于忽视了block的copy过程. 7.解决循环引用时为什么要用__strong、__weak修饰?首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上__weak,在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,但是持有的是我们上面加了__weak所以行程了比消此长的链条,刚好能解决block延迟销毁的时候对外部对象生命周期造成的影响.如果不这样做很容易造成循环引用. 8.block发生copy时机?在ARC中,编译器将创建在栈中的block会自动拷贝到堆内存中,而block作为方法或函数的参数传递时,编译器不会做copy操作. 调用block的copy函数时。 Block作为函数返回值返回时。 将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时。 方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。 9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别? ARC下会对这个对象强引用，MRC下不会","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Block%E7%AF%87/"},{"title":"大厂常问iOS面试题--NSNotification篇","text":"主要内容包含如下: 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等） 通知的发送时同步的，还是异步的 NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息 NSNotificationQueue是异步还是同步发送？在哪个线程响应 NSNotificationQueue和runloop的关系 如何保证通知接收的线程在主线程 页面销毁时不移除通知会崩溃吗 多次添加同一个通知会是什么结果？多次移除通知呢 下面的方式能接收到通知吗？为什么 1234// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil]; 在解释这些内容之前 强烈建议认真研读一下这篇 一文全解iOS通知机制(经典收藏)文章 了解一下大概 所有的问题就迎刃而解了. 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等首先通知中心结构大概分为如下几个类 NSNotification 通知的模型 name、object、userinfo. NSNotificationCenter通知中心 负责发送NSNotification NSNotificationQueue通知队列 负责在某些时机触发 调用NSNotificationCenter通知中心 post通知 通知是结构体通过双向链表进行数据存储 123456789101112131415// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation; 主要是以key value的形式存储,这里需要重点强调一下 通知以 name和object两个纬度来存储相关通知内容,也就是我们添加通知的时候传入的两个不同的方法. 简单理解name&amp;observer&amp;SEL之间的关系就是name作为key, observer作为观察者对象,当合适时机触发就会调用observer的SEL.这基本很简单,如果觉得我说的不准确可以看下文章开头的文章. 通知的发送时同步的，还是异步的同步发送.因为要调用消息转发.所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程. NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息是的, 异步线程发送通知则响应函数也是在异步线程. 异步发送通知可以开启异步线程发送即可. NSNotificationQueue是异步还是同步发送？在哪个线程响应123456// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送}; NSPostWhenIdle NSPostASAP NSPostNow NSPostingStyle 异步发送 异步发送 同步发送 NSNotificationCenter都是同步发送的，而这里介绍关于NSNotificationQueue的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了runloop的时机来触发的. 异步线程发送通知则响应函数也是在异步线程,主线程发送则在主线程. NSNotificationQueue和runloop的关系NSNotificationQueue依赖runloop. 因为通知队列要在runloop回调的某个时机调用通知中心发送通知.从下面的枚举值就能看出来 123456// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送}; 如何保证通知接收的线程在主线程如果想在主线程响应异步通知的话可以用如下两种方式 1.系统接受通知的API指定队列 1- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block 2.NSMachPort的方式 通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可 页面销毁时不移除通知会崩溃吗?iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针. iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。 多次添加同一个通知会是什么结果？多次移除通知呢多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。 下面的方式能接收到通知吗？为什么1234// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil]; 不能 首先我们看下通知中心存储通知观察者的结构 123456789101112131415// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation; nameless与named的具体数据结构如下: 当添加通知监听的时候，我们传入了name和object，所以，观察者的存储链表是这样的： named表：key(name) : value-&gt;key(object) : value(Observation) 因此在发送通知的时候，如果只传入name而并没有传入object，是找不到Observation的，也就不能执行观察者回调. 总结今天又重新认识了iOS中的通知中心,希望大家经常温故而知新.","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-NSNotification%E7%AF%87/"},{"title":"大厂常问iOS面试题--Runloop&amp;KVO篇","text":"前言今天这一篇我们来讲一下 Runloop和KVO 本章的主要回答的问题如下: Runloop app如何接收到触摸事件的 为什么只有主线程的runloop是开启的 为什么只在主线程刷新UI PerformSelector和runloop的关系 如何使线程保活 KVO 实现原理 如何手动关闭kvo 通过KVC修改属性会触发KVO么 哪些情况下使用kvo会崩溃，怎么防护崩溃 kvo的优缺点 Runloop作为一个合格的iOS开发者必须对runloop有一个更深入的了解,下面我们来回答一下 相关问题 1.app如何接收到触摸事件的回答这个问题前请认真阅读一下 iOS触摸事件全家桶 通过上图可以看出整个流程就是 我们app启动默认会通过machPort监听端口的方式 来接受IOHIDEvent 来接收和处理触摸事件. 2.为什么只有主线程的runloop是开启的mian()函数中调用UIApplicationMain，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行并接收事件，所以在主线程中开启一个runloop，让主线程常驻. 3.为什么只在主线程刷新UI我们所有用到的UI都是来自于UIKit这个基础库.因为objc不是一门线程安全的语言所以存在多线程读写不同步的问题,如果使用加锁的方式操作系统开销很大,会耗费大量的系统资源(内存、时间片轮转、cpu处理速度…)，加上上面讲到的系统事件的接收处理都在主线程,如果UI异步线程的话 还会存在 同步处理事件的问题,所以多点触摸手势等一些事件要保持和UI在同一个线程相对是最优解. 另一方面是 屏幕的渲染是 60帧(60Hz/秒), 也就是1秒钟回调60次的频率,(iPad Pro 是120Hz/秒),我们的runloop 理想状态下也会按照时钟周期 回调60次(iPad Pro 120次), 这么高频率的调用是为了 屏幕图像显示能够垂直同步 不卡顿.在异步线程的话是很难保证这个处理过程的同步更新. 即便能保证的话 相对主线程而言 系统资源开销 线程调度等等将会占据大部分资源和在同一个线程只专门干一件事有点得不偿失. 4.PerformSelector和runloop的关系当调用NSObect的 performSelector:相关的时候,内部会创建一个timer定时器添加到当前线程的runloop中,如果当前线程没有启动runloop,则该方法不会被调用. 开发中遇到最多的问题就是这个performSelector: 导致对象的延迟释放,这里开发过程中注意一下,可以用单次的NSTimer替代. 详细可以参考Runloop与performSelector 5.如何使线程保活？想要线程保活的话就开启该线程的runloop即可,注意:在NSThread执行的方法中添加while(true){}，这样是模拟runloop的运行原理，结合GCD的信号量，在{}代码块中处理任务. 但是注意 开启runloop的方法要正确 如下代码 123456789101112131415161718192021222324252627282930313233343536373839//测试开启线程- (void)memoryTest { for (int i = 0; i &lt; 100000; ++i) { NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; [self performSelector:@selector(stopThread) onThread:thread withObject:nil waitUntilDone:YES]; }}//线程停止- (void)stopThread { CFRunLoopStop(CFRunLoopGetCurrent()); NSThread *thread = [NSThread currentThread]; [thread cancel];}//运行线程的runloop 注意 意添加的那个空port,否则会出现内存泄露- (void)run { @autoreleasepool { NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; if (!self.emptyPort) { self.emptyPort = [NSMachPort port]; } [runLoop addPort:self.emptyPort forMode:NSDefaultRunLoopMode]; [runLoop runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]]; }}//下列代码用于模拟线程内部做的一些耗时任务- (void)printSomething { NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]); [self performSelector:@selector(printSomething) withObject:nil afterDelay:1];}//模拟手动点击按钮 让 runloop停掉- (void)stopButtonDidClicked:(id)sender { [self performSelector:@selector(stopRunloop) onThread:self.thread withObject:nil waitUntilDone:YES];}- (void)stopRunloop { CFRunLoopStop(CFRunLoopGetCurrent());} 详细请参考:iOS开发深入研究Runloop与线程保活 KVO在开发过程中我们经常使用KVO,下面解答一下KVO相关的问题. KVO的实现原理通过runtime派生子类的方式 复写相关需要KVO监听的属性,在该属性setter之前和之后调用NSObject的监听方法,这样KVO就实现了属性变换前后的回调. KVO派生的子类具体格式应该是:NSKVONotifying_+类名的类 eg: NSKVONotifying_Person 下面示例代码为Person类的name添加KVO的模拟实验 12345678910111213- (void)setName:(NSString *)name{ _NSSetObjectValueAndNotify();}void _NSSetObjectValueAndNotify { [self willChangeValueForKey:@&quot;name&quot;]; [super setName:name]; [self didChangeValueForKey:@&quot;name&quot;];}- (void)didChangeValueForKey:(NSString *)key{ [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];} 问题来了如何动态创建类呢? 12345678910111213141516171819//动态创建XXCustomClassClass customClass = objc_allocateClassPair([NSObject class], &quot;XXCustomClass&quot;, 0);// 添加实例变量class_addIvar(customClass, &quot;age&quot;, sizeof(int), 0, &quot;i&quot;);// 动态添加方法class_addMethod(customClass, @selector(hahahha), (IMP)hahahha, &quot;V@:&quot;);//需要实现的方法void hahahha(id self, SEL _cmd){ NSLog(@&quot;hahahha====&quot;);}- (void)hahahha{}//最后注册到运行时环境objc_registerClassPair(customClass); V@:表示方法的参数和返回值 具体原理以及自定义实现KVO可以参考KVO详解及底层实现 如何手动关闭KVO?被观察的对象复写如下方法 返回NO即可关闭KVO 123+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key { return NO;} 如果关闭后还想触发 KVO的话 修改需要手动调用在变量setter的前后 主动调用 willChangeValueForKey:和didChangeValueForKey: 通过KVC修改属性会触发KVO么?会的 哪些情况下使用kvo会崩溃，怎么防护崩溃？使用不当 会crash,比如: 添加和移出不是成对出现且存在多线程添加KVO的情况,经常遇到的crash是移出 - 内存dealloc的时候 或者对象销毁前没有正确移出Observer 如何防护？ 1.注意移出对象 匹配 2.内存野指针问题,一定要在对象销毁前移出观察者 3.可以使用第三方库BlockKit添加KVO,blockkit内部会自动移除Observer避免crash. KVO的优缺点优点: 方便两个对象间同步状态(keypath)更加方便,一般都是在A类要观察B类的属性的变化. 非侵入式的得到某内部对象的状态改变并作出响应.(就是在不改变原来对象类的代码情况下即可做出对该对象的状态变化进行监听) 可以嵌入更改前后的两个时机的状态. - 可以通过Keypaths对嵌套对象的监听. 缺点: 需要手动移除观察者,不移除容易造成crash. 注册和移出成对匹配出现. keypath参数的类型String, 如果对象的成员变量被重构而变化字符串不会被编译器识别而报错. 实现观察的方式是复写NSObjec的相关KVO的方法,应该更加面向protocol的方式会更好. 总结这一篇我们讲了 runloop和KVO相关的内容,这里面最负责的当属runloop如何处理触摸手势事件.建议认真研读相关链接文章.这样才有一个对runloop更深刻的理解。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Runloop%E5%92%8CKVO%E7%AF%87/"},{"title":"大厂常问iOS面试题--Runtime篇","text":"1.什么是Runtime在 Objective-C 中，Runtime 是一套 C 语言的 API，用于在运行时操作对象、类和元类。通过 Objective-C Runtime，开发者可以在程序运行时动态地创建类、修改类的方法、获取类的属性信息、发送消息等。这使得 Objective-C 具有了诸多动态语言的特性，如动态绑定、消息转发、方法调用等。 2.Category 的实现原理？ Category 实际上是 Category_t的结构体，在运行时，新添加的方法，都被以倒序插入到原有方法列表的最前面，所以不同的Category，添加了同一个方法，执行的实际上是最后一个。 Category 在刚刚编译完的时候，和原来的类是分开的，只有在程序运行起来后，通过 Runtime ，Category 和原来的类才会合并到一起。 3.isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？ isa 等价于 is kind of 实例对象的 isa 指向类对象 类对象的 isa 指向元类对象 元类对象的 isa 指向元类的基类 isa 有两种类型 纯指针，指向内存地址 NON_POINTER_ISA，除了内存地址，还存有一些其他信息 4.Objective-C 如何实现多重继承？Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现 通过组合实现 A和B组合，作为C类的组件 通过协议实现 C类实现A和B类的协议方法 消息转发实现 forwardInvocation:方法 5.runtime 如何实现 weak 属性？weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。 runtime 对注册的类，会进行内存布局，从一个粗粒度的概念上来讲，这时候会有一个 hash 表，这是一个全局表，表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。当此对象的引用计数为 0 的时候会 dealloc，假如该对象内存地址是 a，那么就会以 a 为 key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。 runtime 如何实现 weak 属性具体流程大致分为 3 步： 1、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向（指针可能原来指向着其他对象，这时候需要将该 weak 指针与旧对象解除绑定，会调用到 weak_unregister_no_lock），如果指针指向的新对象非空，则创建对应的弱引用表，将 weak 指针与新对象进行绑定，会调用到 weak_register_no_lock。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。 3、释放时：调用 clearDeallocating 函数，clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 6.讲一下 OC 的消息机制Objective-C 的消息机制是其动态消息传递的核心特性，它是 Objective-C 语言中实现方法调用的机制。在 Objective-C 中，对象之间的通信是通过向对象发送消息来实现的，而不是像其他语言那样直接调用方法。 消息机制的基本原理如下： 1、方法调用：在 Objective-C 中，调用对象的方法实际上是向对象发送一个消息。消息由方法名和对应的参数组成。 2、动态绑定：在编译时，编译器并不会确定对象接收到消息时应该调用的具体方法，而是在运行时根据对象的类和方法选择器（selector）来动态确定调用的方法。这种动态确定方法的过程称为动态绑定。 3、消息传递：当一个对象接收到消息时，Objective-C 运行时会根据消息的方法选择器（selector）在对象所属的类的方法列表（method list）中查找相应的方法实现。如果找到了匹配的方法实现，则调用该方法；如果找不到匹配的方法实现，则会执行消息转发（message forwarding）过程。 4、消息转发：当运行时无法在类的方法列表中找到与消息相匹配的方法实现时，Objective-C 运行时会调用对象的 forwardingTargetForSelector: 方法，尝试将消息转发给另一个对象处理。如果该方法返回一个有效的对象，则将消息转发给该对象；如果返回 nil，则会继续执行下一步的消息转发机制。 5、动态方法解析：如果 forwardingTargetForSelector: 方法没有返回有效的对象，Objective-C 运行时会调用对象的 resolveInstanceMethod: 或 resolveClassMethod: 方法，尝试动态地添加方法实现。如果成功添加了方法实现，则会重新执行消息传递过程；如果仍然无法找到相应的方法实现，则会执行最后一步的消息转发机制。 6、完整的消息转发：如果动态方法解析仍然无法找到相应的方法实现，则 Objective-C 运行时会调用对象的 forwardInvocation: 方法，将原始的未知消息封装成一个 NSInvocation 对象，并传递给 forwardInvocation: 方法进行处理。开发者可以在该方法中自定义处理未知消息的逻辑，例如将消息转发给其他对象进行处理。 7.runtime具体应用 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题 KVC 字典转模型 8.runtime如何通过selector找到对应的IMP地址？每一个类对象中都一个对象方法列表（对象方法缓存） 类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）。 方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现。 当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找。 当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找。 9.简述下Objective-C中调用方法的过程Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下： objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类 然后在该类中的方法列表以及其父类方法列表中寻找方法运行 如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会，这三次拯救程序奔溃的说明见问题《什么时候会报unrecognized selector的异常》中的说明。 10.load和initialize的区别两者都会自动调用父类的，不需要super操作，且仅会调用一次（不包括外部显示调用). load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。 load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。 load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。 load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。 11.怎么理解Objective-C是动态运行时语言。 主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。 简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物,猪也属于生物,都继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础.","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Runtime%E7%AF%87/"},{"title":"大厂常问iOS面试题--内存管理篇","text":"1.什么情况使用weak关键字，相比assign有什么不同？ 什么情况使用 weak 关键字？ 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》 不同点： weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。 assign 可以用非 OC 对象,而 weak 必须用于 OC 对象 2.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？ 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤： 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议。该协议只有一个方法: 1- (id)copyWithZone:(NSZone *)zone; 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。 重写带 copy 关键字的 setter，例如： 1234- (void)setName:(NSString *)name { //[_name release]; _name = [name copy];} 3.深拷贝与浅拷贝浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。 当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形： 当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现； 当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。 copy方法:如果是非可扩展类对象，则是浅拷贝。如果是可扩展类对象，则是深拷贝。 mutableCopy方法:无论是可扩展类对象还是不可扩展类对象，都是深拷贝。 4.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的 @property 的本质是实例变量（ivar）+存取方法（access method ＝ getter + setter）,即 @property = ivar + getter + setter; “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。 ivar、getter、setter 是自动合成这个类中的 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字. 5.@protocol和category中如何使用@property 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性 category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：objc_setAssociatedObject和objc_getAssociatedObject 6.简要说一下@autoreleasePool的数据结构？？简单说是双向链表，每张链表头尾相接，有 parent、child指针 每创建一个池子，会在首部创建一个 哨兵 对象,作为标记 最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。 7.BAD_ACCESS在什么情况下出现？访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环 8.使用CADisplayLink、NSTimer有什么注意点？CADisplayLink、NSTimer会造成循环引用，可以使用YYWeakProxy或者为CADisplayLink、NSTimer添加block方法解决循环引用 9.iOS内存分区情况 栈区（Stack） 由编译器自动分配释放，存放函数的参数，局部变量的值等 栈是向低地址扩展的数据结构，是一块连续的内存区域 堆区（Heap） 由程序员分配释放 是向高地址扩展的数据结构，是不连续的内存区域 全局区 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域 程序结束后由系统释放 常量区 常量字符串就是放在这里的 程序结束后由系统释放 代码区 存放函数体的二进制代码 注： 在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的 系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容） 变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收 当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错） 10.iOS内存管理方式 Tagged Pointer（小对象） Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍 objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据 使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中 NONPOINTER_ISA （指针中存放与该对象内存相关的信息） 苹果将 isa 设计成了联合体，在 isa 中存储了与该对象相关的一些内存的信息，原因也如上面所说，并不需要 64 个二进制位全部都用来存储指针。 isa 的结构： 12345678910111213141516171819202122232425// x86_64 架构struct { uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 44; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 8; // 引用计数能够用 8 个二进制位存储时，直接存储在这里};// arm64 架构struct { uintptr_t nonpointer : 1; // 0:普通指针，1:优化过，使用位域存储更多信息 uintptr_t has_assoc : 1; // 对象是否含有或曾经含有关联引用 uintptr_t has_cxx_dtor : 1; // 表示是否有C++析构函数或OC的dealloc uintptr_t shiftcls : 33; // 存放着 Class、Meta-Class 对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用指向 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 是否需要使用 sidetable 来存储引用计数 uintptr_t extra_rc : 19; // 引用计数能够用 19 个二进制位存储时，直接存储在这里}; 这里的 has_sidetable_rc 和 extra_rc，has_sidetable_rc 表明该指针是否引用了 sidetable 散列表，之所以有这个选项，是因为少量的引用计数是不会直接存放在 SideTables 表中的，对象的引用计数会先存放在 extra_rc 中，当其被存满时，才会存入相应的 SideTables 散列表中，SideTables 中有很多张 SideTable，每个 SideTable 也都是一个散列表，而引用计数表就包含在 SideTable 之中。 散列表（引用计数表、弱引用表） 引用计数要么存放在 isa 的 extra_rc 中，要么存放在引用计数表中，而引用计数表包含在一个叫 SideTable 的结构中，它是一个散列表，也就是哈希表。而 SideTable 又包含在一个全局的 StripeMap 的哈希映射表中，这个表的名字叫 SideTables。 当一个对象访问 SideTables 时： 首先会取得对象的地址，将地址进行哈希运算，与 SideTables 中 SideTable 的个数取余，最后得到的结果就是该对象所要访问的 SideTable 在取得的 SideTable 中的 RefcountMap 表中再进行一次哈希查找，找到该对象在引用计数表中对应的位置 如果该位置存在对应的引用计数，则对其进行操作，如果没有对应的引用计数，则创建一个对应的 size_t 对象，其实就是一个 uint 类型的无符号整型 弱引用表也是一张哈希表的结构，其内部包含了每个对象对应的弱引用表 weak_entry_t，而 weak_entry_t 是一个结构体数组，其中包含的则是每一个对象弱引用的对象所对应的弱引用指针。 11.循环引用1. 概述iOS内存中的分区有：堆、栈、静态区。其中，栈和静态区是操作系统自己管理回收，不会造成循环引用。在堆中的相互引用无法回收，有可能造成循环引用。 循环引用的实质：多个对象相互之间有强引用，不能施放让系统回收。 解决循环引用一般是将 strong 引用改为 weak 引用。 2. 循环引用场景分析及解决方法1）父类与子类 如：在使用UITableView 的时候，将 UITableView 给 Cell 使用，cell 中的 strong 引用会造成循环引用。 1234567891011// controller- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { TestTableViewCell *cell =[tableView dequeueReusableCellWithIdentifier:@&quot;UITableViewCellId&quot; forIndexPath:indexPath]; cell.tableView = tableView; return cell;}// cell@interface TestTableViewCell : UITableViewCell@property (nonatomic, strong) UITableView *tableView; // strong 造成循环引用@end 解决：strong 改为 weak 1234// cell@interface TestTableViewCell : UITableViewCell@property (nonatomic, weak) UITableView *tableView; // strong 改为 weak@end 2）block block在copy时都会对block内部用到的对象进行强引用的。 123self.testObject.testCircleBlock = ^{ [self doSomething];}; self将block作为自己的属性变量，而在block的方法体里面又引用了 self 本身，此时就很简单的形成了一个循环引用。 应该将 self 改为弱引用 12345__weak typeof(self) weakSelf = self; self.testObject.testCircleBlock = ^{ __strong typeof (weakSelf) strongSelf = weakSelf; [strongSelf doSomething];}; 在 ARC 中，在被拷贝的 block 中无论是直接引用 self 还是通过引用 self 的成员变量间接引用 self，该 block 都会 retain self。 快速定义宏 12345// weak obj/#define WEAK_OBJ(type) __weak typeof(type) weak##type = type;// strong obj/#define STRONG_OBJ(type) __strong typeof(type) str##type = weak##type; 3）Delegatedelegate 属性的声明如下： 1@property (nonatomic, weak) id &lt;TestDelegate&gt; delegate; 如果将 weak 改为 strong，则会造成循环引用 123456789// self -&gt; AViewControllerBViewController *bVc = [BViewController new];bVc = self; [self.navigationController pushViewController: bVc animated:YES]; // 假如是 strong 的情况 // bVc.delegate ===&gt; AViewController (也就是 A 的引用计数 + 1) // AViewController 本身又是引用了 &lt;BViewControllerDelegate&gt; ===&gt; delegate 引用计数 + 1 // 导致： AViewController &lt;======&gt; Delegate ，也就循环引用啦 4）NSTimerNSTimer 的 target 对传入的参数都是强引用（即使是 weak 对象） 解决办法: 《Effective Objective-C 》中的52条方法 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;@interface NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;@end#import &quot;NSTimer+YPQBlocksSupport.h&quot;@implementation NSTimer (YPQBlocksSupport)+ (NSTimer *)ypq_scheduledTimeWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats{ return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(ypq_blockInvoke:) userInfo:[block copy] repeats:repeats];}- (void)ypq_blockInvoke:(NSTimer *)timer{ void (^block)() = timer.userInfo; if(block) { block(); }}@end 使用方式： 1234567__weak ViewController * weakSelf = self;[NSTimer ypq_scheduledTimeWithTimeInterval:4.0f block:^{ ViewController * strongSelf = weakSelf; [strongSelf afterThreeSecondBeginAction]; } repeats:YES]; 计时器保留其目标对象，反复执行任务导致的循环，确实要注意，另外在dealloc的时候，不要忘了调用计时器中的 invalidate方法。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/"},{"title":"大厂常问iOS面试题--多线程篇","text":"1.进程与线程 进程： 1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元. 2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app. 3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源 线程 1.程序执行流的最小单元，线程是进程中的一个实体. 2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程 进程和线程的关系 1.线程是进程的执行单元，进程的所有任务都在线程中执行 2.线程是 CPU 分配资源和调度的最小单位 3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程 4.同一个进程内的线程共享进程资源 2.什么是多线程？ 多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。 如果是多核CPU就真的可以同时处理多个线程了。 多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。 3.多线程的优点和缺点 优点: 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 缺点: 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 4.多线程的 并行 和 并发 有什么区别？ 并行：充分利用计算机的多核，在多个线程上同步进行 并发：在一条线程上通过快速切换，让人感觉在同步进行 5.iOS中实现多线程的几种方案，各自有什么特点？ NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。 GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。 NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。 6.多个网络请求完成后执行下一步 使用GCD的dispatch_group_t 创建一个dispatch_group_t 每次网络请求前先dispatch_group_enter,请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。 当所有enter的block都leave后，会执行dispatch_group_notify的block。 12345678910111213141516171819NSString *str = @&quot;http://xxxx.com/&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_group_t downloadGroup = dispatch_group_create();for (int i=0; i&lt;10; i++) { dispatch_group_enter(downloadGroup); NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); dispatch_group_leave(downloadGroup); }]; [task resume];}dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 使用GCD的信号量dispatch_semaphore_t dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。dispatch_semaphore_signal(semaphore)为计数+1操作,dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。 创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回 1234567891011121314151617181920212223NSString *str = @&quot;http://xxxx.com/&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_semaphore_t sem = dispatch_semaphore_create(0);for (int i=0; i&lt;10; i++) { NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); count++; if (count==10) { dispatch_semaphore_signal(sem); count = 0; } }]; [task resume];}dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 7.多个网络请求顺序执行后执行下一步 使用信号量semaphore 每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后 123456789101112131415161718192021NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;NSURL *url = [NSURL URLWithString:str];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];dispatch_semaphore_t sem = dispatch_semaphore_create(0);for (int i=0; i&lt;10; i++) { NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@&quot;%d---%d&quot;,i,i); dispatch_semaphore_signal(sem); }]; [task resume]; dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);}dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;);}); 8.异步操作两组数据时, 执行完第一组之后, 才能执行第二组 这里使用dispatch_barrier_async栅栏方法即可实现 123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{ NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{ NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_barrier_async(queue, ^{ NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);});dispatch_async(queue, ^{ NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{ NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);}); 9.多线程中的死锁？死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个： 互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞。 123456dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;);});NSLog(@&quot;1&quot;);// 什么也不会打印，直接报错 10.GCD执行原理？ GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？） 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。 如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。 这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5–8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3–5条最为合理。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"},{"title":"大厂常问iOS面试题--性能优化篇","text":"1.造成tableView卡顿的原因有哪些？ 1.最常用的就是cell的重用， 注册重用标识符 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。 如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 2.避免cell的重新布局 cell的布局填充等操作 比较耗时，一般创建时就布局好 如可以将cell单独放到一个自定义类，初始化时就布局好 3.提前计算并缓存cell的属性及内容 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell 4.减少cell中控件的数量 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件， 不适用的可以先隐藏 5.不要使用ClearColor，无背景色，透明度也不要设置为0 渲染耗时比较长 6.使用局部更新 如果只是更新某组的话，使用reloadSection进行局部更 7.加载网络数据，下载图片，使用异步加载，并缓存 8.少使用addView 给cell动态添加view 9.按需加载cell，cell滚动很快时，只加载范围内的cell 10.不要实现无用的代理方法，tableView只遵守两个协议 11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可 12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。 13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕； 14.使用正确的数据结构来存储数据。 2.如何提升 tableview 的流畅度？ 本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。 CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制 GPU：纹理的渲染 卡顿优化在 CPU 层面 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout 会比直接设置 frame 消耗更多的 CPU 资源 图片的 size 最好刚好跟 UIImageView 的 size 保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 卡顿优化在 GPU层面 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES 尽量避免出现离屏渲染 iOS 保持界面流畅的技巧 1.预排版，提前计算 在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。 尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式 2.预渲染，提前绘制 例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了 避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。 3.异步绘制 4.全局并发线程 5.高效的图片异步加载 3.APP启动时间应从哪些方面优化？App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手 dylib loading time 核心思想是减少dylibs的引用 合并现有的dylibs（最好是6个以内） 使用静态库 rebase/binding time 核心思想是减少DATA块内的指针 减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突） 减少c++虚函数 多使用Swift结构体（推荐使用swift） ObjC setup time 核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时 initializer time 使用initialize替代load方法 减少使用c/c++的attribute((constructor))；推荐使用dispatch_once() pthread_once() std:once()等方法 推荐使用swift 不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁 不要在初始化中创建线程 4.如何降低APP包的大小降低包大小需要从两方面着手 可执行文件 编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 资源（图片、音频、视频 等） 优化的方式可以对资源进行无损的压缩 去除没有用到的资源 5.如何检测离屏渲染与优化 检测，通过勾选Xcode的Debug-&gt;View Debugging–&gt;Rendering-&gt;Run-&gt;Color Offscreen-Rendered Yellow项。 优化，如阴影，在绘制时添加阴影的路径 6.怎么检测图层混合1、模拟器debug中color blended layers红色区域表示图层发生了混合 2、Instrument-选中Core Animation-勾选Color Blended Layers 避免图层混合： 确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明 如无特殊需要，不要设置低于1的alpha值 确保UIImage没有alpha通道 UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer.masksToBounds=YES让label只会渲染她的实际size区域，就能解决UILabel的图层混合问题 iOS8 之前只要设置背景色为非透明的就行 为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？ UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了 7.日常如何检查内存泄露？ 目前我知道的方式有以下几种 Memory Leaks Alloctions Analyse Debug Memory Graph MLeaksFinder 泄露的内存主要有以下两种： Laek Memory 这种是忘记 Release 操作所泄露的内存。 Abandon Memory 这种是循环引用，无法释放掉的内存。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/"},{"title":"大厂常问iOS面试题--数据结构篇","text":"1.数据结构的存储一般常用的有几种？各有什么特点？数据结构的存储一般常用的有两种 顺序存储结构 和 链式存储结构 顺序存储结构: 比如，数组，1-2-3-4-5-6-7-8-9-10，存储是按顺序的。再比如栈和队列等 链式存储结构: 比如，数组，1-2-3-4-5-6-7-8-9-10，链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序 2.集合结构 线性结构 树形结构 图形结构 集合结构 一个集合，就是一个圆圈中有很多个元素，元素与元素之间没有任何关系 这个很简单 线性结构 一个条线上站着很多个人。 这条线不一定是直的。也可以是弯的。也可以是值的 相当于一条线被分成了好几段的样子 （发挥你的想象力）。 线性结构是一对一的关系 树形结构 做开发的肯定或多或少的知道xml 解析 树形结构跟他非常类似。也可以想象成一个金字塔。树形结构是一对多的关系 图形结构 这个就比较复杂了。他呢 无穷。无边 无向（没有方向）图形机构 你可以理解为多对多 类似于我们人的交集关系 3.单向链表 双向链表 循环链表 单向链表 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑 双向链表 循环链表 循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;A. 绕成一个圈。就像蛇吃自己的这就是循环 不需要去死记硬背哪些理论知识。 4.数组和链表区别 数组 数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况 链表 链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高 5.堆、栈和队列堆 堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质： 1）堆中某个节点的值总是不大于或不小于其父节点的值； 2）堆总是一棵完全二叉树。 堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。 堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 栈 栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。 栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。 堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。 栈的应用—递归 队列 队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。 队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。 6.输入一棵二叉树的根结点，求该树的深度？二叉树的结点定义如下： 123456struct BinaryTreeNode{ int m_nValue ； BinaryTreeNode* m_pLeft; BinarvTreeNode* m_pRight ；} 如果一棵树只有一个结点，它的深度为1。 如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。 如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。 123456789int TreeDepth(TreeNode* pRoot){ if(pRoot == nullptr) return 0; int left = TreeDepth(pRoot-&gt;left); int right = TreeDepth(pRoot-&gt;right); return (left&gt;right) ? (left+1) : (right+1);} 7.输入一课二叉树的根结点，判断该树是不是平衡二叉树？ 重复遍历结点 先求出根结点的左右子树的深度，然后判断它们的深度相差不超过1，如果否，则不是一棵二叉树；如果是，再用同样的方法分别判断左子树和右子树是否为平衡二叉树，如果都是，则这就是一棵平衡二叉树。 遍历一遍结点 遍历结点的同时记录下该结点的深度，避免重复访问。 方法1: 123456789101112131415161718192021222324struct TreeNode{ int val; TreeNode* left; TreeNode* right;};int TreeDepth(TreeNode* pRoot){ if(pRoot==NULL) return 0; int left=TreeDepth(pRoot-&gt;left); int right=TreeDepth(pRoot-&gt;right); return left&gt;right?(left+1):(right+1);}bool IsBalanced(TreeNode* pRoot){ if(pRoot==NULL) return true; int left=TreeDepth(pRoot-&gt;left); int right=TreeDepth(pRoot-&gt;right); int diff=left-right; if(diff&gt;1 || diff&lt;-1) return false; return IsBalanced(pRoot-&gt;left) &amp;&amp; IsBalanced(pRoot-&gt;right);} 方法2： 123456789101112131415161718192021bool IsBalanced_1(TreeNode* pRoot,int&amp; depth){ if(pRoot==NULL){ depth=0; return true; } int left,right; int diff; if(IsBalanced_1(pRoot-&gt;left,left) &amp;&amp; IsBalanced_1(pRoot-&gt;right,right)){ diff=left-right; if(diff&lt;=1 || diff&gt;=-1){ depth=left&gt;right?left+1:right+1; return true; } } return false;}bool IsBalancedTree(TreeNode* pRoot){ int depth=0; return IsBalanced_1(pRoot,depth);}","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"},{"title":"大厂常问iOS面试题--算法篇","text":"1.时间复杂度 时间频度 一个算法执行所耗费的时间,从理论上是不能算出来的,必须上机运行测试才能知道.但我们不可能也没有必要对每个算法都上机测试,只需知道哪个算法花费的时间多,哪个算法花费的时间少就可以了.并且一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n). 时间复杂度 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度. 在各种不同算法中,若算法中语句执行次数为一个常数,则时间复杂度为O(1),另外,在时间频度不相同时,时间复杂度有可能相同,如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同,但时间复杂度相同,都为O(n2). 按数量级递增排列,常见的时间复杂度有： O(1)称为常量级，算法的时间复杂度是一个常数。 O(n)称为线性级，时间复杂度是数据量n的线性函数。 O(n²)称为平方级，与数据量n的二次多项式函数属于同一数量级。 O(n³)称为立方级，是n的三次多项式函数。 O(logn)称为对数级，是n的对数函数。 O(nlogn)称为介于线性级和平方级之间的一种数量级 O(2ⁿ)称为指数级，与数据量n的指数函数是一个数量级。 O(n!)称为阶乘级，与数据量n的阶乘是一个数量级。 它们之间的关系是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)，随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低. 2.空间复杂度 评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。不包括算法程序代码和所处理的数据本身所占空间部分。通常用所使用额外空间的字节数表示。其算法比较简单，记为S(n)=O(f(n))，其中，n表示问题规模。 3.常用的排序算法 选择排序、冒泡排序、插入排序三种排序算法可以总结为如下： 都将数组分为已排序部分和未排序部分。 选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。 冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。 插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 【选择排序】：最值出现在起始端 * * 第1趟：在n个数中找到最小(大)数与第一个数交换位置 * 第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置 * 重复这样的操作...依次与第三个、第四个...数交换位置 * 第n-1趟，最终可实现数据的升序（降序）排列。 * */void selectSort(int *arr, int length) { for (int i = 0; i &lt; length - 1; i++) { //趟数 for (int j = i + 1; j &lt; length; j++) { //比较次数 if (arr[i] &gt; arr[j]) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } }}/** * 【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾 * 第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置 * 第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置 * …… …… * 第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置 */void bublleSort(int *arr, int length) { for(int i = 0; i &lt; length - 1; i++) { //趟数 for(int j = 0; j &lt; length - i - 1; j++) { //比较次数 if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }}/** * 折半查找：优化查找时间（不用遍历全部数据） * * 折半查找的原理： * 1&gt; 数组必须是有序的 * 2&gt; 必须已知min和max（知道范围） * 3&gt; 动态计算mid的值，取出mid对应的值进行比较 * 4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1 * 5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1 * */ // 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 int findKey(int *arr, int length, int key) { int min = 0, max = length - 1, mid; while (min &lt;= max) { mid = (min + max) / 2; //计算中间值 if (key &gt; arr[mid]) { min = mid + 1; } else if (key &lt; arr[mid]) { max = mid - 1; } else { return mid; } } return -1;} 4.字符串反转1234567891011121314void char_reverse (char *cha) { // 定义头部指针 char *begin = cha; // 定义尾部指针 char *end = cha + strlen(cha) -1; while (begin &lt; end) { char temp = *begin; *(begin++) = *end; *(end--) = temp; }} 5.链表反转（头差法）.h声明文件 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;// 定义一个链表struct Node { int data; struct Node *next;};@interface ReverseList : NSObject// 链表反转struct Node* reverseList(struct Node *head);// 构造一个链表struct Node* constructList(void);// 打印链表中的数据void printList(struct Node *head);@end .m实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ReverseList.h&quot;@implementation ReverseListstruct Node* reverseList(struct Node *head){ // 定义遍历指针，初始化为头结点 struct Node *p = head; // 反转后的链表头部 struct Node *newH = NULL; // 遍历链表 while (p != NULL) { // 记录下一个结点 struct Node *temp = p-&gt;next; // 当前结点的next指向新链表头部 p-&gt;next = newH; // 更改新链表头部为当前结点 newH = p; // 移动p指针 p = temp; } // 返回反转后的链表头结点 return newH;}struct Node* constructList(void){ // 头结点定义 struct Node *head = NULL; // 记录当前尾结点 struct Node *cur = NULL; for (int i = 1; i &lt; 5; i++) { struct Node *node = malloc(sizeof(struct Node)); node-&gt;data = i; // 头结点为空，新结点即为头结点 if (head == NULL) { head = node; } // 当前结点的next为新结点 else{ cur-&gt;next = node; } // 设置当前结点为新结点 cur = node; } return head;}void printList(struct Node *head){ struct Node* temp = head; while (temp != NULL) { printf(&quot;node is %d \\n&quot;, temp-&gt;data); temp = temp-&gt;next; }}@end 6.有序数组合并.h声明文件 1234567#import &lt;Foundation/Foundation.h&gt;@interface MergeSortedList : NSObject// 将有序数组a和b的值合并到一个数组result当中，且仍然保持有序void mergeList(int a[], int aLen, int b[], int bLen, int result[]);@end .m实现文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;MergeSortedList.h&quot;@implementation MergeSortedListvoid mergeList(int a[], int aLen, int b[], int bLen, int result[]){ int p = 0; // 遍历数组a的指针 int q = 0; // 遍历数组b的指针 int i = 0; // 记录当前存储位置 // 任一数组没有到达边界则进行遍历 while (p &lt; aLen &amp;&amp; q &lt; bLen) { // 如果a数组对应位置的值小于b数组对应位置的值 if (a[p] &lt;= b[q]) { // 存储a数组的值 result[i] = a[p]; // 移动a数组的遍历指针 p++; } else{ // 存储b数组的值 result[i] = b[q]; // 移动b数组的遍历指针 q++; } // 指向合并结果的下一个存储位置 i++; } // 如果a数组有剩余 while (p &lt; aLen) { // 将a数组剩余部分拼接到合并结果的后面 result[i] = a[p++]; i++; } // 如果b数组有剩余 while (q &lt; bLen) { // 将b数组剩余部分拼接到合并结果的后面 result[i] = b[q++]; i++; }}@end 7.查找第一个只出现一次的字符（Hash查找）.h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;@interface HashFind : NSObject// 查找第一个只出现一次的字符char findFirstChar(char* cha);@end .m实现文件 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;HashFind.h&quot;@implementation HashFindchar findFirstChar(char* cha){ char result = '\\0'; // 定义一个数组 用来存储各个字母出现次数 int array[256]; // 对数组进行初始化操作 for (int i=0; i&lt;256; i++) { array[i] =0; } // 定义一个指针 指向当前字符串头部 char* p = cha; // 遍历每个字符 while (*p != '\\0') { // 在字母对应存储位置 进行出现次数+1操作 array[*(p++)]++; } // 将P指针重新指向字符串头部 p = cha; // 遍历每个字母的出现次数 while (*p != '\\0') { // 遇到第一个出现次数为1的字符，打印结果 if (array[*p] == 1) { result = *p; break; } // 反之继续向后遍历 p++; } return result;}@end 8.查找两个子视图的共同父视图.h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface CommonSuperFind : NSObject// 查找两个视图的共同父视图- (NSArray&lt;UIView *&gt; *)findCommonSuperView:(UIView *)view other:(UIView *)viewOther;@end .m实现文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &quot;CommonSuperFind.h&quot;@implementation CommonSuperFind- (NSArray &lt;UIView *&gt; *)findCommonSuperView:(UIView *)viewOne other:(UIView *)viewOther{ NSMutableArray *result = [NSMutableArray array]; // 查找第一个视图的所有父视图 NSArray *arrayOne = [self findSuperViews:viewOne]; // 查找第二个视图的所有父视图 NSArray *arrayOther = [self findSuperViews:viewOther]; int i = 0; // 越界限制条件 while (i &lt; MIN((int)arrayOne.count, (int)arrayOther.count)) { // 倒序方式获取各个视图的父视图 UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1]; UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1]; // 比较如果相等 则为共同父视图 if (superOne == superOther) { [result addObject:superOne]; i++; } // 如果不相等，则结束遍历 else{ break; } } return result;}- (NSArray &lt;UIView *&gt; *)findSuperViews:(UIView *)view{ // 初始化为第一父视图 UIView *temp = view.superview; // 保存结果的数组 NSMutableArray *result = [NSMutableArray array]; while (temp) { [result addObject:temp]; // 顺着superview指针一直向上查找 temp = temp.superview; } return result;}@end 9.无序数组中的中位数(快排思想).h声明文件 12345678#import &lt;Foundation/Foundation.h&gt;@interface MedianFind : NSObject// 无序数组中位数查找int findMedian(int a[], int aLen);@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970.m实现文件#import &quot;MedianFind.h&quot;@implementation MedianFind//求一个无序数组的中位数int findMedian(int a[], int aLen){ int low = 0; int high = aLen - 1; int mid = (aLen - 1) / 2; int div = PartSort(a, low, high); while (div != mid) { if (mid &lt; div) { //左半区间找 div = PartSort(a, low, div - 1); } else { //右半区间找 div = PartSort(a, div + 1, high); } } //找到了 return a[mid];}int PartSort(int a[], int start, int end){ int low = start; int high = end; //选取关键字 int key = a[end]; while (low &lt; high) { //左边找比key大的值 while (low &lt; high &amp;&amp; a[low] &lt;= key) { ++low; } //右边找比key小的值 while (low &lt; high &amp;&amp; a[high] &gt;= key) { --high; } if (low &lt; high) { //找到之后交换左右的值 int temp = a[low]; a[low] = a[high]; a[high] = temp; } } int temp = a[high]; a[high] = a[end]; a[end] = temp; return low;}@end 10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad { [super viewDidLoad]; NSArray *oriArray = @[@(2),@(3),@(6),@(7),@(22),@(12)]; BOOL isHaveNums = [self twoNumSumWithTarget:9 Array:oriArray]; NSLog(@&quot;%d&quot;,isHaveNums);}- (BOOL)twoNumSumWithTarget:(int)target Array:(NSArray&lt;NSNumber *&gt; *)array { NSMutableArray *finalArray = [NSMutableArray array]; for (int i = 0; i &lt; array.count; i++) { for (int j = i + 1; j &lt; array.count; j++) { if ([array[i] intValue] + [array[j] intValue] == target) { [finalArray addObject:array[i]]; [finalArray addObject:array[j]]; NSLog(@&quot;%@&quot;,finalArray); return YES; } } } return NO;}","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95%E7%AF%87/"},{"title":"大厂常问iOS面试题--Runloop篇","text":"1.Runloop 和线程的关系？ 一个线程对应一个 Runloop。 主线程的默认就有了 Runloop。 子线程的 Runloop 以懒加载的形式创建。 Runloop 存储在一个全局的可变字典里，线程是 key ，Runloop 是 value。 2.RunLoop的运行模式 RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重写启动一个运行模式 12345- kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行- UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）- kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式- UIInitializationRunLoopMode：在刚启动App时进入的第一个Mode，启动完成后就不再使用- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 3.runloop内部逻辑？ 实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 内部逻辑： 通知 Observer 已经进入了 RunLoop 通知 Observer 即将处理 Timer 通知 Observer 即将处理非基于端口的输入源（即将处理 Source0） 处理那些准备好的非基于端口的输入源（处理 Source0） 如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1） 通知 Observer 线程即将休眠 将线程置于休眠状态，直到发生以下事件之一 事件到达基于端口的输入源（port-based input sources）(也就是 Source0) Timer 到时间执行 外部手动唤醒 为 RunLoop 设定的时间超时 通知 Observer 线程刚被唤醒（还没处理事件） 处理待处理事件 如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步 如果输入源被触发，处理该事件（文档上是 deliver the event） 如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步 4.autoreleasePool 在何时被释放？ App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 5.GCD 在Runloop中的使用？ GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。 6.AFNetworking 中如何运用 Runloop? AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }}+ (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start { [self.lock lock]; if ([self isCancelled]) { [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } else if ([self isReady]) { self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } [self.lock unlock];} 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 7.PerformSelector 的实现原理？ 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 8.PerformSelector:afterDelay:这个方法在子线程中是否起作用？ 不起作用，子线程默认没有 Runloop，也就没有 Timer。可以使用 GCD的dispatch_after来实现 9.事件响应的过程？ 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 10.手势识别的过程？ 当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 11.CADisplayLink和Timer哪个更精确CADisplayLink 更精确 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-Runloop%E7%AF%87/"},{"title":"大厂常问iOS面试题--组件化篇","text":"1.组件化有什么好处？ 业务分层、解耦，使代码变得可维护； 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护； 便于各业务功能拆分、抽离，实现真正的功能复用； 业务隔离，跨团队开发代码控制和版本风险控制的实现； 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力； 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App） 2.你是如何组件化解耦的？ 分层 基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制； 基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计 业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供； 中间件：target-action，url-block，protocol-class 3.为什么CTMediator方案优于基于Router的方案？Router的缺点： 在组件化的实施过程中，注册URL并不是充分必要条件。组件是不需要向组件管理器注册URL的，注册了URL之后，会造成不必要的内存常驻。注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过runtime做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。 在iOS领域里，一定是组件化的中间件为openURL提供服务，而不是openURL方式为组件化提供服务。如果在给App实施组件化方案的过程中是基于openURL的方案的话，有一个致命缺陷：非常规对象(不能被字符串化到URL中的对象，例如UIImage)无法参与本地组件间调度。 在本地调用中使用URL的方式其实是不必要的，如果业务工程师在本地间调度时需要给出URL，那么就不可避免要提供params，在调用时要提供哪些params是业务工程师很容易懵逼的地方。 为了支持传递非常规参数，蘑菇街的方案采用了protocol，这个会侵入业务。由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖public Protocol。这对于将来的业务迁移是有非常大的影响的。 CTMediator的优点： 调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。 组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。 方便传递各种类型的参数。 4.基于CTMediator的组件化方案，有哪些核心组成？ CTMediator中间件：集成就可以了 模块Target_%@：模块的实现及提供对外的方法调用Action_methodName，需要传参数时，都统一以NSDictionary*的形式传入。 CTMediator+%@扩展：扩展里声明了模块业务的对外接口，参数明确，这样外部调用者可以很容易理解如何调用接口。","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%AF%87/"},{"title":"大厂常问iOS面试题--通知机制解析篇","text":"简述本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。同时也解决了阿里、字节：一套高效的iOS面试题中关于通知的问题，相信看完此文再也不怕面试官问我任何通知相关问题了 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计 问题列表先把之前的问题列出来，详细读完本文之后，你会找到答案 实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等） 通知的发送时同步的，还是异步的 NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息 NSNotificationQueue是异步还是同步发送？在哪个线程响应 NSNotificationQueue和runloop的关系 如何保证通知接收的线程在主线程 页面销毁时不移除通知会崩溃吗 多次添加同一个通知会是什么结果？多次移除通知呢 下面的方式能接收到通知吗？为什么 12345// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@&quot;TestNotification&quot; object:nil];复制代码 关键类结构NSNotification用于描述通知的类，一个NSNotification对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性： 12345678910@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;.../* Querying a Notification Object */- (NSString*) name; // 通知的name- (id) object; // 携带的对象- (NSDictionary*) userInfo; // 配置信息@end复制代码 一般用于发送通知时使用，常用api如下： 12- (void)postNotification:(NSNotification *)notification;复制代码 NSNotificationCenter这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而NSNotificationCenter类主要负责三件事 添加通知 发送通知 移除通知 核心API如下： 12345678910// 添加通知- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;// 发送通知- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;// 删除通知- (void)removeObserver:(id)observer;复制代码 NSNotificationQueue功能介绍通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用NSNotificationCenter的发送接口进行发送通知，这么看NSNotificationQueue最终还是调用NSNotificationCenter进行消息的分发 另外NSNotificationQueue是依赖runloop的，所以如果线程的runloop未开启则无效，至于为什么依赖runloop下面会解释 NSNotificationQueue主要做了两件事： 添加通知到队列 删除通知 核心API如下： 123456// 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;// 删除通知，把满足合并条件的通知从队列中删除- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;复制代码 队列的合并策略和发送时机把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义 12345678910111213// 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) { NSPostWhenIdle = 1, // runloop空闲时发送通知 NSPostASAP = 2, // 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的 NSPostNow = 3 // 立刻发送或者合并通知完成之后发送};// 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) { NSNotificationNoCoalescing = 0, // 默认不合并 NSNotificationCoalescingOnName = 1, // 只要name相同，就认为是相同通知 NSNotificationCoalescingOnSender = 2 // object相同};复制代码 GSNotificationObserver这个类是GNUStep源码中定义的，它的作用是代理观察者，主要用来实现接口：addObserverForName：object: queue: usingBlock:时用到，即要实现在指定队列回调block，那么GSNotificationObserver对象保存了queue和block信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把block抛到指定queue中执行，定义如下： 123456789101112131415161718192021222324252627282930313233@implementation GSNotificationObserver{ NSOperationQueue *_queue; // 保存传入的队列 GSNotificationBlock _block; // 保存传入的block}- (id) initWithQueue: (NSOperationQueue *)queue block: (GSNotificationBlock)block{......初始化操作}- (void) dealloc{....}// 响应接收通知的方法，并在指定队列中执行block- (void) didReceiveNotification: (NSNotification *)notif{ if (_queue != nil) { GSNotificationBlockOperation *op = [[GSNotificationBlockOperation alloc] initWithNotification: notif block: _block]; [_queue addOperation: op]; } else { CALL_BLOCK(_block, notif); }}@end复制代码 存储容器上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的 1234567891011121314151617// 根容器，NSNotificationCenter持有typedef struct NCTbl { Observation *wildcard; /* 链表结构，保存既没有name也没有object的通知 */ GSIMapTable nameless; /* 存储没有name但是有object的通知 */ GSIMapTable named; /* 存储带有name的通知，不管有没有object */ ...} NCTable;// Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs { id observer; /* 观察者，接收通知的对象 */ SEL selector; /* 响应方法 */ struct Obs *next; /* Next item in linked list. */ ...} Observation;复制代码 注册通知正式开始“注册通知”的深入研究，注册通知有几个常用方法，但只需要研究典型的一两个就够了，原理都是一样的 目前只介绍NSNotificationCenter的注册流程，NSNotificationQueue的方式在下面章节单独拎出来解释 接口1直接看源码（精简版便于理解）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*observer：观察者，即通知的接收者selector：接收到通知时的响应方法name: 通知nameobject：携带对象*/- (void) addObserver: (id)observer selector: (SEL)selector name: (NSString*)name object: (id)object { // 前置条件判断 ...... // 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它 o = obsNew(TABLE, selector, observer);/*======= case1： 如果name存在 =======*/ if (name) { //-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name); if (n == 0) { // 不存在，则创建 m = mapNew(TABLE); // 先取缓存，如果缓存没有则新建一个map GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m); ... } else { // 存在则把值取出来 赋值给m m = (GSIMapTable)n-&gt;value.ptr; } //-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节 n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object); if (n == 0) {// 不存在，则创建 o-&gt;next = ENDOBS; GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o); } else { list = (Observation*)n-&gt;value.ptr; o-&gt;next = list-&gt;next; list-&gt;next = o; } }/*======= case2：如果name为空，但object不为空 =======*/ else if (object) { // 以object为key，从nameless字典中取出对应的value，value是个链表结构 n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object); // 不存在则新建链表，并存到map中 if (n == 0) { o-&gt;next = ENDOBS; GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o); } else { // 存在 则把值接到链表的节点上 ... } }/*======= case3：name 和 object 都为空 则存储到wildcard链表中 =======*/ else { o-&gt;next = WILDCARD; WILDCARD = o; }}复制代码 逻辑说明从上面介绍的存储容器中我们了解到NCTable结构体中核心的三个变量以及功能：wildcard、named、nameless，在源码中直接用宏定义表示了：WILDCARD、NAMELESS、NAMED，下面逻辑会用到 建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图 case1: 存在name（无论object是否存在） 注册通知，如果通知的name存在，则以name为key从named字典中取出值n(这个n其实被MapNode包装了一层，便于理解这里直接认为没有包装)，这个n还是个字典，各种判空新建逻辑不讨论 然后以object为key，从字典n中取出对应的值，这个值就是Observation类型(后面简称obs)的链表，然后把刚开始创建的obs对象o存储进去 数据结构关系图 这里就回答了上述问题列表的问题1的一部分，现在梳理下存储关系 如果注册通知时传入name，那么会是一个双层的存储结构 找到NCTable中的named表，这个表存储了还有name的通知 以name作为key，找到value，这个value依然是一个map map的结构是以object作为key，obs对象为value，这个obs对象的结构上面已经解释，主要存储了observer &amp; SEL case2: 只存在object 以object为key，从nameless字典中取出value，此value是个obs类型的链表 把创建的obs类型的对象o存储到链表中 数据结构关系图 只存在object时存储只有一层，那就是object和obs对象之间的映射 case3: 没有name和object这种情况直接把obs对象存放在了Observation *wildcard 链表结构中 接口2源码接口功能： 此接口实现的功能是在接收到通知时，在指定队列queue执行block 123456789101112131415161718// 这个api使用频率较低，怎么实现在指定队列回调block的，值得研究- (id) addObserverForName: (NSString *)name object: (id)object queue: (NSOperationQueue *)queue usingBlock: (GSNotificationBlock)block{ // 创建一个临时观察者 GSNotificationObserver *observer = [[GSNotificationObserver alloc] initWithQueue: queue block: block]; // 调用了接口1的注册方法 [self addObserver: observer selector: @selector(didReceiveNotification:) name: name object: object]; return observer;}复制代码 逻辑说明这个接口依赖于接口1，只是多了一层代理观察者GSNotificationObserver，在关键类结构中已经介绍了它，设计思路值得学习 创建一个GSNotificationObserver类型的对象observer，并把queue和block保存下来 调用接口1进行通知的注册 接收到通知时会响应observer的didReceiveNotification:方法，然后在didReceiveNotification:中把block抛给指定的queue去执行 小结 从上述介绍可以总结，存储是以name和object为维度的，即判定是不是同一个通知要从name和object区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的，问题列表中的第九题也迎刃而解了 理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑 存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次 发送通知源码发送通知的核心逻辑比较简单，基本上就是查找和调用响应方法，核心函数如下 123456789101112131415161718192021222324252627// 发送通知- (void) postNotificationName: (NSString*)name object: (id)object userInfo: (NSDictionary*)info{// 构造一个GSNotification对象， GSNotification继承了NSNotification GSNotification *notification; notification = (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone()); notification-&gt;_name = [name copyWithZone: [self zone]]; notification-&gt;_object = [object retain]; notification-&gt;_info = [info retain]; // 进行发送操作 [self _postAndRelease: notification];}//发送通知的核心函数，主要做了三件事：查找通知、发送、释放资源- (void) _postAndRelease: (NSNotification*)notification { //step1: 从named、nameless、wildcard表中查找对应的通知 ... //step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的 [o-&gt;observer performSelector: o-&gt;selector withObject: notification]; //step3: 释放资源 RELEASE(notification);}复制代码 逻辑说明其实上述代码注释说的很清晰了，主要做了三件事 通过name &amp; object 查找到所有的obs对象(保存了observer和sel)，放到数组中 通过performSelector：逐一调用sel，这是个同步操作 释放notification对象 小结从源码逻辑可以看出发送过程的概述：从三个存储容器中：named、nameless、wildcard去查找对应的obs对象，然后通过performSelector：逐一调用响应方法，这就完成了发送流程 核心点： 同步发送 遍历所有列表，即注册多次通知就会响应多次 删除通知这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载源码看下吧 要注意的点： 查找时仍然以name和object为维度的，再加上observer做区分 因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉 1234567891011121314151617// 删除已经注册的通知- (void) removeObserver: (id)observer name: (NSString*)name object: (id)object { if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil) return; ...}- (void) removeObserver: (id)observer{ if (observer == nil) return; [self removeObserver: observer name: nil object: nil];}复制代码 异步通知上面介绍的NSNotificationCenter都是同步发送的，而这里介绍关于NSNotificationQueue的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了runloop的时机来触发的 入队下面为精简版的源码，看源码的注释，基本上能明白大致逻辑 根据coalesceMask参数判断是否合并通知 接着根据postingStyle参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：_asapQueue、_idleQueue 核心点： 队列是双向链表实现 当postingStyle值是立即发送时，调用的是NSNotificationCenter进行发送的，所以NSNotificationQueue还是依赖NSNotificationCenter进行发送 1234567891011121314151617181920212223242526272829303132333435/** 把要发送的通知添加到队列，等待发送* NSPostingStyle 和 coalesceMask在上面的类结构中有介绍* modes这个就和runloop有关了，指的是runloop的mode*/ - (void) enqueueNotification: (NSNotification*)notification postingStyle: (NSPostingStyle)postingStyle coalesceMask: (NSUInteger)coalesceMask forModes: (NSArray*)modes{ ...... // 判断是否需要合并通知 if (coalesceMask != NSNotificationNoCoalescing) { [self dequeueNotificationsMatching: notification coalesceMask: coalesceMask]; } switch (postingStyle) { case NSPostNow: { ... // 如果是立马发送，则调用NSNotificationCenter进行发送 [_center postNotification: notification]; break; } case NSPostASAP: // 添加到_asapQueue队列，等待发送 add_to_queue(_asapQueue, notification, modes, _zone); break; case NSPostWhenIdle: // 添加到_idleQueue队列，等待发送 add_to_queue(_idleQueue, notification, modes, _zone); break; }}复制代码 发送通知这里截取了发送通知的核心代码，这个发送通知逻辑如下： runloop触发某个时机，调用GSPrivateNotifyASAP()和GSPrivateNotifyIdle()方法，这两个方法最终都调用了notify()方法 notify()所做的事情就是调用NSNotificationCenter的postNotification:进行发送通知 123456789101112131415161718192021222324252627282930313233static void notify(NSNotificationCenter *center, NSNotificationQueueList *list, NSString *mode, NSZone *zone){ ...... // 循环遍历发送通知 for (pos = 0; pos &lt; len; pos++) { NSNotification *n = (NSNotification*)ptr[pos]; [center postNotification: n]; RELEASE(n); } ...... }// 发送_asapQueue中的通知void GSPrivateNotifyASAP(NSString *mode){ notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_asapQueue, mode, item-&gt;queue-&gt;_zone);}// 发送_idleQueue中的通知void GSPrivateNotifyIdle(NSString *mode){ notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_idleQueue, mode, item-&gt;queue-&gt;_zone);}复制代码 小结对于NSNotificationQueue总结如下 依赖runloop，所以如果在其他子线程使用NSNotificationQueue，需要开启runloop 最终还是通过NSNotificationCenter进行发送通知，所以这个角度讲它还是同步的 所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程 主线程响应通知异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？ 其实也是比较常见的问题了，基本上解决方式如下几种： 使用addObserverForName: object: queue: usingBlock方法注册通知，指定在mainqueue上响应block 在主线程注册一个machPort，它是用来做线程通信的，当在异步线程收到通知，然后给machPort发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有 总结本文写的内容比较多，以GNUStep源码为基础进行研究，全面阐述了通知的存储、发送、异步发送等原理，对研究学习有很大帮助","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%E7%AF%87/"},{"title":"大厂常问iOS面试题--视图和图形篇","text":"本篇我们来讲一下 【iOS面试题的视图&amp;图形】相关的问题. 视图&amp;图像相关主要问题列表如下: AutoLayout的原理，性能如何 UIView &amp; CALayer的区别 事件响应链 drawrect &amp; layoutsubviews调用时机 UI的刷新原理 隐式动画 &amp; 显示动画区别 什么是离屏渲染 imageName&amp;imageWithContentsOfFile区别 多个相同的图片，会重复加载吗 图片是什么时候解码的，如何优化 图片渲染怎么优化 如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决 1.AutoLayout的原理，性能如何?AutoLayout的原理 来历 一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（论文地址:http://constraints.cs.washington.edu/solvers/uist97.html）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的Cassowary网站上http://constraints.cs.washington.edu/cassowary/。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的https://github.com/pybee/cassowary。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。 论文下载链接比较慢,我下载了一份Cassowary原文放到了我的博客 大家可以自由下载. AutoLayout的原理就是用Cassowary算法来将布局问题抽象成线性不等式，并分解成多个位置间的约束 因为多了计算视图大小frame的过程,所以性能肯定没有指定Frame坐标要快. 详细的原理以及高阶原理请参考戴铭老师的文章 戴铭老师写的 深入剖析Auto Layout，分析iOS各版本新增特性 性能如何?下面是WWDC2018 High Performance Auto Layout中对比的iOS12和iOS11下分别使用自动布局的性能对比现场. 经过实验得出如下图标结论: iOS12之前，视图嵌套的数量对性能的影响是呈指数级增长的，而iOS12优化之后对性能的影响是线性增长，对性能消耗不大。 无论如何优化也肯定不如CGRectFrame那样的设置更加直接,性能更好. 2.UIView &amp; CALayer的区别 区别 UIView CALayer 继承父类 UIView:UIResponder:NSObject CALayer:NSObject 用途 可以处理触摸事件 不处理用户的交互,不参与响应事件传递 两者关系 有一个CALayer成员变量 eg: view.layer 是UIView的成员变量 分工 处理交互层事件并包装各种图形的简单设置 底层渲染图形,支持动画 3.事件响应链下面这篇文章我已经在前几篇将runloop的时候提了不止一次,前列建议阅读,快手的同事大部分都以这个理解为标准 iOS触摸事件全家桶 4. drawrect &amp; layoutsubviews调用时机layoutSubviews:(相当于layoutSubviews()函数)在以下情况下会被调用： init初始化不会触发layoutSubviews。 addSubview会触发layoutSubviews。 设置view的Frame会触发layoutSubviews (frame发生变化触发)。 滚动一个UIScrollView会触发layoutSubviews。 旋转Screen会触发父UIView上的layoutSubviews事件。 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。 直接调用setLayoutSubviews。 drawrect:(drawrect()函数)在以下情况下会被调用： drawrect:是在UIViewController的loadView:和ViewDidLoad:方法之后调用. 当我们调用[UIFont的 sizeToFit]后,会触发系统自动调用drawRect: 当设置UIView的contentMode或者Frame后会立即触发触发系统调用drawRect: 直接调用setNeedsDisplay设置标记 或setNeedsDisplayInRect:的时候会触发drawRect: 知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下UIView的渲染过程. 5.UI的刷新原理这个问题我不知道问的是不是iOS离屏渲染过程,我来简单的回到一下这个吧 iOS 的MainRunloop 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕在这过程中要完成以下的工作: view的缓冲区创建 view内容的绘制(如果重写了 drawRect) 接收和处理系统的触摸事件 我们看到的UI图形实际上是CPU和GPU不断配合工作的结果.经过UIView的渲染过程 后我们的UI会不间断的接收系统图给我们的事件. 由于主线程的runloop 一直在回调,我们的UI就得到了刷新的窗口,是渲染还是处理事件都是因为runloop不断工作的结果.前几篇我们学过 main线程的runloop默认是启动的.因为我们响应交互. 不知道我这样回答是否满足这个问题的答案.如果回答的不对烦请下方评论区留言 告知我将持续改进. 6.隐式动画 &amp; 显示动画区别隐式动画一直存在 如需关闭需设置 显式动画是不存在，如需显式 要开启 只需要观察动画执行完成的结果 比如: 一个简单UIView的frame移动 如果从A点移动到B点 移动完成 回到原始位置就是隐式动画 Core Animation 是显式动画.因为它既可以直接对其layer属性做动画，也可以覆盖默认的图层行为. 7.imageName&amp;imageWithContentsOfFile区别 区别 UIView imageWithContentsOfFile 不同点 会图片缓存到内存中 无缓存 8.什么是离屏渲染 iOS离屏渲染的深入研究 9.多个相同的图片，会重复加载吗不会,GPU有 像素点缓存的mask. 10.图片是什么时候解码的，如何优化是加载到内存中,从UIImge-&gt;CGImage-&gt;CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码. 如何优化自己手动操作图片的编码API CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库. 参考PINRemoteImage或者YYWebImage开源 11.图片渲染怎么优化可以从阴影,圆角入手.帧率,电量,图片的锯齿等等. iOS开发-视图渲染与性能优化 12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决现象是 图形清晰,场景逼真,但是一般arm芯片的GPU 刷新超过60Hz一定会超级费电,手机发热导致降频.FPS降低,因为低能耗电量不足,无法支持GPU高刷新率 解决办法只能用xcode自带工具检测,看渲染过程哪里可以优化. 总结简单回答了一些图形相关的问题,大部分都是iOS离屏渲染,这个地方大家要认真学习.很多资料看起来比较耗时.","link":"/%E5%A4%A7%E5%8E%82%E5%B8%B8%E9%97%AEiOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A7%86%E5%9B%BE%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%AF%87/"},{"title":"头条-最新iOS面试真题总结","text":"头条最新iOS面试真题总结本文汇总了头条iOS面试中的经典真题，涵盖基础知识、算法、架构设计及多线程等方面。内容来源于真实面试经验，适合准备iOS相关岗位面试的同学参考。 温馨提示：本文侧重题目整理，部分知识点可结合官方文档和经典书籍深入学习。欢迎留言交流，互相提升。 一面题目汇总 自我介绍及项目相关介绍 如何自定义导航跳转 Runtime的理解与应用 KVC（键值编码）的用途及原理 Method Swizzling的注意事项 引用计数机制的理解 RunLoop的理解与状态 AutoreleasePool的使用场景 TableView性能优化，如何减少卡顿 属性关键字：copy、assign、retain、weak的区别和使用场景 JSON转Model的实现思路 代码布局规范 多屏幕适配方案 HTTP请求头与响应头解析 Cookie机制 NSCache缓存机制介绍 自己设计一个缓存器的思路 LRU缓存算法的实现方式 SDWebImage的基本原理 二叉树先序遍历（递归和非递归实现） 二面题目汇总 MVC架构存在的缺点 介绍其他架构模式（如MVVM、VIPER等） 常见编码方式（UTF-8、UTF-16等） 字符串翻转算法设计 多线程实现方式及其区别（NSThread、GCD、NSOperation） 队列和线程的关系 线程安全相关题目及解决方案 各种锁的类型及区别（互斥锁、自旋锁、读写锁等） 属性关键字的详细解释 assign是否可以用于OC对象，及其风险 copy与strong的区别 weak是如何实现自动赋nil的 为什么不可变对象属性使用copy更安全 assign在对象中的使用注意点 pod update与pod install的区别 layoutIfNeeded与setNeedsLayout的区别 抓包工具如何抓取HTTPS请求的原理 isEqual与hash方法的关系 Bitmap数据结构介绍 可变数组的实现原理 如何hook一个对象的方法而不影响其他对象 代码中如何避免大量if else写法 自旋锁和互斥锁的区别及使用场景 三面题目汇总 详细介绍项目经验，重点讲自己擅长的技术点 数组copy后，里面的元素是否复制一份新对象？ 浅拷贝和深拷贝的区别与实现方式 TCP为什么是三次握手，四次挥手？原理解析 面试总结头条iOS面试通常采用视频形式，一条龙流程服务较完善。面试内容覆盖基础知识广泛，既有理论考察，也注重实际项目经验和算法能力。建议候选人重点夯实以下方面： Objective-C及Swift语言基础 iOS常用设计模式与架构 Runtime机制和相关技术（如Method Swizzling、消息转发等） 多线程与并发编程（GCD、NSOperation、锁机制等） 网络协议和请求处理（HTTP/HTTPS、TCP/IP） 算法与数据结构基础（字符串处理、树、链表、排序等） 项目经验梳理，能够清晰描述技术细节和难点 欢迎大家收藏与分享，也可以留言补充或提问，一起进步！ 相关资源推荐： 《Objective-C高级编程》 《iOS开发者面试宝典》 Ray Wenderlich iOS教程 LeetCode算法题刷题平台 祝你面试顺利，早日拿到理想offer！","link":"/%E5%A4%B4%E6%9D%A1-%E2%80%94%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"常见 iOS 面试真题汇总（基础、实战、系统、网络、架构全覆盖）","text":"常见 iOS 面试真题总结（持续更新）前言近期的 iOS 面试求职可以说是经历了一波小高潮。话不多说，下面是我精心整理的一份 iOS 面试真题合集，覆盖各类公司常问问题，供大家查缺补漏。 面试题目录 iOS 基础题 iOS 实战题 网络通信题 计算机系统题 设计模式题 架构设计题 数据结构与算法题 补充题 1、iOS 基础题 分类（Category）和扩展（Extension）的区别及使用场景？ atomic 的实现机制？为什么不能保证线程安全？ __weak 修饰符的释放过程？SideTable 的结构与作用？ AutoreleasePool 的数据结构及 AutoreleasePoolPage 的底层分析 对象、类对象、元类的关系？为什么方法存在类对象中？ Objective-C 中的内省方法、class 与 objc_getClass 区别？ RunLoop 的作用及内部机制？与线程/内存管理的关系？ 离屏渲染的触发场景及性能影响？ 2、iOS 实战题 NSOperation 相比 GCD 的优势和使用场景？ App 启动优化策略（main 函数前后阶段分析） 无埋点埋点系统的实现思路？应具备哪些特性？ App 崩溃场景分析与处理手段 App 卡顿的原因与性能优化方法（如帧率监测、主线程任务分离等） 3、网络题 App 网络层优化策略有哪些？（缓存、压缩、重试机制等） TCP 三次握手、四次挥手原理？为何必须三次？ HTTPS 握手流程、非对称加密使用原因、双向认证？ HTTPS 如何校验身份与数据完整性？ 如何用 Charles 抓取 HTTPS 请求？中间人证书原理？ 4、计算机系统题 编译过程的各个阶段（预处理、编译、汇编、链接） 静态链接 vs 动态链接？.a 和 .dylib 区别？ static 与 const 的区别与使用场景？ 死锁出现的四个条件？如何预防？ 常见锁的类型、底层实现、性能对比与适用场景？ 5、设计模式题 除了单例、观察者，还了解哪些设计模式？ iOS SDK 中使用的设计模式示例（MVC、代理、组合等） 每种设计模式的参与角色与交互机制？ 6、架构 &amp; 设计题 MVC、MVVM、MVP 的本质区别与优缺点？ 面向对象的 SOLID 原则？如何在项目中落地？ 常见重构技巧？重构的时机与作用？ 框架 vs 设计模式 的本质区别？ 三方框架源码分析（如 AFNetworking、Masonry、SDWebImage）与设计思想总结 7、数据结构 &amp; 算法题 链表与数组的区别？插入/查找复杂度？ 哈希表结构、冲突解决方法（开放定址、链式散列等） 排序算法手写：冒泡、选择、插入、快速排序（二路/三路） 链表题：判断链表有无环；删除特定值节点 数组题：有序数组中找和为指定值的两个数；合并有序数组 二叉树题：反转二叉树；判断两个二叉树是否相等 8、额外补充（进阶 &amp; 冷门） UIView 与 CALayer 的关系？drawRect 是否影响性能？ UIImageView 如何显示超大图并支持缩放？ fishhook 如何工作？为何不能修改静态链接库符号？ C++ 虚函数调用 vs Objective-C 消息发送机制？ placement new 是什么？OC 中如何实现？ ARC 下 C++ 容器如何管理 Objective-C 对象？ id、self、super 的语法差异？ isa 指针结构和作用？ Block 修改变量除了 __block 还有什么方法？ NSDictionary 和 NSHashTable 区别与场景？ Swift 中 String.Index 的设计优缺点？ TCP 长连接断网后服务器是否能立即感知？ Wireshark 抓不到 SSL 原始数据的原因？ backtrace 的实现原理？用户态 or 内核态？ malloc 指针 double free 与访问 freed 指针的异常区别？ RunLoop 是死循环吗？为何不会卡死系统？ Runtime 源码中的 fastpath/slowpath 机制？ Runtime 中 SideTable 的用途？ Objective-C 如何实现系统升级下的 ABI 稳定性？ 结语刷题只是准备面试的一部分，更关键的是理解每一个问题背后的原理与设计理念。在找工作的同时，不断提升技术深度，整理项目亮点，打磨软实力，才能真正从容应对。 ✨ 祝每位正在准备 iOS 面试的开发者都能收获满意的 offer！你值得更好的舞台！","link":"/%E5%B8%B8%E8%A7%81-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"快手-最新iOS面试真题总结","text":"背景面的是快手X3岗位，视频面试，不支持周末，但是可以选择晚上时间。视频面试是通过牛客网进行的，以下是记下来的各轮面试题，对于一些iOS基础知识就不做解答了。 一面1、用递归写一个算法，计算从1到100的和。 1234567891011func sum(value: Int) -&gt; Int { if value &lt;= 0 { return 0 } var number = value return value + sum(value: number - 1)}// 计算过程let result = sum(value: 100)print(result)复制代码 写完算法之后又围绕着问了几个问题，都是算法基础： 算法的时间复杂度是多少 递归会有什么缺点 不用递归能否实现，复杂度能否降到O(1) 2、property的作用是什么，有哪些关键词，分别是什么含义？ 3、父类的property是如何查找的？ 4、NSArray、NSDictionary应该如何选关键词？ 5、copy和muteCopy有什么区别，深复制和浅复制是什么意思，如何实现深复制？ 6、用runtime做过什么事情？runtime中的方法交换是如何实现的？ 7、讲一下对KVC合KVO的了解，KVC是否会调用setter方法？ 8、__block有什么作用 9、说一下对GCD的了解，它有那些方法，分别是做什么用的？ 10、对二叉树是否了解？ 面试官是想接着问这方面的问题的。我当时说了不了解，然后就没有后续了。 二面1、ARC和MRC的区别，iOS是如何管理引用计数的，什么情况下引用计数加1什么情况引用计数减一？ 2、在MRC下执行[object autorelease]会发生什么，autorelease是如何实现的？ 3、OC如何实现多继承？ 这个当时没有答好。其实借助于消息转发，protocol和类别都可以间接实现多继承。 4、对设计模式有什么了解，讲一下其中一种是如何使用的。 5、有没有哪个开源库让你用的很舒服，讲一下让你舒服的地方。 6、一张100*100，RGBA的png图像解压之后占多大内存空间。 5、算法题 题目：给定一个个数字arr，判断数组arr中是否所有的数字都只出现过一次。 这个并没有要求写出来，说是提供思路就行了。我当时给的方案是在便利数组的时候，用一个字典把便利的元素存起来，如果在后面的便利过程中新元素在字典中存在过就说明，有重复数字出现。时间复杂度是O(n)。 当时也问了有没有办法进行优化，我当时想到了将数组转成Set，然后和原数组比较，两个集合的数量是否变化。 7、因为我跟他介绍自己Swift用的多一些，然后问了些Swift跟OC的区别，各自的优缺点。 8、为什么离职，有什么职业规划。 三面1、给定一个Int型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。 123输入: [3,30,34,5,9]输出: 9534330复制代码 这个是leetcode的179题，难度中等。面试官让先说思路，再去做题。事先说一下这个题我没有做过。当时的思路是用冒泡法进行排序，排序的前提是将较少位数的数字进行循环补齐，例如3和30的比较，变成33和30的比较，34和4的比较变成34和44的比较，然后将结果从大到小整合成字符串输出。 但是做题是却发现没那么简单，位数的补齐对于2位和3位数的比较还需要求位数的最小公倍数，将他们都转成6位数才能比较。在挣扎了5分钟做了就做罢了。 后来再去做这道题，其实这就是一个排序而已，只不过他的规则是按高位优先级更高的原则，而这一点跟字符串的比较保持一致，如果再加一些Swift的高阶函数，就可以写成： 123456789101112func largestNumber(_ nums: [Int]) -&gt; String { let sort = nums.map {&quot;\\($0)&quot;}.sorted { (lStr, rStr) -&gt; Bool in return lStr + rStr &gt; rStr + lStr } let result = sort.joined() if result.prefix(1) == &quot;0&quot; { return &quot;0&quot; } else { return result }}复制代码 2、项目中有这么一个方法func findfile(dir: String suffix: String) -&gt; [String] ，可以通过输入文件夹目录，和后缀检索出所需的文件。 例如需要在某个文件中检索txt文件或者mp4文件，那就传入dir和suffix就行了。现在又有一些需求，例如需要检索utf8格式的txt或者h264编码的mp4，也会有一些例如查找最近一周更新过的文件这样的需求，你如何优化这个类，让它满足这些情况？ 我首先想到的是这么多需求不可能一个方法就完成，需要根据不同场景拆出不同的方法，但是这些同属于文件操作，会有一个共同使用的方法就是检索文件。这个方法需要传入文件目录，然后递归的返回当前目录所有文件路径。外部不同场景的调用逻辑就用一个enum完成，不同值对应相同范围的不同种类。 面试官比较关注内部共用的文件检索怎么写，他说子文件如果过多怎么办，如何优化。我有点懵，查找文件至少是要遍历一遍的，子文件过多，这个应该是没法优化的啊。中间卡了一段时间，后来他给了提示说是不是可以用block实现，将文件路径返回出去，由外部决定当前文件是否可用，最终外部的调用类是这个样子。 12345//我的方案//func findDir(_ dir: String) -&gt; [String]//block方案func findDir(_ dir: String, block: ((String) -&gt; Bool))复制代码 我想来确实没毛病，用block返回内容至少不会将该目录的所有文件都由一个对象持有，而前面一堆的铺垫其实也都是为验证block方案的好处。 其实事后想下这个问题没啥难的，这种写法自己也有写过，但当时就是没想起来，可能前面一圈的铺垫给我带偏了吧，说亏也不亏，以后多多努力吧。 总结 整体来看，快手的面试题跟我在别处看到的iOS面试题对比要简单些。一面主要是基础知识，二面考察更全面一些，更多让自己谈一些对技术的理解，三面则是更偏实践一些。 算法虽然三轮都有，但相对比较简单，即使写不出来，有思路也是可以的。当然写出来肯定是加分项，所以大家准备面试时，应该都看一下。算法相关的，排序，数组，二叉树，这几类是重点。","link":"/%E5%BF%AB%E6%89%8B%E2%80%94%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"抖音最新 iOS 面试真题汇总（2024年一二三面完整整理）","text":"本文整理了抖音 iOS 面试过程中遇到的最新真题汇总（涵盖一面、二面、三面），内容涉及数据结构、网络协议、系统架构、iOS 多线程、性能优化、底层原理等多个模块，适合准备大厂 iOS 岗位的开发者系统复习。 🙋 面试前说明由于时间有限，未能对所有题目撰写详解答案，但整体内容覆盖全面，记录了真实的面试题与准备过程，希望能为正在面试或准备面试的同学提供参考与帮助。欢迎交流讨论。 📌 一面面试题（技术基础 + 网络 + 多线程） 求二叉树两个节点的最近公共父节点 输入两个节点，可能为 null，可能不在树中。 反转链表（经典算法题） HTTP 基础与 HTTP/2.0 新特性 多路复用、二进制帧、服务器推送等。 iOS9 - iOS13 每个版本说一个新特性 iOS 9：App Transport Security iOS 10：UserNotifications 框架 iOS 11：大文件下载、拖拽 iOS 12：性能优化，Screen Time iOS 13：深色模式、Combine 框架、SwiftUI 多个任务执行完后统一处理的方法有哪些？ 使用 dispatch_group、信号量 dispatch_semaphore、栅栏 dispatch_barrier_async 不用 SDWebImage 如何实现图片加载与缓存？ 图片下载 → Memory Cache + Disk Cache → 显示 简述 SDWebImage 核心架构：异步下载 + 缓存策略 + HashKey 管理 TableView 中多个 Cell 同时请求同一个图片 URL，如何避免重复请求？ 请求去重（缓存或 URL 任务池） 建立 url-task 映射池，任务完成后统一回调更新所有 UIImageView 滑动 TableView 时，GIF 动图为何不动？ RunLoop 切换为 UITrackingRunLoopMode，暂停了 NSDefaultRunLoopMode 下的任务 了解 WebSocket 吗？说一下作用和使用场景 长连接协议，适用于实时通讯（如 IM、弹幕、直播互动等） 📌 二面面试题（系统设计 + 网络协议 + 多线程） 如何不用递归遍历 UIView 的所有 subviews？ 使用栈结构模拟 DFS 或 BFS 设计一个图片缓存系统（Memory + Disk）并代码实现 可借鉴 NSCache + 沙盒持久化逻辑 介绍 Clang/LLVM 静态分析的基本原理 AST 抽象语法树 → 语义分析 → 规则检测（如 Xcode 的静态分析功能） 计算机网络的七层协议栈简述 HTTP 属于哪一层协议？ 应用层协议 HTTP 常见返回码及含义？ 200 OK、301/302 重定向、403 禁止访问、404 找不到资源、500 服务器错误 HTTP 除了 GET/POST，还有哪些方法？ PUT、DELETE、HEAD、OPTIONS、PATCH HTTPS 简要介绍 基于 HTTP + TLS/SSL 加密协议 包含对称加密、非对称加密、数字证书 HTTPS 能防止中间人攻击吗？为什么？ 是的。通过证书校验和加密通信防止篡改与监听 TCP 与 UDP 的区别？ 线程与进程的区别？ 线程之间如何通信？ 不用 GCD 如何保证线程安全？ 使用锁机制（如 NSLock、pthread_mutex） iOS 多线程实现方式有哪些？ NSThread、GCD、NSOperationQueue 同步与异步的区别？ 串行队列与并发队列区别？ 队列和线程的关系？ 死锁是如何产生的？有哪些必要条件？ 互斥、请求保持、不可剥夺、循环等待 📌 三面面试题（网络底层 + 性能优化 + 系统架构） 合并两个有序链表（LeetCode 经典题） HTTPS 使用对称加密还是非对称加密？ 握手阶段用非对称，通信阶段用对称加密 TCP 的慢启动、拥塞控制、快重传介绍 客户端发起网络请求到响应的全过程？ DNS解析 → TCP握手 → HTTPS握手 → 发送请求 → 接收响应 → 渲染页面 DNS 查询过程中的 ISP 服务器不可用，会怎样？ 递归或迭代请求下一级 DNS 服务器，如根域名服务器 → 顶级域名服务器 → 权威 DNS 字典转模型的架构设计 + 夜间模式的设计 字典转模型可采用 KVC、Swift Codable 夜间模式基于主题管理中心/通知机制更新 UI 为何不使用第三方库如 YYModel、MJExtension？ 可控性差、不灵活、依赖大，调试困难 自定义方案更轻量、更好维护 夜间模式的缺点与优化？ 缺点：耗电、维护成本高 优化：使用动态色值、样式隔离 iOS 中的锁有哪些？ OSSpinLock（已废弃）、NSLock、@synchronized、dispatch_semaphore、pthread_mutex 常见数据存储方式？你项目中怎么用的？ UserDefaults、Plist、Keychain、SQLite（FMDB） 线程安全错误的常见表现？ 数据竞争、崩溃、数据错乱，常发生在 UI 更新或共享资源访问时 ✅ 总结：抖音 iOS 面试知识结构梳理 模块 涉及题型 数据结构 链表反转、合并链表、树的最近公共祖先 网络 HTTP/2、HTTPS、WebSocket、TCP/UDP、七层协议 多线程 GCD、信号量、栅栏、死锁、线程通信 系统设计 图片缓存系统、夜间模式、字典转模型 工具原理 LLVM、静态分析 项目经验 SDWebImage 实现、缓存优化、DNS 故障处理 🧠 建议准备： 常见算法题练熟（链表、二叉树、排序） 网络协议 &amp; HTTPS 握手过程深入理解 多线程调度机制（GCD、NSOperation）掌握细节 项目经验表达清晰，能举出优化点 iOS 系统架构底层原理适当了解 📎 如果你正在准备 iOS 面试，欢迎点赞收藏，持续更新更多真题汇总与答案详解。","link":"/%E6%8A%96%E9%9F%B3-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"拼多多最新iOS面试真题总结（JSON解析、多线程、安全性、架构设计）","text":"拼多多最新 iOS 面试真题总结本文整理了拼多多 iOS 岗位面试中常见的真题，涵盖 JSON 转模型、夜间模式、架构设计、多线程安全、Block 机制等重点知识，适合拼多多及其他互联网公司 iOS 面试准备参考。 一面题目 JSON 转模型实现方式 讨论如何将服务器返回的 JSON 数据转换为本地模型对象，涉及手写、第三方库（如 YYModel、MJExtension）等实现方式。 夜间模式设计 如何设计和实现夜间模式，切换颜色、样式及避免 UI 重绘卡顿。 播放器架构设计 简述播放器的模块划分、数据流及解码流程。 请求流程 网络请求从发起到接收响应的整个过程，包括 DNS 解析、TCP 连接、HTTP 协议。 服务端返回数据格式 除 JSON 外，还有哪些格式（XML、Protobuf、Thrift 等）。 哪些 Objective-C 对象是线程安全的 例如 NSString、NSArray 的不可变版本是线程安全的。 为什么要在主线程更新 UI UIKit 线程模型及主线程限制。 如何保证 OC 容器在多线程下的数据安全性 使用锁机制、线程安全的集合类或 GCD。 SDWebImage 内存设计及更新原则 缓存策略、内存缓存与磁盘缓存的区别及更新时机。 算法题 判断括号匹配性（如 ()[]{} 是否匹配） 只有一种括号的情况下，计算最少需要加多少括号才能满足匹配 二面题目 +load 和 +initialize 的理解与调用时机 讨论两者区别、调用顺序，父类与子类重写情况。 Objective-C 的动态性理解 运行时机制、消息发送、动态绑定。 消息转发机制及系统 API 消息重定向过程、forwardInvocation:、methodSignatureForSelector: 等。 Block 的理解 定义、使用场景。 Block 的变量捕获机制 变量如何捕获，捕获的变量类型（全局、栈、堆）。 __block 关键字实现原理 允许变量被修改，底层实现细节。 内存管理机制 ARC、MRC 的基本原理，引用计数机制。 用户点击屏幕后系统事件响应流程 如何找到触摸点对应的 View，事件传递链（Hit Testing 机制）。 总结拼多多 iOS 面试注重基础扎实，涵盖数据解析、多线程安全、内存管理和运行时机制等方面，建议重点复习： JSON 与模型映射技巧 夜间模式和架构设计思路 Objective-C 运行时和消息机制 Block 和变量捕获原理 多线程下数据安全设计 iOS 事件响应机制 欢迎大家留言交流，探讨更多面试技巧和知识点。祝你面试顺利，成功拿下拼多多 iOS 岗位！","link":"/%E6%8B%BC%E5%A4%9A%E5%A4%9A-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"字节跳动-最新iOS面试真题","text":"字节跳动最新iOS面试真题总结以下内容基于字节跳动iOS面试中真实遇到的题目，涵盖基础知识、算法、网络、多线程和系统设计等多个方面。适合面试准备者系统复习。 一面题目 自我介绍 介绍简历中的一个项目 面向对象的三个要素（封装、继承、多态） 多态的理解 Java、Python、Objective-C运行效率比较 Property详解，copy修饰符如何工作？ Property(nonatomic, copy)修饰NSMutableArray会有什么问题？ copy和mutableCopy的区别 类别（Category）的原理及实现 封装和重载的解释 Objective-C是否支持多重继承？ UITableView的复用原理 UITableView滑动卡顿的优化方法 viewDidLoad和viewDidAppear的调用时机及调用次数差异 页面间传值方式（属性传值、协议、Block、通知、extern全局变量、NSUserDefaults） 通知与代理（delegate）的区别 通知发送和接收是否在同一线程？ HTTP与HTTPS的区别 Objective-C中多线程的几种实现方案 NSURLConnection与NSURLSession的了解 NSURLSession的实现原理 HTTP常见的状态码及含义 编程题：实现二叉树的倒置 二面题目 博弈论题：老虎吃羊问题 算法题：青蛙跳格子问题（斐波那契数列） 熟悉使用的框架介绍 如何实现SDWebImage的二级缓存机制 @autoreleasepool { NSString *s; } 与 NSString *s; 的区别 对autorelease的理解 HTTP的理解 HTTP返回状态码详解 为什么说HTTP是无状态协议 为什么不用原生APNS实现推送 GCD的了解 dispatch_group_t与dispatch_barrier_sync的区别 NSOperation的使用及理解 NSOperationQueue的使用 三面题目 算法题：仅包含三种元素的数组排序，要求时间复杂度O(n) Objective-C程序的编译和链接过程理解 内存管理相关操作（ARC、MRC等） 响应链原理 hitTest方法是否尝试过重写，重写的场景和注意点 HTTP、Session和Cookie的区别和联系 线程和队列的关系 CALayer与UIView的关系和区别 总结字节跳动的iOS面试涵盖了语言基础、架构设计、网络、多线程、算法以及系统底层机制，难度较高，注重应试者对核心概念的理解和实际编码能力。建议结合项目经验，系统复习基础知识和算法，熟悉面试中常见的设计题和编程题，提升解决问题的思路和表达能力。 推荐复习资料： 《Objective-C高级编程》 《iOS开发者面试宝典》 LeetCode经典算法题库 Apple官方文档关于Runtime和内存管理章节 祝你面试顺利，成功拿到Offer！","link":"/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"},{"title":"教你炒股票1：不会赢钱的经济人，只是废人！","text":"“教你炒股票”这样的题目，全中国不会有第二人比本ID更适合写的。当然，股票是炒出来的，不是写出来的，因此也从未想过写这样的题目。 但任何事情都是有缘起的，缘分到了，也不妨写上一写。 人，总是很奇怪的，就算是很聪明的人，或者在其他行业很成功的人，一旦进入资本市场，就像换了人。虚拟和现实的鸿沟使得干实业的， 且不说期货了，就算到风险小的多的股市，也很少能干好的。而习惯在虚拟市场玩游戏的，基本很难回头去弄实业，这些例子都太多了。 周围朋友和经济有关的，干金融的比较多，也有几个干实业的。去年人民币放开后，有次和他们一起玩，偶然聊起股票。 当时给他们的意见是，由于资源的全球化升势及人民币的升值，国内实业将有很大的困难，而虚拟市场由于对资本的吸纳作用将大有改观， 会出现一个至少是大X浪级别的行情，劝他们应该分流部分资金到资本市场来。由于前几年资本市场上出事的人一拨接一拨，这帮家伙很犹豫，一晃就把时间过了。 今年，过完春节，这帮家伙突然开始不断骚扰本ID，说要入市。本ID当时已经忙得无暇分身，对他们一番数落，然后告诉他们， 现在是个人都能挣钱，自己玩去，没空理你们。进入三、四月份，当时有色等行情已经很火暴，这帮家伙想大进又怕风险，一直在小打小闹。 有一天，又在一起玩，他们一定要本ID选择一些具体的股票。因为这两年一直有很多外资大基金进来接触要收中国快速消费品的企业， 还有就是一些大的周期行业将面临重组，就让他们去关注这两类股票和权证。 五月份后，股市大涨，大家都很忙，中旬时又有机会碰头，一问之下，基本都没怎么大买，买了的也没几个站就下车了。他们都显得很烦躁， 不断问有什么可买的。既有点可怜又有点烦他们，怎么在市场外弄得好好的，一到市场里都成这样了？就有点敷衍地告诉他们， 去买深沪两地3元上下的本地股，而且告诉他们，这样下去肯定要出问题的，最好自己好好学学，别人怎么厉害也不可能整天像照顾小孩一样看着。 上周日，又碰在一起。这几位，大概都一肚子股票了，这次个个神采飞扬；大概又都刨了几本书，听了几股评，看了几杂志，更是口水喷喷地这面那面、 一线二线地专家了，1800、2000、2500点地牛人了。这市场，还真能改造人！只是这市场的绞肉机，又有新货了。 有人说，市场是老人挣新人的钱，而市场中的老人，套个10年8年的一抓一大把。其实，市场从来都是明白人挣糊涂人的钱。 在市场经济中，只要你参与到经济中来，就是经济人了，经济人当然就以挣钱为目的，特别在资本市场中，没有慈善家，只有赢家和输家。 而不会赢钱的经济人，只是废人！无论你在其他方面如何成功，到了市场里，赢输就是唯一标准，除此之外，都是废话。","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A81%EF%BC%9A%E4%B8%8D%E4%BC%9A%E8%B5%A2%E9%92%B1%E7%9A%84%E7%BB%8F%E6%B5%8E%E4%BA%BA%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%BA%9F%E4%BA%BA%EF%BC%81/"},{"title":"教你炒股票10：2005年6月，本ID为何时隔四年后重看股票","text":"2001年6月后，本ID就从未看过股票，直到2005年6月。本ID是严重反对人民币升值的， 曾写有“货币战争和人民币战略”在网上广泛流传。但到2005年6月，本ID知道有些事情不是人力可为的， 天要下雨、娘要嫁人，LET IT BE吧。所以2005年6月，本ID时隔四年后重看股票。 在强国论坛的人都知道，2005年6月最暴跌时，本ID连续三次罕有地表扬一个政府官员， 就是股市当时的新人、如今那位著名的山东人。 其后还专门写文章为他说股改“开弓没有回头箭”而热烈鼓掌。 同时，本ID却曾写过这样的文章“群狼争肉—-国有股流通与国有资产蚕食、瓜分游戏！”。 这，难道是本ID逻辑混乱、前后矛盾吗？ 非也，这就是昨天本ID所解释的〈论语〉里“子曰：众，恶之，必察焉；众，好之，必察焉”的完美应用。 确实，从好恶角度，本ID严重反对人民币升值、反对国有股流通， 而且深刻地分析了这些玩意后面的现实逻辑关系和严重后果。但在股市里，本ID从来没有好恶。 只要有点金融常识的人都知道，本币的历史性升值所带来历史性牛市曾被太多国家所经历。 本ID只知道，一旦人民币升值、国有股流通，股市将大涨。知识分子为什么可笑，就是有好恶而无“察”， 企图以理论来理论现实，十足脑子水太多了。 书呆子是不适宜投资市场的，错了，应该是投机市场。别相信这世上有什么投资市场， 世界本身都是投机的，还有什么资可投？就像有人号称所谓爱情，而所有的爱情， 都不过是遮掩性游戏谎言的一条内裤而已。所有的性游戏都可以用这样的数学表达式表示：4N9。 N代表从0到无穷的自然数，0等于没搞上，无穷等于天长地久也就是废话，1等于一夜情419， 所有的性游戏包括爱情，都被这样一个数学表达式表示了。那么，任何一个投资者和股票的性关系， 也完全可以以此表示。任何股票和你，都不过是一个4N9的关系，可以投机的就是这个N， 如果你能在这个N里把一只股票当面首一样采尽他的精气，那你就是高手了。其后再换一个继续N2的游戏， 如果该游戏可以新戏不断，而你又能采之而不被采，那你就是高手中的高手了。 世界就那么简单，别把自己搞糊涂了。 股票，恶之，必察焉；股票，好之，必察焉。由孔子的话，不难明白以上的道理，而明白这道理， 就明白投机市场第一原则“只搞能搞的”所依。智慧都是相通的，“只搞能搞的”，而不是“只搞喜欢的”。 能搞是需要“察”而得之，不是靠喜好厌恶而来的。随便在市场里抓一个人，问他为什么买手里的股票， 一万个人有9999个告诉你因为他的股票如何如何好，这种人能在市场上长久活下来就世界最大奇迹了。 本ID从来不觉得自己手里的股票有什么好，只知道他们能搞。 但几乎所有的人，包括庄家、散户，都喜欢为自己股票的好找理由。别以为庄家就不这样， 庄家里的傻人从来不比散户少，本ID见多了。这些人，拿了股票就到处找理由为其持有、上涨编故事， 就算股票已经从10跌到1了，还乐此不疲。市场里所有亏损，都是因为持有了不能搞的股票而造成的。 但无论任何股票，能搞总是相对的，不能搞却是绝对的，就像4N9里，如果你为了某面首把N设成无穷， 那么劝你自杀吧，因为你活也白活了，你已经不是人，而是某面首的附属物。 N只能有限地给予一个固定的能搞对象，有N1，就要有N2，这样才能生生不息，才能风生水起。 但在4N9任意一段N中，这面首、这股票就是你的全部，你要全身心地投入去“察”去“采”，投机市场， 机会总是一闪而过，别到白天才问夜的黑，那什么菜都凉了。能搞是相对的， 意味着随时能搞就会变成不能搞。一旦这“机”失去了，就会在不能搞的泥潭难以自拔。 无论对面首或股票，都要全身心地往死里干然后抛弃，这是不能偏废的两方面， 任何的失败者都一定是至少在其中一面失败了。 在4N9的任何一段N中，可以有世界上最浪漫的故事、最火热的缠绵，有无数的细节， 从前戏到缠绵到进入到高潮到不应到抛弃，所有的故事只是唯一的故事， 就像所有的AV都只有同一的情节。从下一期开始，我们将仔细分析同一AV情节的每一个细节， 让每一细节深入你心，成为本能的反应，然后才能成为AV主角，在每一段4N9中高潮迭起，采阳不休。","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A810%EF%BC%9A2005%E5%B9%B46%E6%9C%88%EF%BC%8C%E6%9C%ACID%E4%B8%BA%E4%BD%95%E6%97%B6%E9%9A%94%E5%9B%9B%E5%B9%B4%E5%90%8E%E9%87%8D%E7%9C%8B%E8%82%A1%E7%A5%A8/"},{"title":"教你炒股票3：你的喜好，你的死亡陷阱！","text":"要世界杯了，在世界杯时谈论股票是一件很无趣的事情，而且，全世界的人都知道， 世界杯前后，股票市场几乎都要大跌，这个常识，虽然并不比所有有关所谓庄家的常识更值得常识， 但至少有趣，并不像所谓庄家一般无聊。还可以增加一句的是，足球至少有帅男， 而见过的如此之多的所谓庄家里，连长得不那么歪瓜裂枣的都少，这的确是实际情况，并不是开玩笑。 但你的喜好，就是你的死亡陷阱！在市场中要生存，第一条就是在市场中要杜绝一切喜好。 市场的诱惑，永远就是通过你的喜好而陷你于死亡。市场中需要的是露水之缘而不是比翼之情， 天长地久之类的东西和市场无关。市场中唯一值得天长地久的就是赢钱，任何一个来市场的人， 其目的就是赢钱，任何与赢钱无关的都是废话。必须明白，任何让你买入一只股票的理由， 并不是因为这股票如何好或被忽悠得如何好，只是你企图通过买入而赢钱，能赢钱的股票就是好的， 否则都是废话。因此，市场中的任何喜好，都是把你引入迷途的陷阱，必须逐一看破， 进而洗心革面，才能在市场上生存。 当然，能看清楚自己周围的市场陷阱，还只是第一步，更进一步，要学会利用市场陷阱来赢钱。 当你要买的时候，空头的陷阱就是你的最佳机会，当你要卖的时候，多头的陷阱当然就是你的天堂。 这市场，永远不缺卖在最低点，买在最高点的人，这世界上没有什么是可以让所有人赢钱的， 连大牛市中都有很多人要亏损累累。而市场中的行为，就如同一个修炼上乘武功的过程， 最终能否成功，还是要落实到每个人的智慧、秉性、天赋、勤奋上来！","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A83%EF%BC%9A%E4%BD%A0%E7%9A%84%E5%96%9C%E5%A5%BD%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%AD%BB%E4%BA%A1%E9%99%B7%E9%98%B1%EF%BC%81/"},{"title":"教你炒股票4：什么是理性？今早买N中工就是理性！","text":"很奇怪，在资本市场中经常有人在教导别人要理性。而所有理性模式后面， 都毫无例外地对应着一套价值系统为依据，企图通过这所谓的依据而战胜市场， 就是所有这些依据最大的心理依据，而这，就是所有资本谎言和神话的基础。 真正的理性就是要去看破各色各样的理性谎言，理性从来都是人YY出来的皇帝新衣， 这在哲学层面已不是什么新鲜的事情。 更可笑的是，被所谓理性毒害的人们，更经常地把理性当成一种文字游戏，当文字货币化以后， 这种文字游戏就以一种更无耻的方式展开了。但真正的理性从来都是当下的，从来都是实践的， 而实践，从来都是当下的理性。就像性是干出来的而不是说出来的，理性也一样。 站在资本市场的角度，就是所有的介入都是可介入从而被介入地介入着。 也就是所有的介入，当你介入时，市场与你就一体了，你创造着市场，从而市场也创造着你， 而这种创造都是当下的，从而也是模式化的。真正的理性关心的不是介入的具体模式如何， 而是这种模式如何被当下着，最重要的是，这种模式如何死去。 生的，总要死去，如果自然真有什么法则，这就是唯一的法则，市场上的法则也一样。 所谓法则，就是宿命。在市场中，死亡是常态，也是必然，而生存，必须以生为依据， 所谓生生不息，其实就是死死不息，当你被依据所依据时，其实已在死亡之中。 而生死，从来都是被当下所模式，资本市场也一样，以为离了生死也就无生死可了， 这不过是所谓理性的妄想。任何市场中人，都是被生死了的，生死无处可离， 生死就在呼吸之间，不离生死而从容于生死，没有这种大勇猛， 一切的理性都不过垂死的哀鸣。对于市场来说，介入就是介入生死， 无所依据地从容于各种模式之间，无所往而生其心，而心实无所生，方可于生死而从容。 对于市场的参与者来说，首要且时刻必须清楚自己目前介入模式的当下， 而市场中的绝大多数人，是不知道自己在干什么的，狠一点说， 就是死都不知道怎么死就死了，市场基本由这种人构成。这种构成与资金实力无关， 大资金死起来更快，一夜之间土崩瓦解的事情，本ID见得多了。此外， 如果你一定要很习惯地、理性地追问什么是理性，那么，相对那些光说不干的所谓理性， 今早15元多买N中工就是理性！理性是干出来的，今天，你干了吗？","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A84%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%90%86%E6%80%A7%EF%BC%9F%E4%BB%8A%E6%97%A9%E4%B9%B0N%E4%B8%AD%E5%B7%A5%E5%B0%B1%E6%98%AF%E7%90%86%E6%80%A7%EF%BC%81/"},{"title":"教你炒股票5：市场无须分析，只要看和干！","text":"喜欢吹牛皮的，在市场里最常见，例如一种以分析市场、吹牛皮为生的职业，叫什么股评、专家的。 此类人不过是市场上的寄生虫，真正的猎手只会观察、操作，用嘴是打不了豺狼的。 市场就是一个狩猎场，首先你要成为一个好猎手，而一个猎手，首先要习惯于无言。 如果真有什么真理，那真理也是无言的。可言说的，都不过是人类思想的分泌物，臭气熏天。 真不可言说了，就无不可言，言而无言，是乃真言。 一个好的猎手，可以没有嘴巴，但一定会有一双不为外物所动的眼睛，在这眼睛下， 一切如幻化般透明。要不被外物所动，则首先要不被自我所迷惑，其实无所谓外物、自我， 都不过幻化空花，如此，方可从容其中。 猎手只关心猎物，猎物不是分析而得的。猎物不是你所想到的，而是你看到的。相信你的眼睛， 不要相信你的脑筋，更不要让你的脑筋动了你的眼睛。被脑筋所动的眼睛充满了成见， 而所有的成见都不过对应着把你引向那最终陷阱的诱饵。猎手并不畏惧陷阱， 猎手只是看着猎物不断地、以不同方式却共同结果地掉入各类陷阱，这里无所谓分析， 只是看和干！ 猎手的好坏不是基于其能说出多少道道来，而是其置于其地的直觉。好的猎手不看而看， 心物相通。如果不明白这一点，最简单就是把你一个人扔到深山里，只要你能活着出来， 就大概能知道一点了。如果觉得这有点残忍，那就到市场中来，这里有无数的虎豹豺狼， 用你的眼睛去看，用你的心去感受，而不是用你的耳朵去听流言蜚语，用你的脑筋去抽筋！","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A85%EF%BC%9A%E5%B8%82%E5%9C%BA%E6%97%A0%E9%A1%BB%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%AA%E8%A6%81%E7%9C%8B%E5%92%8C%E5%B9%B2%EF%BC%81/"},{"title":"教你炒股票2：没有庄家，有的只是赢家和输家！","text":"庄家这种动物对大多数人来说很神秘，对本ID来说就太稀松平常了。庄家和散户这种二元对立，大概比较适合现代中国人的思维模式， 因此就变得如此的常识，但常识往往就是共同谬误的同义词，不仅是所谓的散户，而且很多的所谓庄家，也就牺牲其中。 一般定义中的所谓庄家，就是那些拿着大量资金，能控制股票走势的人。在有关庄家的神话中，庄家被描述成无所不能的， 既能超越技术指标、更能超越基本面，大势大盘就更不在话下了。这里说的还只是个股的庄家，至于国家级的庄家，更成了所谓散户的上帝。 关于这些庄家上帝的传闻在市场中一秒钟都不曾消停，构成了常识的谬误流播。 但所谓的庄家，前赴后继，尸骨早堆成了山。前几天在一个私人聚会里，还碰到一个50年代的老大叔，说已经准备了二十亿， 要坐庄，让本ID去联系一下某某公司的头。那人也是有头有脸的人了，不想当众奚落他，暗地里把他嘲笑了一番，简直是脑子锈着了。 当然，即使庄家的神话已经如此常识，这种傻人还是一直、也会继续前赴后继的。而正因为这种傻人如此的多，猎人打起猎来才能收获丰富。 看到越摆庄家谱的，猎人就越高兴，反正这类型的，基本在市场上混个几年就基本尸骨无存了。 市场没有什么庄家，有的只是赢家和输家！有的只是各种类型的动物，还有极少数的高明猎手。市场就是一个围猎的游戏， 当你只有一把小弓箭，你可以去打野兔；当你有了屠龙刀，抓几条蛇来玩当然就没劲了，关键你是否有屠龙刀！","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A82%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%BA%84%E5%AE%B6%EF%BC%8C%E6%9C%89%E7%9A%84%E5%8F%AA%E6%98%AF%E8%B5%A2%E5%AE%B6%E5%92%8C%E8%BE%93%E5%AE%B6%EF%BC%81/"},{"title":"教你炒股票6：本ID如何在五粮液、包钢权证上提款的！","text":"最近忙着和孔二爷闹，满博客都是孔二爷，前两天耍了一下鲁超女活跃一下气氛， 今天想继续说说这“教你炒股票”系列。总不能整天都是孔二爷，也要照顾一下孔方兄， 都是姓孔的，一碗水要端平。 股票上永远不缺英雄，更永远不缺死去的英雄，最近的英雄们都又在吹投资， 但投资这内裤永远掩盖不了股票扒光后赤裸裸的投机。阴符云：“天性，人也；人心， 机也；立天之道以定人也。天发杀机，斗转星移；地发杀机，龙蛇起陆；人发杀机， 天地反覆；天人合发，万化定基。”不投这个机，又如何夺天地之造化？ 股票市场也是一样的。 对于本ID来说，这股票市场就如同提款机，时机到了，就去提款，时机不到， 就让他搁在那。市场就如同男人，整天管他就会犯贱，就会咬你。 所以男人不能经常搞，这市场也一样，必须耐心等待他的骚动，他不骚动，是不能搞的。 本ID曾写帖子“G股是G点，大牛不用套！”，连G点都不明白，是没资格谈论股票的。 如同要找到男人的G点，就要对这男人充分了解，要找到这市场的G点，其道理是一样的。 但就像光知道男人有G点还是不能乱搞，首先要了解他是干净的，是安全的， 否则高潮还没有就翘了，那不麻烦大了？这市场也是一样的，不是什么机会、 G点都要搞的，首先的前提要安全，要像去银行提款一样安全。 就像又有G点又干净的男人才值得搞，市场上也只有这样又安全又能G点的机会， 才值得投机。 就像四月份时本ID在五粮液、包钢认购权证上的布局。为什么选择他们而不是其他， 道理很简单，因为他们既有认购又有认沽，而对于企业来说，除非行情特别不好， 否则是不会让认沽兑现的，因为不兑现，这就是一个空头支票， 而兑现是要掏真金白银的。因此，对既有认购又有认沽的认购权证来说， 认沽和认购的行权价之间的差价，就是认购权证最安全的底线。对于五粮液、 包钢认购权证，这个底线就分别是1.02和0.43元。 而本ID当时分别在1元多和4毛多吃他们，是不是和去银行提款一样安全？ 唯一遗憾的是，他们的盘子都太小，属于小男人的类型，容纳不了太大的资金。 小男人，没什么劲；小盘的股票，也一样。 投机不是瞎搞，是要清清楚楚地搞。要清清楚楚，就要对市场充分地理解， 要明白其道道。本ID曾发明了一个口号在私下流传，就是“像搞男人一样搞股票， 像做爱一样做股票。”不明白这，没资格谈论股票。关于这个话题， 今天就到这，有时间、有心情，继续。","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A86%EF%BC%9A%E6%9C%ACID%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%94%E7%B2%AE%E6%B6%B2%E3%80%81%E5%8C%85%E9%92%A2%E6%9D%83%E8%AF%81%E4%B8%8A%E6%8F%90%E6%AC%BE%E7%9A%84%EF%BC%81/"},{"title":"教你炒股票8：投资如选面首，G点为中心，拒绝ED男！","text":"中国人喜欢说反话，面首，“面”，绝不是首位的。选面首，先看面，终要看“里子”。何谓“里子”？就是“G点为中心，拒绝ED男！” 这也是本ID关于投资的警世之言。拿投资来忽悠的人，总爱编一些关于“面”的神话。诸如基本面、技术面、心理面、资金面， 这面那面，都如同面首之“面”，不过是进而“里子”的借口。没有“G点为中心，拒绝ED男！”的“里子”，这面那面又有何意义？ 投资的结果很简单，就“输、赢”两种。所有关于投资的理论把戏，都企图通过控制某种“输入”而把“输”这结果给去了。 因此一切相关的理论前提就必然建立在这样一个逻辑假设之上：输入与输出间被某种必然的逻辑关系和因果链条所连接。 而该逻辑假设，相当于说“面首的面和其里子有着必然的逻辑关系。”如果这都能成立，那么帅男就一定G点澎湃、 满面胡子的糙爷就一定非ED男，出去扒几个面首看看这类假设是何等荒谬。然而，现实中，企图跳过“面”而直捣“里子”， 同样是一种荒谬的幻想。即使“面”和“里子”没有任何必然的联系，但现实依然只能从“面”到“里子”。那种企图否定一切“面”的， 企图直接就“里子”就G点的，不过是把某种“面”当“里子”了。这种人，终生被骗而不知，就像把“叫床分贝”当高潮指标一样可笑。 投资领域，没有任何理论可以描述这种从“面”的输入到“里子”输出的必然关系，因为这种关系根本不存在。 但人只要介入这种投资游戏，其介入就必然要以某种方式进行，相应地，其后必然有着某种理论、信念的基础。 而正因为绝对正确的不存在，因此反而使得各种理论、信念基础之间有了比较的可能。任何好的投资理论，最终都只面向“里子”， 就如同一个好面首，必须最终以其G点的澎湃度来证明其优秀。相应的，投资市场最重要的指标就是高潮度， 一个长期没有高潮的市场，就如同没有G点的石男，是不值得任何关注的。期待一个石男变成一个优秀的面首，那是牧师的工作， 而投资市场不需要牧师。一个市场能进入可投资的视界，首先要显示其G点的萌动，否则还是一边凉快去吧。 世界，永远不缺G点萌动的男人去面首，同样，在世界总的市场体系中，永远不缺高潮萌动的市场。但大多数的散户， 就喜欢泡石男，以为石男没有攻击性就安全了，以为长期没有高潮的市场就一定安全。有多少人因此而独守空房、耗费青春， 整天听着看着别人高潮不断，最终寂寞难耐，走向另一个极端，见高潮就扑上去，如飞蛾一样死掉。 本ID曾言“像搞男人一样搞股票，像做爱一样做股票”。搞男人、做爱，最终都是要获得其高潮，最终采阳而补。投资也一样， 通过市场的高潮是要赚取其利润，是采利而补。可惜，市场上的人，大多数都让人当阳给采了，可笑可怜。要采阳而不要被采， 这就是和面首游戏的第一准则，而投资市场的道理也是一样的。 采阳，过熟不行，过生也不行，必须把握其火候。阳生，必有其萌动，必须待其萌动之后才可介入。具体对于股票来说， 按其是否萌动的标准把所有股票动态地进行分类，一种是可以搞的，一种是不能搞的，将你参与的股票限制在能搞的范围内， 不管任何情况，这是必须遵守的原则。当然，搞的分类原则，各人可以有所不同。 例如，250天线以及周线上的成交量压力线的突破；资金量不大且短线技术还可以的，可以把250天线改成70天线、35天线， 甚至改为30分钟图里的相应均线；对新股，可以用上市第一日的最高价作为标准；还有，就是接近安全线的股票， 例如在第六期里，本ID给出的一个带认沽权怔的认购权怔介入的安全线标准；而对于有一定水平的人，识别各种空头陷阱， 利用空头陷阱介入是一个很好的方法，这种方法比较专业点，以后专门说。 男人只有两种，能搞的和不能搞的；市场也只有两种，能搞的和不能搞的。必须坚持的是， 不能搞的就无论发生什么情况都不能搞，除非能达到某种能搞的标准而自动成为能搞的对象，就像用ED把男人进行分类一样， ED男只有非ED后才有进入被搞侯选集合的可能。一旦被搞的分类原则确定，就一定要严格遵守“只搞能搞的”原则。 可惜，这样一个简单的原则，绝大多数的人即使知道也不能遵守。人的贪婪使得人有一种企图占有所有机会的冲动， 就如同看到街上的所有男人都企图上去扒光他们一样，这种人叫“花痴”，“花痴”在投资市场的命运一定是悲惨的。 在投资市场，定好“能搞”的“G点萌动”标准，相应选出来的，至少不是ED男了。而接下来，就要防止其“早泄”。 这里找到有关“早泄”的医学定义：男子性功能障碍中仅次于阳痿的最常见的症状，是射精障碍中最常见的疾病， 发病率占成人男性的35%一50%。投资市场里，这“早泄”的比例和市场总体强度有关，在熊市中这比例至少是80%以上， 而牛市中这个比例就小多了，大概就30%。无论是选一个好面首还是一个好股票， 把“早泄”的一类给筛出去可是最重要也是最困难的一步，很多所谓的高手，就死在这一步上。 关于这问题，将在下一讲中详细论述。","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A88%EF%BC%9A%E6%8A%95%E8%B5%84%E5%A6%82%E9%80%89%E9%9D%A2%E9%A6%96%EF%BC%8CG%E7%82%B9%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%8C%E6%8B%92%E7%BB%9DED%E7%94%B7%EF%BC%81/"},{"title":"教你炒股票7：给赚了指数亏了钱的一些忠告","text":"今天不宠幸孔二爷了，宠幸一下股票。早就说过，中国没有人有资格和本ID谈论股票。 国庆前，香港有几个大的基金经理过来，吃饭时让本ID给修理了一通，屁颠屁颠回去了。 本ID和他们说了大的国际经济趋势以及大中国区的金融前景还有内地的政治经济形势，坚定他们的信心， 他们主要是对内地的情况不了解，所以有所狐疑。最近这伙人干得不错，在市场里，干就往死里干， 不干白不干。把锅炒热了才有好菜吃，这道理不很简单？ 但这几个月还是有点烦，就是整天给一大叔骚扰。他钱不多，也就千万级别的资金规模， 这种人本ID从不搭理，但这大叔有点特殊，有些渊源，人家年纪又这么大，40好几了， 怎么都给点面子。但有时候，真想踹他两脚。4月份，本ID布局权证时，他就不敢买， 后来权证疯了，他就后悔。然后告诉他，年纪大了就不要玩太高风险的，买银行股吧， 民生，4块钱附近买了就搁着，结果赚了几毛钱就跑，真没出息。最可气的是， 国航跌破发行价时告诉他去买，他自己也当过兵，特别提醒他国航的李总当兵出身的， 怎么可能让自己的股票跌破发行价这么没面子？这大叔犹犹豫豫，N天时间也就买了点， 长起来几毛钱又走了。最近，让他在3元多吸纳北辰实业，4块不到就跑了，本ID简直对他彻底绝望。 不过他还算好，有部分钱在年初3、4块买了一只自己十分熟悉的北京股票，现在已经10块了， 但这大叔最麻烦的是，上下一波动就紧张，就打电话来骚扰本ID，本ID教他怎么在箱型盘整时弄短差， 这大叔，涨的时候不敢卖，跌的时候不敢买，本ID真服了他。 之所以说这，因为这种情况在散户中太常见。散户就如浮萍，没根，没主意，这样不给屠杀才怪了。 大概最近比这大叔更惨的，赚了指数亏了钱的也不在少数，本ID也废话一下，让有缘者得之。 去年破1000点前，本ID曾写“G股是G点”，今天5月刚突破后，本ID又写“大牛不用套！”， 但为什么有人竟然可以不挣钱？最主要是对牛市没信心，对牛市的节奏没把握。5月份前有色等的上涨， 不过是牛市的预热阶段，而目前以金融股等为代表的指数股上涨，是牛市的第一阶段。96年的时候， 深发展长了N倍了，很多股票还没怎么动。牛市的第一阶段都是这样的，一线股先长，它们不到位， 其他股票怎么长？全世界的牛市都基本这样子，没什么新鲜的。 错过了这个节奏怎么办？如果你跟盘技术还行的，就要在回档的时候跟进强势股票。散户就怕跌， 但牛市里，跌就是爹，一跌就等于爹来了，又要发钱了。如果跟盘技术不行，有一种方式是最简单的， 就是盯着所有放量突破上市首日最高价的新股以及放量突破年线然后缩量回调年线的老股， 这都是以后的黑马。特别那些年线走平后向上出现拐点的股票，一定要看好了。 至于还在年线下面的股票，先别看了，等他们上年线再说。其实， 这就是在牛市中最简单可靠的找所谓牛股的方法。举一个例子，去看看宝钢，突破年线后缩量回调， 10月23日回调4.20元，当时年线就在4.17元，然后再放量启动，今天，11月16日，已经6元多了， 50%就这么完成了。从年线上启动，先长个50%，不像玩一样？本ID一般只看大盘股票，小盘股没法进去， 但散户可以看小盘股，原则是一样的，不过小盘股可要留意，一般大盘股启动的骗线比较少， 小盘股可不一定，这都要自己好好去揣摩。散户就当好散户，别整天想着抄底、逃顶，底都让你抄了， 顶都让你逃了，不是散户的人吃什么去呀？散户，一定要等趋势明确才介入或退出，这样会少走很多弯路。 一只股票长起来千万别随意抛了，中线如果连三十天线都没跌破，证明走势很强，就要拿着。 当然，如果你水平高一点，在上涨的时候，根据短线指标可以打短差，这样可以增加资金的利用率， 但高位抛掉的，只要中线图形没走坏，回挡时一定要买回来，特别那些没出现加速的股票。 有一个抛股票的原则，分两种情况，一种是缓慢推升的，一旦出现加速上涨，就要时刻注意出货的机会； 另一种是第一波就火暴上涨，调整后第二波的上涨一旦出现背弛或放巨量的，一定要小心，找机会走人。 具体的操作是一个火候的问题，必须自己用心去体会，就像煲汤，火候的问题是没法教的， 只能自己在实践中体会。还有，对抛弃的股票一定不能有感情，股票就像男人， 玩过就扔，千万别有感情。 还有一点必须提醒，在牛市中，一定要严重关注成分股，特别有一定资金规模的，成分股都是大部队在战斗， 别整天跟那些散兵游勇玩，那些人自己都自身难保，本ID看这种所谓游资被消灭的都看到麻木了， 大资金就爱吃他们，几个亿几个亿吃他们，这才有点意思，否则吃小散户的几万几千，累不累呀？ 牛市中，最终所有股票都会有表现的机会，只是掌握了节奏，资金的利用率就高，一个牛市下来， 挣的钱如果不超出指数最终涨幅的几倍，指数长一倍，不挣个4、5倍，那就算废物点心了。 要达到这种水平，其实很简单，就一个原则：避开大的回挡，借回挡踏准轮动节奏。 千万别相信什么基本面的忽悠，特别对于散户来说，最多也就一亿几千万的钱，有必要研究什么基本面吗？ 所谓基本面，只是一个由头，给自己壮胆和忽悠别人用的。对基本面， 只要知道别人心目中的基本面以及相应的影响就可以了，自己千万别信。 本ID还是那句话，玩资本主义的游戏就要用资本主义的原则，既然玩股票了，就要心狠手辣， 市场从来不同情失败者，市场不需要焚尸炉，失败者的尸体在市场中连影子、味道都不会留下。 别给自己的失败找任何理由，失败只能是你自己的失败，失败就找机会扳回来， 但前提是必须找到失败的真正原因，否则不过是延续不同的情节、相同的悲剧。 希望来本博客的人，除了学《论语》、听音乐、看文章，还都能学会挣钱。 这个世界上最无耻下流的就是不会挣钱的人，你说钱是孙子，而你连孙子都搞不掂，那你最多就是龟孙子， 有什么资格说话？有钱不是大爷，没钱更不是大爷。在市场挣钱就如同打仗，九死一生，而最终能活着的， 就是牛人，牛人就要牛，这又有什么可说的？","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A87%EF%BC%9A%E7%BB%99%E8%B5%9A%E4%BA%86%E6%8C%87%E6%95%B0%E4%BA%8F%E4%BA%86%E9%92%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%A0%E5%91%8A/"},{"title":"百度 iOS 面试真题总结（含一二三面深度解析）","text":"本文记录了百度 iOS 岗位的三轮面试经历，涵盖 iOS 基础、UI 响应链、内存管理、多线程、源码阅读、OpenGL 渲染、跨语言知识（如 Python &amp; JVM）等内容，适合希望进入百度等大厂的 iOS 工程师参考。 百度一面：基础知识 + 跨平台能力1. iOS 基础知识点涉及 UIViewController 生命周期、视图加载时机、UI 响应链、图片加载、图标内存大小估算等。 2. Python 基础知识考察线程安全、多线程与集合类、类继承、JVM 基础等跨平台知识点，体现广度能力。 3. iOS 源码阅读经验面试官关注是否阅读过 AFNetworking、YYModel、Masonry 等三方库源码，建议提前准备一两处代码逻辑作为回答素材。 4. OpenGL &amp; GLSurfaceView 基础图形绘制流程，包括 Shader 编程、FrameBuffer 配置、OpenGL 渲染管线的调用流程。 5. 项目优化实践主要围绕你负责的模块、性能优化方法（如卡顿检测、图片内存优化）、Crash 分析与修复方案等展开。 6. 多进程通信机制提到 Android 的 Binder/AIDL 机制，如果你有了解，也是体现技术深度和广度的加分项。 百度二面：深入理解 iOS 原理1. Delegate、Notification 和 KVO 对比 KVO：适合属性观察，自动触发，容易产生内存泄漏； Notification：解耦强，适合广播型通信； Delegate：一对一，强类型，结构清晰。 2. UI 中心视图实现方式考察 AutoLayout（约束）、frame 手动设置、居中布局等方法的灵活掌握。 3. 触摸事件响应机制 事件传递路径：UIApplication → UIWindow → ViewController → View； FirstResponder 的确定； UIResponder 链关系。 4. UIViewController 生命周期问题重点考察 loadView、viewDidLoad 的调用时机，以及仅 alloc 未使用的 VC 是否触发视图加载。 5. UILabel vs drawRect 性能比较系统控件（UILabel）通常自带优化；自绘方式性能高但复杂，适用于高度定制需求。 6. AFNetworking 是否支持 IPv6？考察是否了解苹果对 App 上架网络兼容性的要求，AF 在 iOS9+ 使用 NSURLSession 支持 IPv6。 7. 64 位架构与 i386 区别 i386 是 32 位模拟器架构； x86_64 是 64 位； arm64 是真机架构； 64 位系统提供更大的寻址空间、更高性能。 8. iOS 应用状态及后台执行iOS 应用状态包括：Not running、Inactive、Active、Background、Suspended。退到后台时可使用任务保持短时间执行。 9. 图片内存计算例如 200×300 RGBA 图片：200 × 300 × 4 = 240000 bytes ≈ 234KB。 10. Block 内存泄漏问题Block 默认强引用外部变量（如 self），容易造成 retain cycle，需使用 __weak 或 __block。 11. [object copy] 是浅拷贝还是深拷贝？多数情况下是浅拷贝，除非手动实现 copyWithZone: 方法。需遵循 NSCopying 协议。 12. Images.xcassets 的优势支持 @2x/@3x 自动加载、内存优化、打包统一管理等，推荐使用。 百度三面：底层机制 + 架构理解这一面偏重对核心知识点的深度理解，问题极其细致。 1. 内存管理原理涉及 ARC 自动引用计数、弱引用释放机制、AutoreleasePool 生命周期等。 2. 多线程基础了解 GCD、NSOperationQueue 的实现与使用场景。 3. 队列与线程模型主队列、串行/并发队列、栅栏函数、线程同步策略的优劣。 4. 线程锁机制 @synchronized：简单但性能差； NSLock、NSRecursiveLock、dispatch_semaphore、pthread_mutex 的应用场景； 死锁成因及避免方式。 5. MVVM 架构设计数据与视图的解耦思维、数据绑定技术（如 KVO、RAC）、MVVM 和 MVC 的取舍。 面试总结 &amp; 准备建议百度的 iOS 面试难度不低，知识广度 + 深度要求都较高。涵盖了语言底层、UI 响应机制、网络、多线程、内存优化、架构设计等多个维度。 🎯 推荐重点准备方向： Objective-C Runtime、KVO 实现、消息转发机制 ARC 内存管理 + Retain Cycle 处理策略 多线程并发处理（GCD、锁机制） 网络栈基本流程、IPv6 支持 自定义 UI 控件、性能优化 架构能力（MVC/MVVM、组件化） 💡 希望这篇《百度 iOS 面试真题总结》对你有所帮助！如果你正在准备大厂面试，不妨将这些问题整理成知识图谱，逐个击破，祝你早日拿到满意 offer 🚀","link":"/%E7%99%BE%E5%BA%A6-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"教你炒股票9：甄别“早泄”男的数学原则！","text":"设计一个程序，将所有投资对象进行分类，只搞那些能搞的，这是投资的第一原则。在分类中， 所应用的程序可以各色各样，但有一点是肯定的， 即没有任何一个程序可以使得所选能搞的最终都百分百能被搞得高潮迭起， 就像没有任何一个挑选面首的程序使得所选能搞的最终都能百分百被搞得高潮迭起。 因为任何操作程序都必然面对“早泄”问题，就像任何关于面首的选择都必然面临“早泄”男的甄别问题。 而甄别“早泄”之所以困难重重，使得无数所谓高手死无葬身之地， 是因为“早泄”这事还真得真刀真枪地实干才能发现，这比ED的甄别可复杂多了、风险大多了。 ED，不需要深入介入就可趁早发现，但“早泄”不可以，怎么都要试上一试，而这玩意是一锤子的买卖， 这次行还不能保证下次就一定行，因此要有效甄别、及早发现而减少损失就成了一个头号难题。 许多所谓高手会宣称，出现什么情况，这股票就会长。但实际上，任何一种情况， 都有着极高百分比的可能会出现“早泄”，确定能搞的突然就变成不能搞了，使得介入变成了套牢。 这种情况，在投资里简直太常见了。 那么，如何甄别“早泄”男？首要的就是严格的资金管理，一旦出现“早泄”现象，必须马上退出， 即使下面突然又不“早泄”了，又强力高潮了，也必须这样干。而且“早泄”特敏感， 一个偶尔的因素就可能导致，而要重新再来，还要等待一个长的不应期，一个长的调整过后， 即使会高潮不断，也浪费了时间，有这时间，可搞的东西多了去了，这世界又不只有一个面首、 一只股票。当然，这里说的只是基本原则，如果有一套严格的分批介入和退出程序，这一切都变得简单。 资金管理问题，涉及面很广，以后会专门分析介绍，这里说的是另一个方面， 就是如何能在投资领域尽量避免碰到“早泄”男。 “早泄”出现的根本原因在于介入程序出现破缺，出现程序所不能概括的异常情况， 这对于所有程序都是必然存在的。而一个程序出现异常，也就是出现“早泄”的概率有多大， 这是可以通过长期的数据测试来确定的。最简单的就是抛硬币，正面买、背面不买， 这样也算一个介入程序，但这样一个程序的“早泄”率，至少是50%。 以上。现在的问题其实很简单，就是如何发现一个“早泄”率特别低的介入程序。但答案很不幸， 任何一个孤立的程序都不会有太低的“早泄”率，如果一个程序的“早泄”率低于10%， 那就是超一流的程序了，按照这个程序，你投资10次，最多失误1次，这样的程序是很厉害的， 基本没有。 但问题不像表面所见那么糟，在数学中，有一个乘法原则可以完全解决这个问题。 假设三个互相独立的程序的“早泄”率分别为30%、40%、30%，这都是很普通的并不出色的程序。 那么由这三个程序组成的程序组，其“早泄”率就是30%*40%*30%=3.6%，也就是说，按这个程序组， 干100次，只会出现不到4次的“早泄”，这绝对是一个惊人的结果。即使对于选面首来说， 有这样的高效率，大概连武则天大姐都要满意了。 现在，问题的关键变成，如何去寻找这三个互相独立的程序。首先，技术指标， 都单纯涉及价量的输入而来，都不是独立的，只需要选择任意一个技术指标构成一个买卖程序就可以。 对于水平高点的人来说，一个带均线和成交量的K线图，比任何技术指标都有意义。 其次，任何一个股票都不是独立的，在整个股票市场中，处在一定的比价关系中， 这个比价关系的变动，也可以构成一个买卖系统，这个买卖系统是和市场资金的流向相关的， 一切与市场资金相关的系统，都不能与之独立；最后，可以选择基本面构成一个甄别“早泄”男程序， 但这个基本面不是单纯指公司赢利之类的，像本ID在前几期所说， 国航李总当兵出身不会让自己的股票长期跌破发行价这么没面子，还有认沽权证基本不会让兑现等等， 这才是更重要的基本面，这需要对市场的参与者、对人性有更多的了解才可能精通。 当然，上面这三个独立的程序只是本ID随手而写，任何人都可以设计自己的独立交易程序组， 但原则是一致的，就是三个程序组之间必须是互相独立的，像人气指标和资金面其实是一回事情， 各种技术指标都是互相相关的等等，如果把三个非独立的程序弄在一起，一点意义都没有。 就像有人告诉你，面首的鼻子大就不会“早泄”，另一个告诉你耳朵大不会“早泄”， 第三个告诉你胡子多不会“早泄”，如果真按这三样来选人， 估计连武则天大姐的奶妈的邻居都会不满意的。 借地说说如何看本ID的文章，本ID不是股评，不会推荐什么股票， 所以希望来本ID这里知道什么具体股票的，就不要浪费时间了。试想，真有本事的人， 挣钱都忙不过来，怎么会当股评。本ID这里，股票只是其中一个小项目， 只是希望来这里的人也学会怎么挣钱。所谓六艺，不会挣钱，在经济社会里还算人吗？ 看本ID的文章，要学会方法，当然，本ID有时候可能有意无意就会透露点东西，但你必须有分析能力， 要吃透方法。就像10月24日告诉你认购权证介入的一个原则，26日武钢认购权证就大幅启动， 2周从3毛多长到1块多，翻了快4倍，如果你真能吃透本ID所说的方法，这种机会是可以把握的。 至于现实的股市，本ID在前面已经反复说了，只要是牛市，股票都要表现的， 前几天大家可能都很烦银行股，因为大家都没有，但昨天开始大家就高兴了，因为银行股不动， 其他股票开始动。别恨银行股，哪天它们真见顶了，市场也好不了，它们是红旗， 各位只要看着红旗还在打，各根据地就可以继续轮动大干了。股票的运动是有规律的，好好学习， 这一切都能在你的把握中。至于说本ID想炫耀自己，这种废话根本不值得反驳。 本ID在投资市场曾干过事情牛的程度超过你们所有人的想象，本ID还用向你们炫耀？ 本ID现在只是把东西抖点出来，活跃一下博客的气氛，没有其他任何想法。","link":"/%E6%95%99%E4%BD%A0%E7%82%92%E8%82%A1%E7%A5%A89%EF%BC%9A%E7%94%84%E5%88%AB%E2%80%9C%E6%97%A9%E6%B3%84%E2%80%9D%E7%94%B7%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E5%88%99%EF%BC%81/"},{"title":"美团最新 iOS 面试真题总结（多线程、架构、网络、内存管理等）","text":"美团最新 iOS 面试真题总结本文整理了美团 iOS 岗位面试中常见的真题及面试官关注的知识点，涵盖多线程、网络协议、架构设计、内存管理等核心内容。适合准备美团及大厂 iOS 面试的同学参考。 一面题目（项目经验 + 多线程 + 网络协议 + 适配） 简历项目详述，面试官针对项目细节提问 Android Volley 源码及图片缓存机制深入探讨，讨论 HTTP 缓存机制 iOS 视图控制器（ViewController）生命周期理解 数据库相关知识 多线程相关知识点：NSThread、NSOperation、GCD+Block HTTP 协议 GET 和 POST 区别 手机屏幕适配方案 真机调试技巧及项目上线注意事项 静态方法是否可以被重写及相关讨论 面试官语速较快，需要注意答题节奏，保持从容 二面题目（Objective-C基础 + 设计模式 + 单元测试） id 和 nil 的含义及区别（nil 与 NULL 区别） 向 nil 对象发送消息的行为 HTTP 同步与异步的区别 MVC 与 MVVM 架构区别及实现 业务示例： VC 入口，VC1 显示“省”列表，VC2 显示“市”列表，VC3 显示“县”列表 设计 ViewModel 和 Model 的结构 VC3 跳转回 VC 的设计 单元测试设计：网络库测试用例设计及覆盖点 从 Git 拉代码到生成 .ipa 文件的全过程及涉及文件 近期阅读的书籍和开源框架及收获分享 JSPatch 如何处理 Block 擅长领域和职业挫折经历分享 新增问题：无 Instruments 工具时如何检测内存泄漏（Memory Leak）和僵尸对象（Zombie） 三面题目（资源管理 + 网络协议 + 设计模式 + 算法） iOS 资源管理机制详解 Python 语言的重要特性介绍 网络五层结构及各层协议 补充问答：MAC 地址与 IP 地址区别 单例模式与全局变量区别 Block 与 Protocol 区别及 Block 的设计目的 iOS 中常用设计模式介绍 为什么 iOS 没有类似 Java 或 C++ 的 Builder 构造模式 冒泡排序、插入排序、快速排序的平均与最坏时间复杂度 堆排序简介 是否存在时间复杂度为 O(n) 的排序算法 近期解决的 Stack Overflow 问题分享 读过的开源框架和书籍推荐 业余兴趣和成就感经历 总结美团 iOS 面试侧重基础扎实、项目实战经验丰富，尤其强调多线程理解、架构设计能力及网络协议掌握。建议重点准备： iOS 生命周期和内存管理（ARC/MRC） 多线程及GCD使用 MVC与MVVM设计模式理解 网络协议及异步处理 算法复杂度及常见排序算法 单元测试及代码质量保障 Runtime及消息机制 祝你面试成功，顺利拿下美团 iOS 岗位！如需详细讲解或代码示例，欢迎随时联系。","link":"/%E7%BE%8E%E5%9B%A2-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"腾讯最新iOS面试真题总结（网络、架构、算法与多线程）","text":"腾讯最新 iOS 面试真题总结本文整理了腾讯 iOS 岗位面试中常见真题，涵盖网络请求、线程与进程、内存管理、设计模式、常见算法等多方面内容。适合腾讯及其它大厂iOS面试准备。 一面题目 介绍实习项目及分工 项目内容、个人负责的功能模块、所用技术栈等。 网络相关 用过哪些网络库？ASIHTTP了解吗？ 断点续传实现及相关设置。 访问速度差异分析：杭州请求快，深圳请求慢，如何排查？ HTTP请求常用方法（GET、POST、PUT），各自使用场景。 TCP建立连接过程、断开连接过程，为什么是“四次握手”。 数据存储 项目中用过哪些存储方式？iOS中常见数据存储方式及适用场景。 MVVM实现绑定机制 Block和通知的区别及适用场景 算法题 多个数组相关的递进算法题，重点是找出数组中重复数字。 进程和线程的区别 程序运行时，操作系统除了分配内存外还做什么？ 进程间通信方式 如何检测应用卡顿 Crash日志收集机制 如何在无第三方平台情况下收集崩溃日志？第三方平台的工作原理。 Block中使用@property是否会造成循环引用？如何避免？ 是否可以用self-&gt;_property或valueForKey访问？ Block中是否可以修改属性值？如何正确操作。 二面题目 Objective-C对象结构 多态机制 Ping协议是什么？ MTU（最大传输单元）了解多少？ ARC和MRC的本质区别 NSThread、GCD、NSOperation的使用 如何开启线程？线程能取消吗？ 子线程调用Connection为何不回调？ 因为未加入RunLoop，执行完即销毁。 MVC与MVVM的区别 了解哪些设计模式？ 设计通讯录的数据结构支持增删改查 autorelease对象何时释放？ 手动添加释放时机（大括号结束），系统自动释放时机（RunLoop循环结束）。 子线程中的autorelease变量何时释放？需要加autoreleasepool吗？ GCD与NSOperation区别 死锁的理解及解决经验 ViewController生命周期 init方法里设置背景颜色会生效吗？为什么？ WWDC 2016新特性了解 源码阅读经验分享 链表相关算法题 找两个链表的第一个相同节点 字符串旋转判断 找链表倒数第k个节点 将链表中比某值大的节点放左边，比它小的放右边 二叉树中序遍历（非递归实现） 总结腾讯iOS面试考察广泛，注重理论基础与实践结合。建议重点准备： 网络请求与协议原理 进程线程与内存管理机制 iOS架构设计模式 Block及运行时机制 多线程与死锁防范 常见数据结构与算法 欢迎留言交流，分享面试经验与题解，祝你面试顺利通过腾讯大厂！","link":"/%E8%85%BE%E8%AE%AF-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"阿里巴巴 iOS 面试真题总结（含一二三面详解）","text":"本文总结了阿里巴巴 2024 年 iOS 面试中的经典真题，涵盖三轮面试，内容包括底层原理（KVO、Block、Runtime）、性能优化、线程安全等问题。适合正在准备 iOS 面试的同学参考。 阿里一面真题回顾这轮面试以基础原理为主，涉及 Objective-C Runtime、KVO、Block、字典原理和方法替换技术等。 1. KVO 是如何知道对象发生变化的？考察 Objective-C 的动态特性，涉及 isa-swizzling、NSKeyValueObserving 的底层实现。 2. NSDictionary 是如何实现快速查找的？哈希表结构，查找操作的时间复杂度趋近 O(1)，考察哈希函数设计与冲突处理策略。 3. 不破坏原方法，如何修复潜在 bug？推荐使用 Method Swizzling 技术或 AOP 思维，保持原接口不变的前提下增强逻辑。 4. Block 和函数指针的区别？Block 是带上下文的对象，支持捕获外部变量；函数指针是纯函数地址，效率高但灵活性差。 5. 性能优化的手段有哪些？内存管理、懒加载、线程调度优化、避免主线程卡顿、图片缓存处理等。 6. YYModel 和 AFNetworking 源码分析要求你对第三方库内部结构有基本认知，至少理解 AF 的请求封装流程和 YYModel 的动态绑定过程。 7. 如何自己设计 JSON -&gt; Model 转换？如可用 KVC、Runtime + 属性枚举等方式封装通用转换逻辑。 阿里二面真题详解侧重于内存管理、线程机制与设计思想，问题较为深入。 1. 浅拷贝和深拷贝的区别？浅拷贝仅复制指针引用；深拷贝会开辟新空间并复制内容，通常实现 copyWithZone: 方法。 2. Block 循环引用与解决方案？Block 捕获强引用对象如 self，造成循环引用，常用 __weak 或 __block 打破循环。 3. Block 与 delegate 比较？Block 更轻便、适合短期回调；delegate 适合长期、结构化通信。 4. KVO 的实现原理？本质是 isa 指向中间类，实现 set 方法的重写并通知观察者。 5. AutoreleasePool 的实现原理？调用栈会创建多个 autorelease pool，底层基于双向链表结构管理对象释放。 6. 消息转发机制？三重转发机制：resolveInstanceMethod: → forwardingTargetForSelector: → forwardInvocation:，是 iOS 动态特性的核心。 7. 死锁的四个必要条件？互斥、占有且等待、不可抢占、循环等待，任意破坏一个即可避免死锁。 8. 进程与线程的区别？进程是资源分配的基本单位，线程是执行调度的基本单位，线程共享进程内存。 9. 数据持久化方案？NSUserDefaults、归档、SQLite、CoreData、Keychain 等。 10. Masonry 的约束应该写在哪里？面试中讨论应放在 updateConstraints 或 layoutSubviews，需权衡复用次数与性能。 阿里三面：场景题 &amp; 架构思维三面偏向项目实战经验和系统设计思维。 1. 项目难点与解决方案介绍自我介绍和项目挑战重点是沟通能力和技术深度的双重考察。 2. 主线程是相对于什么而言？相对于操作系统调度中的主执行队列（main dispatch queue），即 UI 操作需在主线程执行。 3. 图片内存占用由什么决定？内存大小 = 宽度 × 高度 × 每像素字节数（RGBA 为 4），与图片压缩格式无关。 4. 索引的作用及优缺点？加快数据检索速度；但增加写入负担、占用存储、需要维护。 5. 如何在数组中找最小的 K 个数？常用方法包括快排变种、最小堆、Partition 算法等。 6. 淘宝下拉加载更多如何优化？预加载、懒加载、分页请求、防抖节流、接口合并、骨架屏设计等。 7. 淘宝页面发起 HTTP 请求流程？从点击触发 → Controller → ViewModel/Service → 网络库（如 AF）→ 请求封装 → 数据返回 → 数据绑定。 8. 介绍 MVVM 架构及应用？Model-View-ViewModel 解耦视图和逻辑，ViewModel 负责业务逻辑转换和绑定数据源。 9. 你了解哪些设计模式？单例、观察者、工厂、策略、责任链、适配器、代理等；可结合项目阐述其使用场景。 面试总结 &amp; 建议通过这次阿里 iOS 面试可以看出重点包括： 语言底层机制：KVO、Runtime、AutoreleasePool、Block 原理等； 性能与架构能力：如网络优化、内存管理、线程调度； 实战与沟通能力：项目介绍、逻辑思维、代码能力； 系统设计思维：索引、并发、缓存、架构模式等。 📝 准备建议： 回顾 iOS 面试八股文知识点； 多刷高频题，多做 Mock Interview； 建立知识图谱，串联底层原理与应用场景； 敢于表达自己的观点，结合项目经历讲解思路。 希望本文能帮助到正在准备 iOS 面试的你，祝你顺利拿到心仪的 Offer！🚀","link":"/%E9%98%BF%E9%87%8C-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"虎牙最新 iOS 面试真题总结（含 ARC、RunLoop、多线程、网络等）","text":"本文汇总了虎牙 iOS 面试中遇到的最新真题，涵盖项目架构、内存管理、锁机制、网络协议、多线程、视频技术等多个核心模块，适合准备大厂 iOS 岗位的同学参考学习。 面试说明由于时间有限，本文主要记录真题与核心知识点，未提供全部详细答案。欢迎交流和补充。 一面题目（项目架构+底层原理+锁） 项目架构是自己设计的吗？请介绍一下 FPS（帧率）是怎么计算的？ 除了 CADisplayLink，还有哪些计算 FPS 的方法？ KVO（键值观察）是如何实现的？ Leaks 是怎么实现的？ 如何通过代码监听僵尸对象？ imageWithName 方法什么时候发生图片解码？在哪个线程？ isa 指针里面包含哪些信息？ Objective-C 消息发送和消息转发的流程？ 函数的参数是如何存储的？ OC 空函数里面有参数吗？ 参数存储在栈还是寄存器？ 红黑树查找的时间复杂度？ NSDictionary 是如何实现的？ iOS 中常见的锁有哪些？ 如何实现 dispatch_once？需要考虑哪些问题？ 同一线程里连续使用两个 @synchronized，是递归锁还是非递归锁？ 如何增加按钮的点击范围？ 二面题目（内存管理+消息机制+网络协议） ARC（自动引用计数）原理介绍 autoreleasepool 的作用及使用场景 autoreleasepool 中的对象什么时候释放？ 消息转发可以用来做什么？ RunLoop 是什么？你用 RunLoop 做过什么？ C++ 多态和虚函数表机制 TCP 如何保证数据传输的完整性？ TCP 为什么需要三次握手？ HTTP 和 HTTPS 全程都是非对称加密吗？ 面对乱序数据，你如何设计排序方案？ 对 RxSwift 的看法，实际项目中用过吗？ 三面题目（对象内存+网络+多线程+视频） iOS 对象指针大小是多少？ 对象分配是在堆还是栈？ HTTP 请求如何区分 Header 和 Body？ 多线程能否同时访问同一个对象？多进程呢？ 视频中的 PTS 和 DTS 是什么？ 视频丢帧时，是丢 PTS 好还是丢 DTS 好？ iOS 各种锁的性能如何？锁的粒度是毫秒还是微秒级别？ HTTP 请求是异步还是同步？ 你怎么看待 React Native 和 Flutter？ 核心知识点总结 主题 关键内容 项目架构 MVC/MVVM、模块化设计、性能优化 FPS计算 CADisplayLink、Core Animation KVO实现 isa-swizzling、消息转发 内存管理 ARC、自动释放池、引用计数 锁机制 OSSpinLock、NSLock、pthread_mutex RunLoop 事件监听、模式切换、定时器管理 网络协议 HTTP/HTTPS、TCP三次握手、数据完整性 多线程 GCD、NSOperation、线程安全 视频技术 PTS/DTS、丢帧策略 跨平台框架 React Native 与 Flutter 对比 参考建议 重点掌握底层原理，尤其是内存管理与锁机制 熟悉网络通信协议及传输安全机制 理解多线程同步与死锁问题 视频相关基础理论及实践经验 对跨平台方案有基本认知和评价能力 欢迎大家点赞收藏，有任何问题或经验分享，欢迎留言交流！祝你面试顺利，早日拿下心仪的 iOS 岗位！","link":"/%E8%99%8E%E7%89%99-%E6%9C%80%E6%96%B0iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"iOS面试题","slug":"iOS面试题","link":"/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Block","slug":"Block","link":"/tags/Block/"},{"name":"NSNotification","slug":"NSNotification","link":"/tags/NSNotification/"},{"name":"Runloop&amp;KVO","slug":"Runloop-KVO","link":"/tags/Runloop-KVO/"},{"name":"Runtime","slug":"Runtime","link":"/tags/Runtime/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Runloop","slug":"Runloop","link":"/tags/Runloop/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"},{"name":"通知机制解析","slug":"通知机制解析","link":"/tags/%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"},{"name":"视图&amp;图形","slug":"视图-图形","link":"/tags/%E8%A7%86%E5%9B%BE-%E5%9B%BE%E5%BD%A2/"},{"name":"iOS面试真题","slug":"iOS面试真题","link":"/tags/iOS%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"},{"name":"头条","slug":"头条","link":"/tags/%E5%A4%B4%E6%9D%A1/"},{"name":"iOS基础","slug":"iOS基础","link":"/tags/iOS%E5%9F%BA%E7%A1%80/"},{"name":"架构设计","slug":"架构设计","link":"/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"name":"网络通信","slug":"网络通信","link":"/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"系统底层","slug":"系统底层","link":"/tags/%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82/"},{"name":"快手","slug":"快手","link":"/tags/%E5%BF%AB%E6%89%8B/"},{"name":"抖音","slug":"抖音","link":"/tags/%E6%8A%96%E9%9F%B3/"},{"name":"iOS开发","slug":"iOS开发","link":"/tags/iOS%E5%BC%80%E5%8F%91/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"拼多多","slug":"拼多多","link":"/tags/%E6%8B%BC%E5%A4%9A%E5%A4%9A/"},{"name":"JSON解析","slug":"JSON解析","link":"/tags/JSON%E8%A7%A3%E6%9E%90/"},{"name":"多线程安全","slug":"多线程安全","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"事件响应","slug":"事件响应","link":"/tags/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"炒股入门","slug":"炒股入门","link":"/tags/%E7%82%92%E8%82%A1%E5%85%A5%E9%97%A8/"},{"name":"投资心理","slug":"投资心理","link":"/tags/%E6%8A%95%E8%B5%84%E5%BF%83%E7%90%86/"},{"name":"股票实战","slug":"股票实战","link":"/tags/%E8%82%A1%E7%A5%A8%E5%AE%9E%E6%88%98/"},{"name":"缠中说禅","slug":"缠中说禅","link":"/tags/%E7%BC%A0%E4%B8%AD%E8%AF%B4%E7%A6%85/"},{"name":"经济人","slug":"经济人","link":"/tags/%E7%BB%8F%E6%B5%8E%E4%BA%BA/"},{"name":"股票投资","slug":"股票投资","link":"/tags/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84/"},{"name":"投机市场","slug":"投机市场","link":"/tags/%E6%8A%95%E6%9C%BA%E5%B8%82%E5%9C%BA/"},{"name":"人民币升值","slug":"人民币升值","link":"/tags/%E4%BA%BA%E6%B0%91%E5%B8%81%E5%8D%87%E5%80%BC/"},{"name":"投资心态","slug":"投资心态","link":"/tags/%E6%8A%95%E8%B5%84%E5%BF%83%E6%80%81/"},{"name":"市场心理","slug":"市场心理","link":"/tags/%E5%B8%82%E5%9C%BA%E5%BF%83%E7%90%86/"},{"name":"投资陷阱","slug":"投资陷阱","link":"/tags/%E6%8A%95%E8%B5%84%E9%99%B7%E9%98%B1/"},{"name":"缠论","slug":"缠论","link":"/tags/%E7%BC%A0%E8%AE%BA/"},{"name":"投资哲学","slug":"投资哲学","link":"/tags/%E6%8A%95%E8%B5%84%E5%93%B2%E5%AD%A6/"},{"name":"理性投资","slug":"理性投资","link":"/tags/%E7%90%86%E6%80%A7%E6%8A%95%E8%B5%84/"},{"name":"股票操作","slug":"股票操作","link":"/tags/%E8%82%A1%E7%A5%A8%E6%93%8D%E4%BD%9C/"},{"name":"市场哲学","slug":"市场哲学","link":"/tags/%E5%B8%82%E5%9C%BA%E5%93%B2%E5%AD%A6/"},{"name":"投资思维","slug":"投资思维","link":"/tags/%E6%8A%95%E8%B5%84%E6%80%9D%E7%BB%B4/"},{"name":"股票市场","slug":"股票市场","link":"/tags/%E8%82%A1%E7%A5%A8%E5%B8%82%E5%9C%BA/"},{"name":"投资实战","slug":"投资实战","link":"/tags/%E6%8A%95%E8%B5%84%E5%AE%9E%E6%88%98/"},{"name":"直觉交易","slug":"直觉交易","link":"/tags/%E7%9B%B4%E8%A7%89%E4%BA%A4%E6%98%93/"},{"name":"猎手心法","slug":"猎手心法","link":"/tags/%E7%8C%8E%E6%89%8B%E5%BF%83%E6%B3%95/"},{"name":"庄家","slug":"庄家","link":"/tags/%E5%BA%84%E5%AE%B6/"},{"name":"赢家与输家","slug":"赢家与输家","link":"/tags/%E8%B5%A2%E5%AE%B6%E4%B8%8E%E8%BE%93%E5%AE%B6/"},{"name":"投资策略","slug":"投资策略","link":"/tags/%E6%8A%95%E8%B5%84%E7%AD%96%E7%95%A5/"},{"name":"股票投机","slug":"股票投机","link":"/tags/%E8%82%A1%E7%A5%A8%E6%8A%95%E6%9C%BA/"},{"name":"权证操作","slug":"权证操作","link":"/tags/%E6%9D%83%E8%AF%81%E6%93%8D%E4%BD%9C/"},{"name":"五粮液","slug":"五粮液","link":"/tags/%E4%BA%94%E7%B2%AE%E6%B6%B2/"},{"name":"包钢","slug":"包钢","link":"/tags/%E5%8C%85%E9%92%A2/"},{"name":"缠论投资","slug":"缠论投资","link":"/tags/%E7%BC%A0%E8%AE%BA%E6%8A%95%E8%B5%84/"},{"name":"市场逻辑","slug":"市场逻辑","link":"/tags/%E5%B8%82%E5%9C%BA%E9%80%BB%E8%BE%91/"},{"name":"牛市策略","slug":"牛市策略","link":"/tags/%E7%89%9B%E5%B8%82%E7%AD%96%E7%95%A5/"},{"name":"散户指导","slug":"散户指导","link":"/tags/%E6%95%A3%E6%88%B7%E6%8C%87%E5%AF%BC/"},{"name":"iOS面试","slug":"iOS面试","link":"/tags/iOS%E9%9D%A2%E8%AF%95/"},{"name":"百度","slug":"百度","link":"/tags/%E7%99%BE%E5%BA%A6/"},{"name":"风险管理","slug":"风险管理","link":"/tags/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/"},{"name":"数学原理","slug":"数学原理","link":"/tags/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"name":"美团","slug":"美团","link":"/tags/%E7%BE%8E%E5%9B%A2/"},{"name":"腾讯","slug":"腾讯","link":"/tags/%E8%85%BE%E8%AE%AF/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"算法题","slug":"算法题","link":"/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"阿里","slug":"阿里","link":"/tags/%E9%98%BF%E9%87%8C/"},{"name":"iOS进阶","slug":"iOS进阶","link":"/tags/iOS%E8%BF%9B%E9%98%B6/"},{"name":"虎牙","slug":"虎牙","link":"/tags/%E8%99%8E%E7%89%99/"},{"name":"ARC","slug":"ARC","link":"/tags/ARC/"},{"name":"RunLoop","slug":"RunLoop","link":"/tags/RunLoop/"}],"categories":[{"name":"iOS开发","slug":"iOS开发","link":"/categories/iOS%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"iOS开发/面试题","link":"/categories/iOS%E5%BC%80%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"好文收录","slug":"好文收录","link":"/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/"},{"name":"缠论原文","slug":"好文收录/缠论原文","link":"/categories/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95/%E7%BC%A0%E8%AE%BA%E5%8E%9F%E6%96%87/"}],"pages":[]}